<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ACE Shot Diagrams - Pool Table Preview</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #0d0d1a;
      color: #eee;
      min-height: 100vh;
      overflow: hidden;
    }

    /* Hidden header in fullscreen mode */
    h1,
    .version-info {
      display: none;
    }

    /* Full-screen table container */
    .diagram-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .table-wrapper {
      position: relative;
      width: 95vw;
    }

    .table-wrapper svg#pool-table-svg {
      display: block;
      width: 100%;
      height: auto;
    }

    /* Connection overlay must match table size */
    .table-wrapper #connection-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 50;
    }

    /* ============================================
       FLOATING TOOL PALETTES - Glassmorphism Style
       ============================================ */
    .tool-palette {
      position: fixed;
      background: rgba(26, 26, 46, 0.85);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
      z-index: 2000;
      transition: opacity 0.3s, transform 0.2s, box-shadow 0.2s;
      user-select: none;
    }

    .tool-palette:hover {
      box-shadow: 0 12px 40px rgba(0, 0, 0, 0.5);
    }

    /* Palette header - draggable area */
    .palette-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 14px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.08);
      cursor: grab;
      border-radius: 12px 12px 0 0;
      background: rgba(255, 255, 255, 0.03);
    }

    .palette-header:active {
      cursor: grabbing;
    }

    .palette-title {
      font-size: 11px;
      font-weight: 600;
      color: #8af;
      text-transform: uppercase;
      letter-spacing: 1px;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .palette-title-icon {
      font-size: 14px;
    }

    .palette-controls {
      display: flex;
      gap: 6px;
    }

    .palette-btn {
      width: 20px;
      height: 20px;
      min-width: 20px;
      min-height: 20px;
      max-width: 20px;
      max-height: 20px;
      border-radius: 4px;
      border: none;
      outline: none;
      background: rgba(255, 255, 255, 0.1);
      color: #888;
      font-size: 14px;
      font-weight: bold;
      line-height: 1;
      padding: 0;
      margin: 0;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      box-sizing: border-box;
      transition: background 0.2s, color 0.2s;
    }

    .palette-btn:hover {
      background: rgba(255, 255, 255, 0.2);
      color: #fff;
    }

    .palette-btn:focus {
      outline: none;
      box-shadow: 0 0 0 2px rgba(100, 150, 255, 0.5);
    }

    /* Palette body */
    .palette-body {
      padding: 12px 14px;
    }

    /* Larger panels (all except balls and cue) */
    #palette-game .palette-header,
    #palette-shot .palette-header,
    #palette-legend .palette-header,
    #palette-aids .palette-header,
    #palette-actions .palette-header,
    #palette-save .palette-header {
      padding: 12px 18px;
    }

    #palette-game .palette-title,
    #palette-shot .palette-title,
    #palette-legend .palette-title,
    #palette-aids .palette-title,
    #palette-actions .palette-title,
    #palette-save .palette-title {
      font-size: 13px;
    }

    #palette-game .palette-body,
    #palette-shot .palette-body,
    #palette-legend .palette-body,
    #palette-aids .palette-body,
    #palette-actions .palette-body,
    #palette-save .palette-body {
      padding: 16px 18px;
    }

    /* Minimized state - compact icon-only display */
    .tool-palette.minimized .palette-body {
      display: none !important;
    }

    .tool-palette.minimized {
      border-radius: 10px !important;
      min-width: 0 !important;
      width: fit-content !important;
      height: fit-content !important;
      max-width: fit-content !important;
      padding: 0 !important;
      cursor: pointer;
    }

    .tool-palette.minimized .palette-header {
      border-bottom: none !important;
      border-radius: 10px;
      padding: 8px 12px !important;
      min-height: 0 !important;
      height: auto !important;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }

    .tool-palette.minimized .palette-title {
      font-size: 0px !important;  /* Hide text */
      line-height: 1 !important;
      color: transparent !important;
      overflow: visible !important;
      width: 28px !important;  /* Just wide enough for icon */
      height: 28px !important;
      display: flex !important;
      align-items: center;
      justify-content: center;
    }

    /* Show just the icon at full size */
    .tool-palette.minimized .palette-title-icon {
      font-size: 22px !important;
      line-height: 1 !important;
      width: 28px !important;
      height: 28px !important;
      display: flex !important;
      align-items: center;
      justify-content: center;
      color: #fff !important;  /* Make icon white */
    }

    .tool-palette.minimized .palette-controls {
      display: none !important;
    }

    /* Hidden state */
    .tool-palette.hidden {
      display: none;
    }

    /* Palette anchor positions */
    #palette-balls {
      top: 60px;   /* Moved down to avoid blocking top-left pocket click */
      left: 60px;  /* Moved right to avoid blocking top-left pocket click */
    }

    #palette-cue {
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      min-width: 600px;
    }

    #palette-game {
      top: 30px;
      right: 30px;
    }

    #palette-aids {
      right: 30px;
      top: 50%;
      transform: translateY(-50%);
    }

    #palette-actions {
      top: 30px;
      left: 50%;
      transform: translateX(-50%);
    }

    /* Legend and Shot Info removed - merged into other palettes */
    #palette-legend,
    #palette-shot,
    #palette-save {
      display: none;
    }

    /* Dragging state */
    .tool-palette.dragging {
      opacity: 0.9;
      box-shadow: 0 16px 48px rgba(0, 0, 0, 0.6);
      z-index: 2001;
    }

    /* Idle state - slightly dimmed */
    body:not(.has-shot) .tool-palette {
      opacity: 0.75;
    }

    body:not(.has-shot) .tool-palette:hover {
      opacity: 1;
    }

    /* ============================================
       PALETTE-SPECIFIC STYLES
       ============================================ */

    /* Ball Rack Palette */
    #palette-balls .ball-grid {
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      gap: 4px;
    }

    #palette-balls .ball-row-special {
      display: flex;
      gap: 6px;
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px solid rgba(255, 255, 255, 0.08);
      justify-content: center;
    }

    /* Cue Controls Palette - Minimalist Horizontal Layout */
    #palette-cue {
      min-width: 280px;
      max-width: 320px;
    }

    #palette-cue .palette-body {
      padding: 10px 12px;
    }

    #palette-cue .cue-controls-compact {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    #palette-cue .cue-top-row {
      display: flex;
      align-items: stretch;  /* Stretch to fill height so shoot button goes to bottom */
      gap: 12px;
    }

    #palette-cue .spin-diagram-compact {
      flex-shrink: 0;
      height: 100px;  /* Match SVG height explicitly */
    }

    #palette-cue .spin-diagram-compact svg {
      display: block;
    }

    #palette-cue .power-shoot-column {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 8px;
      min-height: 100px;  /* Match spin diagram */
      position: relative;  /* For absolute positioning of shoot button */
    }

    #palette-cue .power-row {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    #palette-cue .power-row .control-label {
      font-size: 11px;
      color: #888;
      min-width: 40px;
    }

    #palette-cue .power-row input[type="range"] {
      flex: 1;
      height: 6px;
    }

    #palette-cue .power-row .force-value {
      font-size: 12px;
      font-weight: bold;
      color: #0af;
      min-width: 35px;
      text-align: right;
    }

    #palette-cue .shoot-row {
      position: absolute;
      bottom: 0;
      right: 0;
    }

    #palette-cue .shoot-btn-compact {
      padding: 8px 16px;
      font-size: 13px;
      font-weight: bold;
      background: linear-gradient(135deg, #0066cc, #0044aa);
      border: none;
      border-radius: 6px;
      color: white;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 6px;
      transition: all 0.2s;
    }

    #palette-cue .shoot-btn-compact:hover {
      background: linear-gradient(135deg, #0077dd, #0055bb);
      transform: scale(1.02);
    }

    /* Legacy grid layout - keep for compatibility */
    #palette-cue .cue-controls-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 16px;
    }

    #palette-cue .control-column {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    #palette-cue .control-row {
      display: flex;
      gap: 16px;
      align-items: flex-start;
    }

    /* Game/Solver Palette */
    #palette-game .game-content {
      display: flex;
      flex-direction: column;
      gap: 14px;
      min-width: 200px;
    }

    #palette-game .game-mode-select {
      font-size: 14px;
      padding: 10px 12px;
    }

    #palette-game .game-mode-description {
      font-size: 13px;
    }

    /* Shot Info Palette */
    #palette-shot {
      min-width: 320px;
      max-width: 380px;
    }

    /* Quick Actions Palette (top center) */
    #palette-actions {
      min-width: 180px;
    }

    #palette-actions .action-buttons {
      display: flex;
      gap: 10px;
    }

    #palette-actions .action-btn {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 6px;
      padding: 12px 18px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      color: #ddd;
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s;
      flex: 1;
    }

    #palette-actions .action-btn:hover {
      background: rgba(255, 255, 255, 0.1);
      border-color: rgba(255, 255, 255, 0.2);
      color: #fff;
    }

    #palette-actions .action-btn .btn-icon {
      font-size: 24px;
    }

    #palette-actions .action-btn.primary {
      background: rgba(0, 200, 255, 0.15);
      border-color: rgba(0, 200, 255, 0.3);
      color: #0cf;
    }

    /* Save Palette (bottom center) - compact horizontal */
    #palette-save {
      min-width: 220px;
    }

    #palette-save .export-buttons {
      display: flex;
      gap: 8px;
    }

    #palette-save .export-btn {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      padding: 10px 16px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 6px;
      color: #aaa;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s;
      flex: 1;
    }

    #palette-save .export-btn:hover {
      background: rgba(255, 255, 255, 0.1);
      border-color: rgba(255, 255, 255, 0.2);
      color: #fff;
    }

    #palette-save .export-btn:active {
      transform: scale(0.96);
    }

    #palette-save .export-btn .btn-icon {
      font-size: 22px;
    }

    #palette-save .export-btn.primary {
      background: rgba(0, 255, 136, 0.15);
      border-color: rgba(0, 255, 136, 0.3);
      color: #0f8;
    }

    #palette-save .export-btn.primary:hover {
      background: rgba(0, 255, 136, 0.25);
      border-color: rgba(0, 255, 136, 0.5);
    }

    /* Position Aids Palette (right center) */
    #palette-aids {
      min-width: 220px;
    }

    #palette-aids .share-btn {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 16px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      color: #ddd;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s;
    }

    #palette-aids .share-btn:hover {
      background: rgba(255, 255, 255, 0.1);
      border-color: rgba(255, 255, 255, 0.2);
      color: #fff;
    }

    #palette-aids .share-btn .btn-icon {
      font-size: 16px;
      width: 20px;
      text-align: center;
    }

    /* Toast notification */
    .toast-notification {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%) translateY(100px);
      background: rgba(0, 255, 136, 0.9);
      color: #000;
      padding: 12px 24px;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      z-index: 9999;
      opacity: 0;
      transition: transform 0.3s ease, opacity 0.3s ease;
      pointer-events: none;
    }

    .toast-notification.show {
      transform: translateX(-50%) translateY(0);
      opacity: 1;
    }

    /* Status banner (persistent message at bottom center) */
    .status-banner {
      position: fixed;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(135deg, rgba(255, 68, 68, 0.95), rgba(180, 40, 40, 0.95));
      color: #fff;
      padding: 10px 20px;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      z-index: 1500;
      display: none;
      align-items: center;
      gap: 10px;
      box-shadow: 0 4px 20px rgba(255, 68, 68, 0.4);
      border: 1px solid rgba(255, 100, 100, 0.5);
    }

    .status-banner.visible {
      display: flex;
    }

    .status-banner .status-icon {
      font-size: 18px;
    }

    .status-banner .status-message {
      flex: 1;
    }

    .status-banner .status-suggestion {
      color: #ffcc00;
      font-weight: bold;
    }

    /* Position aids toggle section */
    #palette-aids .position-aids {
      margin-top: 0;
      padding-top: 0;
      border-top: none;
    }

    #palette-aids .position-aids .section-label {
      font-size: 11px;
      color: #8af;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 10px;
    }

    #palette-aids .toggle-row {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px 0;
      font-size: 14px;
      color: #aaa;
      cursor: pointer;
    }

    #palette-aids .toggle-row:hover {
      color: #fff;
    }

    #palette-aids .toggle-row input[type="checkbox"] {
      accent-color: #0fa;
    }

    #palette-aids .toggle-row input[type="checkbox"]:checked+span {
      color: #0fa;
    }

    /* Saved Diagrams Section */
    #palette-save .saved-diagrams {
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid rgba(255, 255, 255, 0.08);
    }

    #palette-save .save-input-row {
      display: flex;
      gap: 6px;
      margin-top: 8px;
    }

    #palette-save .save-input-row input {
      flex: 1;
      padding: 8px 10px;
      background: rgba(0, 0, 0, 0.3);
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 6px;
      color: #fff;
      font-size: 12px;
    }

    #palette-save .save-input-row input::placeholder {
      color: #666;
    }

    #palette-save .save-input-row input:focus {
      outline: none;
      border-color: #0fa;
    }

    #palette-save .save-input-row button {
      padding: 8px 12px;
      background: rgba(0, 255, 136, 0.2);
      border: 1px solid rgba(0, 255, 136, 0.3);
      border-radius: 6px;
      color: #0fa;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s;
    }

    #palette-save .save-input-row button:hover {
      background: rgba(0, 255, 136, 0.3);
    }

    #palette-save .saved-list {
      max-height: 150px;
      overflow-y: auto;
      margin-top: 8px;
    }

    #palette-save .saved-list::-webkit-scrollbar {
      width: 6px;
    }

    #palette-save .saved-list::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, 0.2);
      border-radius: 3px;
    }

    #palette-save .saved-list::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.2);
      border-radius: 3px;
    }

    #palette-save .saved-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 10px;
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(255, 255, 255, 0.06);
      border-radius: 6px;
      margin-bottom: 4px;
      transition: all 0.2s;
    }

    #palette-save .saved-item:hover {
      background: rgba(255, 255, 255, 0.08);
      border-color: rgba(255, 255, 255, 0.12);
    }

    #palette-save .saved-item-info {
      flex: 1;
      min-width: 0;
      cursor: pointer;
    }

    #palette-save .saved-item-name {
      font-size: 12px;
      color: #ddd;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    #palette-save .saved-item-date {
      font-size: 10px;
      color: #666;
      margin-top: 2px;
    }

    #palette-save .saved-item-actions {
      display: flex;
      gap: 4px;
      margin-left: 8px;
    }

    #palette-save .saved-item-btn {
      width: 24px;
      height: 24px;
      border-radius: 4px;
      border: none;
      background: rgba(255, 255, 255, 0.1);
      color: #888;
      font-size: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
    }

    #palette-save .saved-item-btn:hover {
      background: rgba(255, 255, 255, 0.2);
      color: #fff;
    }

    #palette-save .saved-item-btn.delete:hover {
      background: rgba(255, 80, 80, 0.3);
      color: #f66;
    }

    #palette-save .no-saved {
      text-align: center;
      color: #555;
      font-size: 11px;
      padding: 12px;
    }

    /* ============================================
       FIRST-TIME USER TOUR SYSTEM
       ============================================ */

    /* Tour overlay - dims everything except highlighted element */
    .tour-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.7);
      z-index: 9000;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .tour-overlay.active {
      opacity: 1;
      pointer-events: auto;
    }

    /* Tour spotlight - hole in overlay to show target element */
    .tour-spotlight {
      position: fixed;
      border-radius: 8px;
      box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.75);
      z-index: 9001;
      pointer-events: none;
      transition: all 0.4s ease;
    }

    .tour-spotlight.pulse {
      animation: tour-pulse 2s infinite;
    }

    @keyframes tour-pulse {

      0%,
      100% {
        box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.75), 0 0 0 0 rgba(0, 255, 136, 0.4);
      }

      50% {
        box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.75), 0 0 0 8px rgba(0, 255, 136, 0.2);
      }
    }

    /* Tour tooltip */
    .tour-tooltip {
      position: fixed;
      max-width: 360px;
      background: linear-gradient(135deg, #1a2a3a 0%, #0d1a26 100%);
      border: 2px solid #0fa;
      border-radius: 12px;
      padding: 0;
      z-index: 9002;
      box-shadow: 0 8px 32px rgba(0, 255, 136, 0.2);
      opacity: 0;
      transform: translateY(10px);
      transition: opacity 0.3s ease, transform 0.3s ease;
    }

    .tour-tooltip.active {
      opacity: 1;
      transform: translateY(0);
    }

    .tour-tooltip-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 16px;
      background: rgba(0, 255, 136, 0.1);
      border-bottom: 1px solid rgba(0, 255, 136, 0.2);
      border-radius: 10px 10px 0 0;
    }

    .tour-tooltip-title {
      font-size: 15px;
      font-weight: 600;
      color: #0fa;
      margin: 0;
    }

    .tour-tooltip-step {
      font-size: 11px;
      color: #8af;
      background: rgba(138, 170, 255, 0.1);
      padding: 4px 10px;
      border-radius: 12px;
    }

    .tour-tooltip-body {
      padding: 16px;
    }

    .tour-tooltip-content {
      font-size: 13px;
      line-height: 1.6;
      color: #ccc;
      margin-bottom: 12px;
    }

    .tour-tooltip-content strong {
      color: #fff;
    }

    .tour-tooltip-content .highlight {
      color: #0fa;
      font-weight: 600;
    }

    .tour-tooltip-task {
      background: rgba(0, 255, 136, 0.08);
      border-left: 3px solid #0fa;
      padding: 10px 12px;
      margin: 12px 0;
      font-size: 12px;
      color: #8f8;
      border-radius: 0 6px 6px 0;
    }

    .tour-tooltip-task::before {
      content: 'ðŸ‘† ';
    }

    .tour-tooltip-footer {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 16px;
      border-top: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(0, 0, 0, 0.2);
      border-radius: 0 0 10px 10px;
    }

    .tour-btn {
      padding: 8px 16px;
      border-radius: 6px;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      border: none;
    }

    .tour-btn-skip {
      background: transparent;
      color: #888;
    }

    .tour-btn-skip:hover {
      color: #fff;
    }

    .tour-btn-back {
      background: rgba(255, 255, 255, 0.1);
      color: #aaa;
      margin-right: 8px;
    }

    .tour-btn-back:hover {
      background: rgba(255, 255, 255, 0.15);
      color: #fff;
    }

    .tour-btn-next {
      background: linear-gradient(135deg, #0fa, #0a8);
      color: #000;
    }

    .tour-btn-next:hover {
      background: linear-gradient(135deg, #2fc, #0ca);
      transform: translateY(-1px);
    }

    .tour-btn-next:disabled {
      background: #444;
      color: #888;
      cursor: not-allowed;
      transform: none;
    }

    .tour-progress {
      display: flex;
      gap: 4px;
      margin-top: 12px;
    }

    .tour-progress-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.2);
      transition: all 0.2s;
    }

    .tour-progress-dot.completed {
      background: #0fa;
    }

    .tour-progress-dot.current {
      background: #0fa;
      transform: scale(1.3);
    }

    /* Arrow pointer for tooltip */
    .tour-tooltip-arrow {
      position: absolute;
      width: 12px;
      height: 12px;
      background: linear-gradient(135deg, #1a2a3a 0%, #0d1a26 100%);
      border: 2px solid #0fa;
      transform: rotate(45deg);
    }

    .tour-tooltip-arrow.top {
      top: -7px;
      border-right: none;
      border-bottom: none;
    }

    .tour-tooltip-arrow.bottom {
      bottom: -7px;
      border-left: none;
      border-top: none;
    }

    .tour-tooltip-arrow.left {
      left: -7px;
      border-right: none;
      border-top: none;
    }

    .tour-tooltip-arrow.right {
      right: -7px;
      border-left: none;
      border-bottom: none;
    }

    /* Welcome modal (first step) */
    .tour-welcome {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      max-width: 480px;
      text-align: center;
    }

    .tour-welcome .tour-tooltip-body {
      padding: 24px;
    }

    .tour-welcome-icon {
      font-size: 48px;
      margin-bottom: 16px;
    }

    .tour-welcome h2 {
      font-size: 22px;
      color: #fff;
      margin: 0 0 12px 0;
    }

    /* Tour trigger button in Share palette */
    .tour-start-btn {
      display: flex;
      align-items: center;
      gap: 8px;
      width: 100%;
      padding: 8px 12px;
      margin-top: 8px;
      background: rgba(138, 170, 255, 0.1);
      border: 1px dashed rgba(138, 170, 255, 0.3);
      border-radius: 6px;
      color: #8af;
      font-size: 11px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .tour-start-btn:hover {
      background: rgba(138, 170, 255, 0.2);
      border-color: rgba(138, 170, 255, 0.5);
      color: #adf;
    }

    /* Highlighted element during tour */
    .tour-highlight {
      position: relative;
      z-index: 9001 !important;
      pointer-events: auto !important;
    }

    /* Palette toggle buttons (when palette is hidden) */
    .palette-restore-btn {
      position: fixed;
      width: 36px;
      height: 36px;
      border-radius: 8px;
      background: rgba(26, 26, 46, 0.9);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      color: #8af;
      font-size: 16px;
      cursor: pointer;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 999;
      transition: transform 0.2s, background 0.2s;
    }

    .palette-restore-btn:hover {
      background: rgba(40, 40, 70, 0.95);
      transform: scale(1.1);
    }

    .palette-restore-btn.visible {
      display: flex;
    }

    #restore-balls {
      top: 20px;
      left: 20px;
    }

    #restore-cue {
      bottom: 20px;
      left: 20px;
    }

    #restore-legend {
      left: 20px;
      top: 50%;
      transform: translateY(-50%);
    }

    #restore-game {
      top: 20px;
      right: 20px;
    }

    #restore-shot {
      bottom: 20px;
      right: 20px;
    }

    /* Allow pocket targets to receive clicks */
    #pocket-targets {
      pointer-events: all;
    }

    /* Original ball rack - hidden, balls moved to palette */
    .ball-rack {
      display: none !important;
    }

    .rack-label {
      display: none;
    }

    /* Balls in palette grid */
    #paletteBallGrid {
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      gap: 4px;
    }

    #paletteBallSpecial {
      display: flex;
      gap: 8px;
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      justify-content: center;
    }

    /* Ball styling - size set dynamically via JS to match SVG scale */
    .ball {
      width: var(--ball-size, 24px);
      height: var(--ball-size, 24px);
      border-radius: 50%;
      cursor: grab;
      user-select: none;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5), inset -2px -2px 3px rgba(0, 0, 0, 0.3), inset 2px 2px 3px rgba(255, 255, 255, 0.2);
      transition: transform 0.1s;
      flex-shrink: 0;
      position: relative;
    }

    /* SVG label container inside ball */
    .ball-label-svg {
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    /* Base SVG text label styling */
    .ball-label {
      font-family: 'Segoe UI', Arial, sans-serif;
      font-weight: bold;
      paint-order: stroke fill;
    }

    /* Numbered balls - black text for white center circle */
    .ball-label-number {
      font-size: 42px;
      fill: #000;
      stroke: none;
    }

    /* Cue ball label */
    .ball-label-cue {
      font-size: 32px;
      fill: #666;
      stroke: none;
    }

    /* Ghost/AIM ball label */
    .ball-label-ghost {
      font-size: 32px;
      fill: rgba(255, 255, 255, 0.85);
      stroke: none;
    }

    .ball:hover {
      transform: scale(1.1);
    }

    .ball.dragging {
      cursor: grabbing;
      z-index: 200;
      transform: scale(1.15);
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.5);
    }

    .ball.on-table {
      position: absolute;
      z-index: 100;
    }

    /* Solid balls - white number circle (larger to fit text at same size as stripes) */
    .ball-1 {
      background: radial-gradient(circle, #fff 0%, #fff 33%, transparent 33%), radial-gradient(circle at 30% 30%, #ffe44d, #ffd700, #c9a600);
    }

    .ball-2 {
      background: radial-gradient(circle, #fff 0%, #fff 33%, transparent 33%), radial-gradient(circle at 30% 30%, #4d8fcc, #0066cc, #004c99);
    }

    .ball-3 {
      background: radial-gradient(circle, #fff 0%, #fff 33%, transparent 33%), radial-gradient(circle at 30% 30%, #ff6666, #ff4444, #cc0000);
    }

    .ball-4 {
      background: radial-gradient(circle, #fff 0%, #fff 33%, transparent 33%), radial-gradient(circle at 30% 30%, #9955bb, #6b2d8b, #4a1f61);
    }

    .ball-5 {
      background: radial-gradient(circle, #fff 0%, #fff 33%, transparent 33%), radial-gradient(circle at 30% 30%, #ff8833, #ff6600, #cc5200);
    }

    .ball-6 {
      background: radial-gradient(circle, #fff 0%, #fff 33%, transparent 33%), radial-gradient(circle at 30% 30%, #339955, #006633, #004422);
    }

    .ball-7 {
      background: radial-gradient(circle, #fff 0%, #fff 33%, transparent 33%), radial-gradient(circle at 30% 30%, #cc3333, #8b0000, #5c0000);
    }

    .ball-8 {
      background: radial-gradient(circle, #fff 0%, #fff 33%, transparent 33%), radial-gradient(circle at 30% 30%, #444, #111, #000);
    }

    /* Striped balls - white band in middle */
    .ball-9 {
      background: linear-gradient(180deg, #ffd700 0%, #ffd700 25%, #fff 25%, #fff 75%, #ffd700 75%);
    }

    .ball-10 {
      background: linear-gradient(180deg, #0066cc 0%, #0066cc 25%, #fff 25%, #fff 75%, #0066cc 75%);
    }

    .ball-11 {
      background: linear-gradient(180deg, #ff4444 0%, #ff4444 25%, #fff 25%, #fff 75%, #ff4444 75%);
    }

    .ball-12 {
      background: linear-gradient(180deg, #6b2d8b 0%, #6b2d8b 25%, #fff 25%, #fff 75%, #6b2d8b 75%);
    }

    .ball-13 {
      background: linear-gradient(180deg, #ff6600 0%, #ff6600 25%, #fff 25%, #fff 75%, #ff6600 75%);
    }

    .ball-14 {
      background: linear-gradient(180deg, #006633 0%, #006633 25%, #fff 25%, #fff 75%, #006633 75%);
    }

    .ball-15 {
      background: linear-gradient(180deg, #8b0000 0%, #8b0000 25%, #fff 25%, #fff 75%, #8b0000 75%);
    }

    /* Cue ball */
    .ball-cue {
      background: radial-gradient(circle at 30% 30%, #fff, #f0f0f0, #d0d0d0);
    }

    /* Ghost ball - transparent with dashed outline */
    .ball-ghost {
      background: transparent;
      border: 2px dashed rgba(255, 255, 255, 0.6);
      box-shadow: none;
    }

    /* Generic gray object ball */
    .ball-gray {
      background: radial-gradient(circle at 30% 30%, #aaa, #777, #555);
    }

    /* Separator in rack */
    .rack-separator {
      width: 1px;
      height: 24px;
      background: #444;
      margin: 0 8px;
    }

    .instructions {
      display: none;
      /* Hidden in fullscreen mode */
    }

    /* Shot info panel - now inside palette */
    .shot-info {
      display: none;
      /* Hidden - info now in palette */
    }

    .info-row {
      display: flex;
      gap: 8px;
    }

    .info-label {
      color: #888;
      font-size: 11px;
    }

    /* Screen reader only - visually hidden but accessible */
    .visually-hidden {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    .info-row span:last-child {
      color: #0fa;
      font-weight: bold;
    }

    /* Pocket targets */
    .pocket-target {
      cursor: pointer;
      pointer-events: all;
      fill: rgba(255, 215, 0, 0);
      transition: fill 0.2s;
    }

    .pocket-target:hover {
      fill: rgba(255, 215, 0, 0.3);
    }

    .pocket-target.selected {
      fill: rgba(0, 255, 170, 0.4);
      stroke: #0fa;
      stroke-width: 0.5;
    }

    /* Selected ball highlight - uses CSS variable for responsive sizing */
    .ball.selected {
      box-shadow: 0 0 0 var(--selection-ring, 2px) #0fa, 2px 2px 4px rgba(0, 0, 0, 0.5);
    }

    /* Cue Controls Panel - now inside palette */
    .cue-controls-panel {
      display: none;
      /* Hidden - controls now in palettes */
    }

    .control-label {
      font-size: 14px;
      color: #888;
      text-align: center;
      margin-bottom: 10px;
    }

    /* Overlap Diagram (Shooter's View) - horizontal layout */
    .overlap-diagram-container {
      display: flex;
      flex-direction: row;
      align-items: center;
      gap: 12px;
    }

    .overlap-diagram-wrapper {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    #overlap-diagram {
      border-radius: 4px;
      border: 1px solid #333;
    }

    .overlap-info {
      display: flex;
      flex-direction: column;
      gap: 4px;
      min-width: 100px;
    }

    .overlap-info .control-label {
      margin-bottom: 4px;
    }

    .overlap-fraction-english {
      font-size: 15px;
      color: #0fa;
      font-weight: bold;
    }

    .overlap-fraction-slash {
      font-size: 20px;
      color: #fff;
      font-weight: bold;
      font-family: 'Times New Roman', serif;
    }

    .overlap-percent {
      font-size: 12px;
      color: #888;
    }

    .overlap-percent span {
      color: #0fa;
    }

    /* Contact Diagram */
    .contact-diagram-container {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    #contact-diagram {
      background: #1a1a2e;
      border-radius: 8px;
      box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
    }

    /* Large contact diagram container */
    .contact-diagram-large {
      min-width: 336px;
    }

    /* Guide circle text styling */
    #contact-diagram .guide-clock text,
    #contact-diagram .guide-inner text {
      font-family: 'Segoe UI', Arial, sans-serif;
      font-weight: bold;
      dominant-baseline: middle;
    }

    #contact-diagram .english-legend text {
      font-family: 'Segoe UI', Arial, sans-serif;
    }

    #contact-point {
      transition: fill 0.15s;
    }

    #contact-point:hover {
      fill: #0088ff;
    }

    .spin-display {
      margin-top: 6px;
      font-size: 13px;
      color: #0fa;
      font-weight: bold;
    }

    /* Force Slider */
    .force-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      min-width: 150px;
    }

    .force-slider-wrapper {
      width: 100%;
    }

    #forceSlider {
      width: 100%;
      height: 8px;
      border-radius: 4px;
      background: linear-gradient(to right, #4a9, #fa0, #f44);
      -webkit-appearance: none;
      appearance: none;
      cursor: pointer;
    }

    #forceSlider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: #fff;
      border: 2px solid #333;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }

    #forceSlider::-moz-range-thumb {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: #fff;
      border: 2px solid #333;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }

    .force-labels {
      display: flex;
      justify-content: space-between;
      font-size: 10px;
      color: #666;
      margin-top: 4px;
    }

    .force-value {
      margin-top: 6px;
      font-size: 14px;
      color: #0fa;
      font-weight: bold;
    }

    /* Solver Options */
    .solver-options {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 120px;
    }

    .solver-options .control-label {
      margin-bottom: 4px;
    }

    .solver-radio-group {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .solver-radio-group label {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 14px;
      color: #aaa;
      cursor: pointer;
      padding: 6px 10px;
      border-radius: 4px;
      transition: background 0.2s;
    }

    .solver-radio-group label:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    .solver-radio-group input[type="radio"] {
      accent-color: #0fa;
    }

    .solver-radio-group input[type="radio"]:checked+span {
      color: #0fa;
      font-weight: bold;
    }

    .simple-view-toggle {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px solid #3a4a5a;
      font-size: 11px;
      color: #888;
      cursor: pointer;
    }

    .simple-view-toggle input[type="checkbox"] {
      accent-color: #0fa;
    }

    .simple-view-toggle input[type="checkbox"]:checked+span {
      color: #0fa;
    }

    /* Game Mode Selector */
    .game-mode-section {
      margin-bottom: 12px;
      padding-bottom: 12px;
      border-bottom: 1px solid #3a4a5a;
    }

    .game-mode-select {
      width: 100%;
      padding: 8px 12px;
      background: #1a2a3a;
      border: 1px solid #3a5a7a;
      border-radius: 6px;
      color: #fff;
      font-size: 13px;
      cursor: pointer;
      margin-top: 6px;
    }

    .game-mode-select:hover {
      border-color: #4a7a9a;
    }

    .game-mode-select:focus {
      outline: none;
      border-color: #0fa;
    }

    .game-mode-description {
      font-size: 10px;
      color: #9ab;
      margin-top: 6px;
      font-style: italic;
    }

    .suit-selector,
    .pocket-selector {
      margin-top: 8px;
      padding: 8px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 6px;
    }

    .suit-selector label,
    .pocket-selector label {
      display: flex;
      align-items: center;
      gap: 6px;
      margin: 4px 0;
      font-size: 11px;
      color: #aaa;
      cursor: pointer;
    }

    .suit-selector input[type="radio"],
    .pocket-selector input[type="radio"] {
      accent-color: #0fa;
    }

    .suit-selector input[type="radio"]:checked+span,
    .pocket-selector input[type="radio"]:checked+span {
      color: #0fa;
      font-weight: bold;
    }

    .pocket-label {
      font-size: 10px;
      color: #9ab;
      display: block;
      margin-bottom: 4px;
    }

    /* Path Legend Palette */
    #palette-legend .legend-content {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 12px;
      font-size: 14px;
      color: #bbb;
    }

    .legend-line {
      width: 28px;
      height: 4px;
      border-radius: 2px;
      flex-shrink: 0;
    }

    .legend-line.aim-line {
      background: repeating-linear-gradient(90deg, #fff 0, #fff 4px, transparent 4px, transparent 8px);
    }

    .legend-line.target-line {
      background: #ffd700;
    }

    .legend-line.obj-path {
      background: #ff6b35;
    }

    .legend-line.cb-path {
      background: #00bfff;
    }

    .legend-line.blocked-path {
      background: repeating-linear-gradient(90deg, #ff4444 0, #ff4444 3px, transparent 3px, transparent 6px);
    }

    .legend-line.kick-path {
      background: repeating-linear-gradient(90deg, #00ff88 0, #00ff88 4px, transparent 4px, transparent 8px);
    }

    .legend-line.combo-path {
      background: linear-gradient(90deg, #00ddff, #ff44ff, #aaff00);
    }

    /* Shot Instructions Panel - THE KEY ANSWER */
    .shot-instructions {
      background: linear-gradient(135deg, #1a2a3a 0%, #0d1a26 100%);
      border: 2px solid #2a4a5a;
      border-radius: 10px;
      padding: 12px 16px;
      margin-top: 12px;
      min-width: 280px;
    }

    .shot-instructions-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 10px;
      padding-bottom: 8px;
      border-bottom: 1px solid #2a4a5a;
    }

    .shot-instructions-title {
      font-size: 12px;
      font-weight: bold;
      color: #8af;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .shot-verdict {
      padding: 4px 12px;
      border-radius: 12px;
      font-size: 11px;
      font-weight: bold;
      text-transform: uppercase;
    }

    .shot-verdict.makeable {
      background: linear-gradient(135deg, #1a4a2a, #0d3a1a);
      color: #4f8;
      border: 1px solid #2a6a3a;
    }

    .shot-verdict.difficult {
      background: linear-gradient(135deg, #4a3a1a, #3a2a0d);
      color: #fa0;
      border: 1px solid #6a4a2a;
    }

    .shot-verdict.very-hard {
      background: linear-gradient(135deg, #4a1a1a, #3a0d0d);
      color: #f66;
      border: 1px solid #6a2a2a;
    }

    .shot-verdict.foul {
      background: linear-gradient(135deg, #5a1a1a, #4a0d0d);
      color: #ff4444;
      border: 1px solid #8a2a2a;
      animation: foul-pulse 1s ease-in-out infinite;
    }

    @keyframes foul-pulse {

      0%,
      100% {
        opacity: 1;
      }

      50% {
        opacity: 0.7;
      }
    }

    /* Foul warning banner - prominent alert at top of instructions */
    .foul-warning-banner {
      background: linear-gradient(135deg, #5a1a1a, #3a0d0d);
      border: 2px solid #ff4444;
      border-radius: 6px;
      padding: 8px 12px;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      gap: 8px;
      animation: foul-banner-pulse 0.8s ease-in-out infinite;
    }

    @keyframes foul-banner-pulse {

      0%,
      100% {
        transform: scale(1);
        border-color: #ff4444;
      }

      50% {
        transform: scale(1.02);
        border-color: #ff6666;
      }
    }

    .foul-icon {
      font-size: 18px;
      color: #ff4444;
    }

    .foul-message {
      font-size: 13px;
      font-weight: bold;
      color: #ff6666;
    }

    .shot-verdict.setup-needed {
      background: linear-gradient(135deg, #2a2a3a, #1a1a2a);
      color: #888;
      border: 1px solid #3a3a4a;
    }

    .instruction-steps {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .instruction-step {
      display: flex;
      align-items: flex-start;
      gap: 10px;
    }

    .step-number {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #2a4a5a;
      color: #8af;
      font-size: 11px;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }

    .step-content {
      flex: 1;
    }

    .step-label {
      font-size: 10px;
      color: #668;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .step-value {
      font-size: 13px;
      color: #fff;
      font-weight: 500;
    }

    .step-value.highlight {
      color: #ffd700;
    }

    .step-hint {
      font-size: 10px;
      color: #668;
      margin-top: 2px;
    }

    .power-status {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .power-status .enough {
      color: #4f8;
    }

    .power-status .not-enough {
      color: #f66;
    }

    .difficulty-bar {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: 10px;
      padding-top: 8px;
      border-top: 1px solid #2a4a5a;
    }

    .difficulty-label {
      font-size: 10px;
      color: #668;
      text-transform: uppercase;
    }

    .difficulty-meter {
      flex: 1;
      height: 6px;
      background: #1a2a3a;
      border-radius: 3px;
      overflow: hidden;
    }

    .difficulty-fill {
      height: 100%;
      border-radius: 3px;
      transition: width 0.3s, background 0.3s;
    }

    .difficulty-fill.easy {
      background: linear-gradient(90deg, #4f8, #2a6);
      width: 25%;
    }

    .difficulty-fill.medium {
      background: linear-gradient(90deg, #fa0, #c80);
      width: 50%;
    }

    .difficulty-fill.hard {
      background: linear-gradient(90deg, #f80, #c40);
      width: 75%;
    }

    .difficulty-fill.very-hard {
      background: linear-gradient(90deg, #f44, #c00);
      width: 100%;
    }

    .difficulty-fill.foul {
      background: linear-gradient(90deg, #f44, #900);
      width: 100%;
      animation: foul-pulse 1s ease-in-out infinite;
    }

    .difficulty-text {
      font-size: 11px;
      font-weight: bold;
      min-width: 60px;
      text-align: right;
    }

    .difficulty-text.easy {
      color: #4f8;
    }

    .difficulty-text.medium {
      color: #fa0;
    }

    .difficulty-text.hard {
      color: #f80;
    }

    .difficulty-text.very-hard {
      color: #f44;
    }

    .difficulty-text.foul {
      color: #ff4444;
    }

    /* ============================================
       MOBILE RESPONSIVE STYLES
       ============================================ */

    /* Tablet and below */
    @media (max-width: 1024px) {
      #palette-cue {
        min-width: 400px;
      }

      #palette-aids {
        top: auto;
        bottom: 30px;
        right: 30px;
        transform: none;
      }
    }

    /* Mobile landscape and portrait */
    @media (max-width: 768px) {
      body {
        padding: 10px;
      }

      h1 {
        font-size: 1.3rem;
        margin-bottom: 8px;
      }

      .version-info {
        font-size: 10px;
      }

      .instructions {
        display: none;
      }

      /* Full-width table */
      .diagram-container {
        width: 100%;
        max-height: 50vh;
      }

      #tableWrapper {
        width: 100%;
      }

      /* Stack palettes at bottom */
      .tool-palette {
        position: fixed;
        left: 10px !important;
        right: 10px !important;
        top: auto !important;
        bottom: auto !important;
        transform: none !important;
        width: auto !important;
        min-width: auto !important;
        max-width: none !important;
        border-radius: 10px;
        font-size: 12px;
      }

      /* Cue controls at bottom */
      #palette-cue {
        bottom: 10px !important;
        z-index: 2010;
      }

      /* Action buttons above cue */
      #palette-actions {
        bottom: 180px !important;
        z-index: 2005;
      }

      /* Ball palette - collapsible at top */
      #palette-balls {
        top: 10px !important;
        bottom: auto !important;
        z-index: 2000;
      }

      /* Game mode - hidden by default on mobile, accessible via minimized state */
      #palette-game {
        top: 10px !important;
        right: 10px !important;
        left: auto !important;
        width: auto !important;
      }

      /* Aids palette */
      #palette-aids {
        bottom: 280px !important;
        z-index: 2003;
      }

      /* Minimized palettes - auto size to fit icon */
      .tool-palette.minimized {
        width: auto !important;
        height: auto !important;
        left: auto !important;
        right: auto !important;
        padding: 0;
      }

      /* Larger touch targets */
      .palette-btn {
        width: 32px;
        height: 32px;
        min-width: 32px;
        min-height: 32px;
        max-width: 32px;
        max-height: 32px;
        font-size: 18px;
        border-radius: 6px;
      }

      .action-btn {
        padding: 12px 16px;
        font-size: 13px;
      }

      /* Simplify cue control layout */
      #palette-cue .palette-body {
        padding: 10px;
      }

      .cue-control-container {
        flex-direction: column;
        gap: 12px;
      }

      .english-diagram {
        width: 80px;
        height: 80px;
      }

      /* Force slider horizontal on mobile */
      .force-control {
        flex-direction: row;
        align-items: center;
        gap: 10px;
      }

      .force-slider-vertical {
        width: 100px;
        height: 8px;
        transform: none;
        writing-mode: horizontal-tb;
      }

      /* Ball grid - smaller on mobile */
      .palette-ball-grid {
        grid-template-columns: repeat(5, 1fr);
        gap: 4px;
      }

      .palette-ball-grid .ball {
        width: 28px;
        height: 28px;
      }

      /* Shot info - compact */
      .shot-info-value {
        font-size: 14px;
      }
    }

    /* Mobile portrait - extra small */
    @media (max-width: 480px) {
      h1 {
        font-size: 1.1rem;
      }

      .diagram-container {
        max-height: 40vh;
      }

      .palette-ball-grid {
        grid-template-columns: repeat(4, 1fr);
      }

      .palette-ball-grid .ball {
        width: 24px;
        height: 24px;
        font-size: 9px;
      }

      .english-diagram {
        width: 60px;
        height: 60px;
      }

      .action-btn span {
        display: none;
      }

      .action-btn {
        padding: 10px;
      }

      /* Auto-minimize most palettes on very small screens */
      #palette-game,
      #palette-aids {
        display: none;
      }
    }

    /* Print styles - preserve ball positions */
    @media print {
      body {
        background: #fff;
        padding: 10px;
        overflow: visible;
      }

      h1,
      .version-info,
      .instructions {
        display: none;
      }

      .tool-palette {
        display: none !important;
      }

      .palette-restore-btn {
        display: none !important;
      }

      .diagram-container {
        position: static;
        width: 100%;
        height: auto;
      }

      .table-wrapper {
        background: none;
        padding: 0;
        max-width: 100%;
        max-height: none;
      }

      .ball {
        print-color-adjust: exact;
        -webkit-print-color-adjust: exact;
      }

      .ball-ghost {
        border-color: #666;
      }

      #connection-overlay line {
        stroke: #333;
      }
    }
  </style>
</head>

<body>
  <h1>ACE Shot Diagrams</h1>
  <p class="version-info">Pool Table Template v009 - Drag balls to create shot diagrams</p>

  <div class="diagram-container" id="diagramContainer">
    <div class="table-wrapper" id="tableWrapper">
      <!-- Connection line SVG overlay -->
      <svg id="connection-overlay" viewBox="-8 -8 116 66" preserveAspectRatio="xMidYMid meet">
        <defs>
          <!-- Cue stick gradient - maple wood shaft with darker butt -->
          <linearGradient id="cue-shaft-gradient" x1="0%" y1="0%" x2="100%" y2="0%">
            <stop offset="0%" stop-color="#f4e4c1" />
            <stop offset="70%" stop-color="#e8d4a8" />
            <stop offset="85%" stop-color="#8b4513" />
            <stop offset="100%" stop-color="#5d3a1a" />
          </linearGradient>
          <!-- Ferrule (white part near tip) -->
          <linearGradient id="cue-ferrule-gradient" x1="0%" y1="0%" x2="100%" y2="0%">
            <stop offset="0%" stop-color="#4a90d9" />
            <stop offset="100%" stop-color="#f5f5f5" />
          </linearGradient>
        </defs>

        <!-- Cue stick visualization (semi-transparent, behind other elements) -->
        <g id="cue-stick" visibility="hidden" opacity="0.7">
          <!-- Main shaft - tapered rectangle -->
          <polygon id="cue-shaft" points="0,0 0,0 0,0 0,0" fill="url(#cue-shaft-gradient)" />
          <!-- Ferrule (white/ivory section near tip) -->
          <polygon id="cue-ferrule" points="0,0 0,0 0,0 0,0" fill="url(#cue-ferrule-gradient)" />
          <!-- Tip (blue chalk) -->
          <circle id="cue-tip" cx="0" cy="0" r="0.3" fill="#4a90d9" />
        </g>

        <!-- Cue to Ghost aiming line (path to support kick shots with bounces) -->
        <path id="cue-ghost-line" d="" stroke="#fff" stroke-width="0.3" stroke-dasharray="1,1" fill="none"
          visibility="hidden" />
        <!-- Actual kick path (where CB really goes with current english - differs from ideal) -->
        <path id="actual-kick-path" d="" stroke="#ff4444" stroke-width="0.25" stroke-dasharray="0.8,0.4" fill="none"
          opacity="0.7" visibility="hidden" />
        <!-- Object ball to Pocket target line -->
        <line id="target-line" x1="0" y1="0" x2="0" y2="0" stroke="#ffd700" stroke-width="0.25" visibility="hidden" />
        <!-- Object ball path (where OB actually travels - can be multi-segment for banks) -->
        <path id="obj-ball-path" d="" stroke="#ff6b35" stroke-width="0.3" fill="none" visibility="hidden" />
        <!-- Bank shot indicator (diamond on rail where OB bounces) -->
        <g id="bank-point-indicator" visibility="hidden">
          <polygon points="0,-0.7 0.7,0 0,0.7 -0.7,0" fill="#ff6b35" stroke="#cc4400" stroke-width="0.1" />
          <text id="bank-point-label" x="0" y="-1.3" text-anchor="middle" font-size="0.9" fill="#ff6b35">BANK</text>
        </g>
        <!-- Cue ball deflection path (tangent line + curve for spin) -->
        <path id="cue-ball-path" d="" stroke="#00bfff" stroke-width="0.3" fill="none" visibility="hidden" />

        <!-- Tangent line - shows where CB goes with stop shot (90Â° from contact) -->
        <g id="tangent-line-group" visibility="hidden">
          <line id="tangent-line" x1="0" y1="0" x2="0" y2="0" stroke="#00ffff" stroke-width="0.25"
            stroke-dasharray="0.8,0.4" opacity="0.7" />
          <text id="tangent-label" x="0" y="0" text-anchor="middle" font-size="1" fill="#00ffff"
            opacity="0.8">STOP</text>
        </g>

        <!-- Follow line - shows where CB goes with follow/top english -->
        <g id="follow-line-group" visibility="hidden">
          <line id="follow-line" x1="0" y1="0" x2="0" y2="0" stroke="#00ff00" stroke-width="0.25"
            stroke-dasharray="0.8,0.4" opacity="0.6" />
          <text id="follow-label" x="0" y="0" text-anchor="middle" font-size="1" fill="#00ff00"
            opacity="0.8">FOLLOW</text>
        </g>

        <!-- Draw line - shows where CB goes with draw/bottom english -->
        <g id="draw-line-group" visibility="hidden">
          <line id="draw-line" x1="0" y1="0" x2="0" y2="0" stroke="#ff6600" stroke-width="0.25"
            stroke-dasharray="0.8,0.4" opacity="0.6" />
          <text id="draw-label" x="0" y="0" text-anchor="middle" font-size="1" fill="#ff6600" opacity="0.8">DRAW</text>
        </g>

        <!-- Shape zone - triangular area showing where CB can be for next shot -->
        <g id="shape-zone-group" visibility="hidden">
          <path id="shape-zone-path" d="" fill="#00ff88" fill-opacity="0.12" stroke="#00ff88" stroke-width="0.2"
            stroke-opacity="0.4" />
          <text id="shape-zone-label" x="0" y="0" text-anchor="middle" font-size="1.2" fill="#00ff88"
            opacity="0.6">SHAPE ZONE</text>
        </g>

        <!-- Ghost ball position indicator - THE AIM TARGET -->
        <g id="ghost-ball-indicator" visibility="hidden">
          <!-- Outer glow ring -->
          <circle cx="0" cy="0" r="1.8" fill="none" stroke="rgba(255,215,0,0.3)" stroke-width="0.4" />
          <!-- Main target circle (ball size) -->
          <circle cx="0" cy="0" r="1.125" fill="rgba(255,215,0,0.15)" stroke="#ffd700" stroke-width="0.2" />
          <!-- Crosshair lines -->
          <line x1="-2.2" y1="0" x2="-1.4" y2="0" stroke="#ffd700" stroke-width="0.15" />
          <line x1="1.4" y1="0" x2="2.2" y2="0" stroke="#ffd700" stroke-width="0.15" />
          <line x1="0" y1="-2.2" x2="0" y2="-1.4" stroke="#ffd700" stroke-width="0.15" />
          <line x1="0" y1="1.4" x2="0" y2="2.2" stroke="#ffd700" stroke-width="0.15" />
          <!-- Center dot -->
          <circle cx="0" cy="0" r="0.2" fill="#ffd700" />
          <!-- AIM label -->
          <text x="0" y="-2.8" text-anchor="middle" font-size="1.2" font-weight="bold" fill="#ffd700">AIM</text>
        </g>
        <!-- Kick shot aim point indicator (diamond on rail) -->
        <g id="kick-aim-indicator" visibility="hidden">
          <polygon points="0,-0.8 0.8,0 0,0.8 -0.8,0" fill="#ff0" stroke="#cc0" stroke-width="0.1" />
          <text id="kick-aim-label" x="0" y="-1.5" text-anchor="middle" font-size="1" fill="#ff0">AIM</text>
        </g>
        <!-- Mirror system visualization for kick shots -->
        <g id="mirror-system-overlay" visibility="hidden">
          <!-- Mirror ghost ball (ghost mirrored across the kick rail) -->
          <g id="mirror-ghost">
            <circle cx="0" cy="0" r="1.125" fill="none" stroke="#ff00ff" stroke-width="0.15" stroke-dasharray="0.4,0.2"
              opacity="0.7" />
            <line x1="-0.8" y1="0" x2="0.8" y2="0" stroke="#ff00ff" stroke-width="0.1" opacity="0.7" />
            <line x1="0" y1="-0.8" x2="0" y2="0.8" stroke="#ff00ff" stroke-width="0.1" opacity="0.7" />
            <text x="0" y="-1.8" text-anchor="middle" font-size="0.9" fill="#ff00ff" opacity="0.8">MIRROR</text>
          </g>
          <!-- Aim line from CB through mirror ghost (shows true aim direction) -->
          <line id="mirror-aim-line" x1="0" y1="0" x2="0" y2="0" stroke="#ff00ff" stroke-width="0.12"
            stroke-dasharray="0.6,0.3" opacity="0.5" />
          <!-- Midpoint marker (for equal-distance visualization) -->
          <g id="midpoint-marker">
            <circle cx="0" cy="0" r="0.4" fill="#00ffff" opacity="0.6" />
            <text x="0" y="-0.8" text-anchor="middle" font-size="0.7" fill="#00ffff" opacity="0.8">MID</text>
          </g>
          <!-- Incoming angle arc (CB to rail) -->
          <path id="incoming-angle-arc" d="" fill="none" stroke="#00ff00" stroke-width="0.12" opacity="0.7" />
          <text id="incoming-angle-text" x="0" y="0" font-size="0.8" fill="#00ff00" opacity="0.9"></text>
          <!-- Outgoing angle arc (rail to ghost) -->
          <path id="outgoing-angle-arc" d="" fill="none" stroke="#ffaa00" stroke-width="0.12" opacity="0.7" />
          <text id="outgoing-angle-text" x="0" y="0" font-size="0.8" fill="#ffaa00" opacity="0.9"></text>
          <!-- English effect indicator (shows angle adjustment from spin) -->
          <g id="english-effect-indicator" visibility="hidden">
            <path id="english-effect-arc" d="" fill="none" stroke="#ff4444" stroke-width="0.15" opacity="0.8" />
            <text id="english-effect-text" x="0" y="0" font-size="0.7" fill="#ff4444" opacity="0.9"></text>
          </g>
        </g>
        <!-- Cue ball final resting position indicator (circle with X) - scaled to 1/3 ball size -->
        <g id="cb-final-position" visibility="hidden">
          <circle cx="0" cy="0" r="0.375" fill="none" stroke="#00bfff" stroke-width="0.08" />
          <line x1="-0.25" y1="-0.25" x2="0.25" y2="0.25" stroke="#00bfff" stroke-width="0.08" />
          <line x1="0.25" y1="-0.25" x2="-0.25" y2="0.25" stroke="#00bfff" stroke-width="0.08" />
        </g>
        <!-- Object ball final resting position indicator (circle with X) - scaled to 1/3 ball size -->
        <g id="ob-final-position" visibility="hidden">
          <circle cx="0" cy="0" r="0.375" fill="none" stroke="#ff6b35" stroke-width="0.08" />
          <line x1="-0.25" y1="-0.25" x2="0.25" y2="0.25" stroke="#ff6b35" stroke-width="0.08" />
          <line x1="0.25" y1="-0.25" x2="-0.25" y2="0.25" stroke="#ff6b35" stroke-width="0.08" />
        </g>
        <!-- Combination shot indicator -->
        <g id="combo-shot-indicator" visibility="hidden">
          <!-- Path 1: Cue â†’ Helper ball (dashed cyan - distinct from other paths) -->
          <path id="combo-path-1" d="" stroke="#00ddff" stroke-width="0.35" stroke-dasharray="0.8,0.4" fill="none" />
          <!-- Path 2: Helper â†’ Target ball (solid magenta - very distinct) -->
          <path id="combo-path-2" d="" stroke="#ff44ff" stroke-width="0.4" fill="none" />
          <!-- Path 3: Target â†’ Pocket (solid yellow-green) -->
          <path id="combo-path-3" d="" stroke="#aaff00" stroke-width="0.35" fill="none" />
          <!-- Helper ghost position indicator -->
          <g id="combo-helper-ghost">
            <circle r="1.125" fill="rgba(0,221,255,0.25)" stroke="#00ddff" stroke-width="0.2"
              stroke-dasharray="0.4,0.2" />
          </g>
          <!-- COMBO label -->
          <text id="combo-label" font-size="1.4" font-weight="bold" fill="#ff44ff" text-anchor="middle">COMBO</text>
        </g>
        <!-- Pocket click targets (invisible hit areas) -->
        <g id="pocket-targets">
          <circle class="pocket-target" data-pocket="corner-tl" cx="1.5" cy="1.5" r="4" />
          <circle class="pocket-target" data-pocket="corner-tr" cx="98.5" cy="1.5" r="4" />
          <circle class="pocket-target" data-pocket="corner-bl" cx="1.5" cy="48.5" r="4" />
          <circle class="pocket-target" data-pocket="corner-br" cx="98.5" cy="48.5" r="4" />
          <ellipse class="pocket-target" data-pocket="side-top" cx="50" cy="0" rx="4" ry="3" />
          <ellipse class="pocket-target" data-pocket="side-bottom" cx="50" cy="50" rx="4" ry="3" />
        </g>
      </svg>

      <!-- Pool Table SVG embedded inline (v009) -->
      <svg id="pool-table-svg" xmlns="http://www.w3.org/2000/svg" viewBox="-8 -8 116 66" role="img"
        aria-label="Pool table diagram">
        <title>Pool Table - Top Down View</title>
        <defs>
          <pattern id="wood-grain" patternUnits="userSpaceOnUse" width="4" height="4">
            <rect width="4" height="4" fill="#5a3825" />
            <path d="M0 2 Q1 1.5 2 2 T4 2" stroke="#4a2c2a" stroke-width="0.3" fill="none" opacity="0.5" />
            <path d="M0 3.5 Q1 3 2 3.5 T4 3.5" stroke="#6b4332" stroke-width="0.2" fill="none" opacity="0.3" />
          </pattern>
          <pattern id="cloth-texture" patternUnits="userSpaceOnUse" width="2" height="2">
            <rect width="2" height="2" fill="#50a6c2" />
            <circle cx="0.5" cy="0.5" r="0.1" fill="#5ab0cc" opacity="0.3" />
            <circle cx="1.5" cy="1.5" r="0.1" fill="#4596b2" opacity="0.3" />
          </pattern>
          <!-- ClipPaths for inside-only cushion strokes -->
          <clipPath id="clip-cushion-head">
            <polygon points="0,3.5 0,46.5 2,44.5 2,5.5" />
          </clipPath>
          <clipPath id="clip-cushion-foot">
            <polygon points="100,3.5 100,46.5 98,44.5 98,5.5" />
          </clipPath>
          <clipPath id="clip-cushion-top-left">
            <polygon points="3.5,0 47,0 45,2 5.5,2" />
          </clipPath>
          <clipPath id="clip-cushion-top-right">
            <polygon points="53,0 96.5,0 94.5,2 55,2" />
          </clipPath>
          <clipPath id="clip-cushion-bottom-left">
            <polygon points="3.5,50 47,50 45,48 5.5,48" />
          </clipPath>
          <clipPath id="clip-cushion-bottom-right">
            <polygon points="53,50 96.5,50 94.5,48 55,48" />
          </clipPath>
        </defs>

        <!-- Layer 1: Rails (Wood with rounded corners) -->
        <g id="layer-rails">
          <path id="rail-frame"
            d="M -2,-6 L 102,-6 A 4,4 0 0,1 106,-2 L 106,52 A 4,4 0 0,1 102,56 L -2,56 A 4,4 0 0,1 -6,52 L -6,-2 A 4,4 0 0,1 -2,-6 Z M 0,0 L 0,50 L 100,50 L 100,0 Z"
            fill="url(#wood-grain)" fill-rule="evenodd" />
        </g>

        <!-- Layer 3: Pocket Voids -->
        <g id="layer-pocket-voids">
          <!-- Corner pockets: circles at corners -->
          <circle cx="0" cy="0" r="4" fill="#050505" />
          <circle cx="100" cy="0" r="4" fill="#050505" />
          <circle cx="0" cy="50" r="4" fill="#050505" />
          <circle cx="100" cy="50" r="4" fill="#050505" />
          <!-- Side pockets: circles shifted outward for deeper, rounder pockets -->
          <!-- Center shifted so inner edge stays at same position, outer edge reaches ~same as corners -->
          <circle cx="50" cy="-0.75" r="3.25" fill="#050505" />
          <circle cx="50" cy="50.75" r="3.25" fill="#050505" />
        </g>

        <!-- Layer 4: Slate/Cloth -->
        <g id="layer-slate-cloth">
          <path id="slate-surface"
            d="M 0,3.5 A 3.5,3.5 0 0,0 3.5,0 L 47,0 L 47,0.3 A 3,0.3 0 0,0 53,0.3 L 53,0 L 96.5,0 A 3.5,3.5 0 0,0 100,3.5 L 100,46.5 A 3.5,3.5 0 0,0 96.5,50 L 53,50 L 53,49.7 A 3,0.3 0 0,0 47,49.7 L 47,50 L 3.5,50 A 3.5,3.5 0 0,0 0,46.5 Z"
            fill="#50a6c2" />
          <path
            d="M 0,3.5 A 3.5,3.5 0 0,0 3.5,0 L 47,0 L 47,0.3 A 3,0.3 0 0,0 53,0.3 L 53,0 L 96.5,0 A 3.5,3.5 0 0,0 100,3.5 L 100,46.5 A 3.5,3.5 0 0,0 96.5,50 L 53,50 L 53,49.7 A 3,0.3 0 0,0 47,49.7 L 47,50 L 3.5,50 A 3.5,3.5 0 0,0 0,46.5 Z"
            fill="url(#cloth-texture)" opacity="0.1" />
        </g>

        <!-- Layer 5: Cushions with inside-only strokes -->
        <g id="layer-cushions">
          <polygon points="0,3.5 0,46.5 2,44.5 2,5.5" fill="#50a6c2" />
          <polygon points="0,3.5 0,46.5 2,44.5 2,5.5" fill="none" stroke="#a8d3e1" stroke-width="0.35"
            clip-path="url(#clip-cushion-head)" />
          <polygon points="100,3.5 100,46.5 98,44.5 98,5.5" fill="#50a6c2" />
          <polygon points="100,3.5 100,46.5 98,44.5 98,5.5" fill="none" stroke="#a8d3e1" stroke-width="0.35"
            clip-path="url(#clip-cushion-foot)" />
          <polygon points="3.5,0 47,0 45,2 5.5,2" fill="#50a6c2" />
          <polygon points="3.5,0 47,0 45,2 5.5,2" fill="none" stroke="#a8d3e1" stroke-width="0.35"
            clip-path="url(#clip-cushion-top-left)" />
          <polygon points="53,0 96.5,0 94.5,2 55,2" fill="#50a6c2" />
          <polygon points="53,0 96.5,0 94.5,2 55,2" fill="none" stroke="#a8d3e1" stroke-width="0.35"
            clip-path="url(#clip-cushion-top-right)" />
          <polygon points="3.5,50 47,50 45,48 5.5,48" fill="#50a6c2" />
          <polygon points="3.5,50 47,50 45,48 5.5,48" fill="none" stroke="#a8d3e1" stroke-width="0.35"
            clip-path="url(#clip-cushion-bottom-left)" />
          <polygon points="53,50 96.5,50 94.5,48 55,48" fill="#50a6c2" />
          <polygon points="53,50 96.5,50 94.5,48 55,48" fill="none" stroke="#a8d3e1" stroke-width="0.35"
            clip-path="url(#clip-cushion-bottom-right)" />
        </g>

        <!-- Layer 6: Diamonds -->
        <g id="layer-diamonds">
          <g id="diamonds-top">
            <polygon points="12.5,-3 13,-3.5 13.5,-3 13,-2.5" fill="#f5f5dc" stroke="#b5a642" stroke-width="0.1" />
            <polygon points="25,-3 25.5,-3.5 26,-3 25.5,-2.5" fill="#f5f5dc" stroke="#b5a642" stroke-width="0.1" />
            <polygon points="37.5,-3 38,-3.5 38.5,-3 38,-2.5" fill="#f5f5dc" stroke="#b5a642" stroke-width="0.1" />
            <polygon points="62.5,-3 63,-3.5 63.5,-3 63,-2.5" fill="#f5f5dc" stroke="#b5a642" stroke-width="0.1" />
            <polygon points="75,-3 75.5,-3.5 76,-3 75.5,-2.5" fill="#f5f5dc" stroke="#b5a642" stroke-width="0.1" />
            <polygon points="87.5,-3 88,-3.5 88.5,-3 88,-2.5" fill="#f5f5dc" stroke="#b5a642" stroke-width="0.1" />
          </g>
          <g id="diamonds-bottom">
            <polygon points="12.5,53 13,52.5 13.5,53 13,53.5" fill="#f5f5dc" stroke="#b5a642" stroke-width="0.1" />
            <polygon points="25,53 25.5,52.5 26,53 25.5,53.5" fill="#f5f5dc" stroke="#b5a642" stroke-width="0.1" />
            <polygon points="37.5,53 38,52.5 38.5,53 38,53.5" fill="#f5f5dc" stroke="#b5a642" stroke-width="0.1" />
            <polygon points="62.5,53 63,52.5 63.5,53 63,53.5" fill="#f5f5dc" stroke="#b5a642" stroke-width="0.1" />
            <polygon points="75,53 75.5,52.5 76,53 75.5,53.5" fill="#f5f5dc" stroke="#b5a642" stroke-width="0.1" />
            <polygon points="87.5,53 88,52.5 88.5,53 88,53.5" fill="#f5f5dc" stroke="#b5a642" stroke-width="0.1" />
          </g>
          <g id="diamonds-head">
            <polygon points="-3,12.5 -3.5,13 -3,13.5 -2.5,13" fill="#f5f5dc" stroke="#b5a642" stroke-width="0.1" />
            <polygon points="-3,25 -3.5,25.5 -3,26 -2.5,25.5" fill="#f5f5dc" stroke="#b5a642" stroke-width="0.1" />
            <polygon points="-3,37.5 -3.5,38 -3,38.5 -2.5,38" fill="#f5f5dc" stroke="#b5a642" stroke-width="0.1" />
          </g>
          <g id="diamonds-foot">
            <polygon points="103,12.5 102.5,13 103,13.5 103.5,13" fill="#f5f5dc" stroke="#b5a642" stroke-width="0.1" />
            <polygon points="103,25 102.5,25.5 103,26 103.5,25.5" fill="#f5f5dc" stroke="#b5a642" stroke-width="0.1" />
            <polygon points="103,37.5 102.5,38 103,38.5 103.5,38" fill="#f5f5dc" stroke="#b5a642" stroke-width="0.1" />
          </g>
        </g>

        <!-- Layer 8: Spots -->
        <g id="layer-spots">
          <g id="head-spot">
            <circle cx="25" cy="25" r="0.8" fill="#1a1a1a" />
            <circle cx="25" cy="25" r="0.25" fill="#ffffff" />
          </g>
          <g id="foot-spot">
            <circle cx="75" cy="25" r="0.8" fill="#1a1a1a" />
            <circle cx="75" cy="25" r="0.25" fill="#ffffff" />
          </g>
        </g>

        <!-- Layer 9: Grid (hidden by default) -->
        <g id="layer-grid" opacity="0.15" visibility="visible">
          <line x1="12.5" y1="2" x2="12.5" y2="48" stroke="#ffffff" stroke-width="0.15" />
          <line x1="25" y1="2" x2="25" y2="48" stroke="#ffffff" stroke-width="0.15" />
          <line x1="37.5" y1="2" x2="37.5" y2="48" stroke="#ffffff" stroke-width="0.15" />
          <line x1="50" y1="2" x2="50" y2="48" stroke="#ffffff" stroke-width="0.15" />
          <line x1="62.5" y1="2" x2="62.5" y2="48" stroke="#ffffff" stroke-width="0.15" />
          <line x1="75" y1="2" x2="75" y2="48" stroke="#ffffff" stroke-width="0.15" />
          <line x1="87.5" y1="2" x2="87.5" y2="48" stroke="#ffffff" stroke-width="0.15" />
          <line x1="2" y1="12.5" x2="98" y2="12.5" stroke="#ffffff" stroke-width="0.15" />
          <line x1="2" y1="25" x2="98" y2="25" stroke="#ffffff" stroke-width="0.15" />
          <line x1="2" y1="37.5" x2="98" y2="37.5" stroke="#ffffff" stroke-width="0.15" />
        </g>
      </svg>
    </div>

    <!-- Ball Rack -->
    <div class="ball-rack" id="ballRack">
      <div class="rack-label">Drag balls onto the table - positions are preserved when printing</div>
    </div>

    <p class="instructions">Drag balls from rack to table. Balls return to rack if dropped outside. Cue-Ghost line
      appears when both are placed. Click a pocket to set target.</p>

    <!-- Shot Info Panel -->
    <div class="shot-info" id="shotInfo">
      <div class="info-row"><span class="info-label">Cut Angle:</span> <span id="cutAngleDisplay">--</span></div>
      <div class="info-row"><span class="info-label">Ball Hit:</span> <span id="overlapDisplay">--</span></div>
    </div>

    <!-- Cue Ball Controls Panel -->
    <div class="cue-controls-panel">
      <!-- Shooter's Eye View - Ball Overlap Diagram -->
      <div class="overlap-diagram-container">
        <div class="overlap-diagram-wrapper">
          <svg id="overlap-diagram" viewBox="-3 -1.5 6 3" width="200" height="100">
            <!-- Background -->
            <rect x="-3" y="-1.5" width="6" height="3" fill="#1a1a2e" />
            <!-- Object Ball (solid, slightly right) -->
            <circle id="overlap-obj-ball" cx="0.5" cy="0" r="1" fill="none" stroke="#ff6b35" stroke-width="0.06" />
            <text x="0.5" y="0.05" text-anchor="middle" font-size="0.28" fill="#ff6b35">OB</text>
            <!-- Ghost Ball (dashed, position based on overlap) -->
            <circle id="overlap-ghost-ball" cx="-0.5" cy="0" r="1" fill="rgba(255,215,0,0.15)" stroke="#ffd700"
              stroke-width="0.06" stroke-dasharray="0.12,0.08" />
            <text id="overlap-ghost-label" x="-0.5" y="0.05" text-anchor="middle" font-size="0.28"
              fill="#ffd700">GB</text>
            <!-- Overlap region highlight -->
            <clipPath id="clip-obj-ball">
              <circle cx="0.5" cy="0" r="1" />
            </clipPath>
            <circle id="overlap-region" cx="-0.5" cy="0" r="1" fill="rgba(0,255,170,0.25)"
              clip-path="url(#clip-obj-ball)" />
            <!-- Center line reference -->
            <line x1="-3" y1="0" x2="3" y2="0" stroke="#333" stroke-width="0.02" stroke-dasharray="0.08,0.08" />
          </svg>
        </div>
        <div class="overlap-info">
          <div class="control-label">Shooter's View</div>
          <div class="overlap-fraction-english" id="overlapEnglish">Half ball</div>
          <div class="overlap-fraction-slash" id="overlapSlash">1/2</div>
          <div class="overlap-percent"><span id="overlapPercent">50%</span> overlap</div>
        </div>
      </div>

      <!-- Cue Ball Contact Diagram -->
      <div class="contact-diagram-container">
        <div class="control-label">Cue Tip Contact</div>
        <svg id="contact-diagram-hidden" viewBox="-1.5 -1.5 3 3" width="100" height="100">
          <!-- Ball outline -->
          <circle cx="0" cy="0" r="1.125" fill="#e8e8e8" stroke="#999" stroke-width="0.05" />
          <!-- Miscue zone (outer ring) -->
          <circle cx="0" cy="0" r="1.125" fill="none" stroke="#ff4444" stroke-width="0.1" stroke-dasharray="0.15,0.1"
            opacity="0.3" />
          <!-- Safe zone boundary -->
          <circle cx="0" cy="0" r="0.56" fill="none" stroke="#4a4a4a" stroke-width="0.02" stroke-dasharray="0.1,0.05" />
          <!-- Crosshairs -->
          <line x1="-0.8" y1="0" x2="0.8" y2="0" stroke="#ccc" stroke-width="0.03" />
          <line x1="0" y1="-0.8" x2="0" y2="0.8" stroke="#ccc" stroke-width="0.03" />
          <!-- Zone labels -->
          <text x="0" y="-0.95" text-anchor="middle" font-size="0.18" fill="#666">Follow</text>
          <text x="0" y="1.05" text-anchor="middle" font-size="0.18" fill="#666">Draw</text>
          <text x="-0.95" y="0.05" text-anchor="middle" font-size="0.15" fill="#666">L</text>
          <text x="0.95" y="0.05" text-anchor="middle" font-size="0.15" fill="#666">R</text>
          <!-- Cue tip contact point (draggable) -->
          <circle id="contact-point-hidden" cx="0" cy="0" r="0.15" fill="#0066cc" stroke="#003366" stroke-width="0.03"
            cursor="move" />
        </svg>
        <div class="spin-display">
          <span id="spinType-hidden">Center</span>
        </div>
      </div>

      <!-- Force Slider -->
      <div class="force-container">
        <div class="control-label">Power</div>
        <div class="force-slider-wrapper">
          <input type="range" id="forceSlider" min="1" max="10" value="10" step="0.5" />
          <div class="force-labels">
            <span>Soft</span>
            <span>Medium</span>
            <span>Hard</span>
          </div>
        </div>
        <div class="force-value"><span id="forceValue">10</span>/10</div>
      </div>

      <!-- Game Mode Selector -->
      <div class="game-mode-section">
        <div class="control-label">Game</div>
        <select id="gameModeSelect" class="game-mode-select">
          <option value="9ball" selected>9-Ball</option>
          <option value="8ball">8-Ball</option>
          <option value="10ball">10-Ball</option>
          <option value="14.1">Straight Pool</option>
          <option value="1pocket">One Pocket</option>
        </select>
        <div class="game-mode-description" id="gameModeDescription">Hit lowest ball first. Pocket 9 to win.</div>
        <!-- 8-Ball suit selector (hidden by default) -->
        <div class="suit-selector" id="suitSelector" style="display: none;">
          <label><input type="radio" name="player-suit" value="solids" checked><span>Solids (1-7)</span></label>
          <label><input type="radio" name="player-suit" value="stripes"><span>Stripes (9-15)</span></label>
        </div>
        <!-- One Pocket pocket selector (hidden by default) -->
        <div class="pocket-selector" id="pocketSelector" style="display: none;">
          <span class="pocket-label">Your Pocket:</span>
          <label><input type="radio" name="player-pocket" value="corner-bl" checked><span>Bottom Left</span></label>
          <label><input type="radio" name="player-pocket" value="corner-br"><span>Bottom Right</span></label>
        </div>
      </div>

      <!-- Solver Options -->
      <div class="solver-options">
        <div class="control-label">Shot Preference:</div>
        <div class="solver-instructions" style="font-size:12px;color:#666;margin-bottom:8px;">Select an object ball and
          pocket</div>
        <div class="solver-radio-group">
          <label>
            <input type="radio" name="solver-mode" value="auto" checked>
            <span>Standard</span>
          </label>
          <label>
            <input type="radio" name="solver-mode" value="kick">
            <span>Prefer Kick</span>
          </label>
          <label>
            <input type="radio" name="solver-mode" value="bank">
            <span>Prefer Bank</span>
          </label>
          <label>
            <input type="radio" name="solver-mode" value="combo">
            <span>Prefer Combo</span>
          </label>
        </div>
        <label class="simple-view-toggle">
          <input type="checkbox" id="simpleViewToggle">
          <span>Simple View</span>
        </label>
      </div>

      <!-- Shot Instructions Panel - THE KEY ANSWER -->
      <div class="shot-instructions" id="shotInstructions">
        <!-- Foul warning banner (hidden by default) -->
        <div class="foul-warning-banner" id="foulWarningBanner" style="display: none;">
          <span class="foul-icon">âš </span>
          <span class="foul-message" id="foulMessage">Must hit legal ball first!</span>
        </div>
        <div class="shot-instructions-header">
          <span class="shot-instructions-title">Shot Instructions</span>
          <span class="shot-verdict setup-needed" id="shotVerdict">Setup Needed</span>
        </div>
        <div class="instruction-steps" id="instructionSteps">
          <div class="instruction-step">
            <div class="step-number">1</div>
            <div class="step-content">
              <div class="step-label">Aim</div>
              <div class="step-value" id="aimInstruction">Place cue ball and select pocket</div>
            </div>
          </div>
          <div class="instruction-step">
            <div class="step-number">2</div>
            <div class="step-content">
              <div class="step-label">English</div>
              <div class="step-value" id="englishInstruction">--</div>
              <div class="step-hint" id="englishHint"></div>
            </div>
          </div>
          <div class="instruction-step">
            <div class="step-number">3</div>
            <div class="step-content">
              <div class="step-label">Power</div>
              <div class="step-value power-status" id="powerInstruction">
                <span id="powerNeeded">--</span>
                <span id="powerStatus"></span>
              </div>
            </div>
          </div>
        </div>
        <div class="difficulty-bar">
          <span class="difficulty-label">Difficulty</span>
          <div class="difficulty-meter">
            <div class="difficulty-fill" id="difficultyFill"></div>
          </div>
          <span class="difficulty-text" id="difficultyText">--</span>
        </div>
      </div>
    </div>
  </div>

  <!-- ============================================
       FLOATING TOOL PALETTES
       ============================================ -->

  <!-- Palette: Ball Rack (Top-Left) -->
  <div class="tool-palette" id="palette-balls" role="region" aria-label="Ball rack - drag balls onto the table">
    <div class="palette-header">
      <span class="palette-title"><span class="palette-title-icon" aria-hidden="true">ðŸŽ±</span> Balls</span>
      <div class="palette-controls">
        <button class="palette-btn minimize" title="Minimize" aria-label="Minimize panel">âˆ’</button>
      </div>
    </div>
    <div class="palette-body">
      <div class="ball-grid" id="paletteBallGrid">
        <!-- Balls will be created here by JS -->
      </div>
      <div class="ball-row-special" id="paletteBallSpecial">
        <!-- Cue and Ghost balls -->
      </div>
    </div>
  </div>

  <!-- Palette: Cue Controls (Bottom-Left) - Minimalist Horizontal Layout -->
  <div class="tool-palette" id="palette-cue" role="region" aria-label="Cue controls - adjust spin, power, and execute shots">
    <div class="palette-header">
      <span class="palette-title"><span class="palette-title-icon" aria-hidden="true">ðŸŽ¯</span> Cue</span>
      <div class="palette-controls">
        <button class="palette-btn minimize" title="Minimize" aria-label="Minimize panel">âˆ’</button>
      </div>
    </div>
    <div class="palette-body">
      <div class="cue-controls-compact">
        <!-- Top row: Spin diagram + Power/Shoot -->
        <div class="cue-top-row">
          <!-- Compact Spin Diagram with spin type inside -->
          <div class="spin-diagram-compact">
            <svg id="contact-diagram" viewBox="-1 -1 2 2" width="100" height="100"
                 role="img" aria-label="Cue ball contact point - click to set spin">
              <!-- Ball outline -->
              <circle cx="0" cy="0" r="0.85" fill="#e8e8e8" stroke="#999" stroke-width="0.03" />

              <!-- Miscue zone boundary (outer edge) -->
              <circle cx="0" cy="0" r="0.85" fill="none" stroke="#ff4444" stroke-width="0.04"
                stroke-dasharray="0.1,0.06" opacity="0.3" />

              <!-- Inner safe zone ring -->
              <circle cx="0" cy="0" r="0.5" fill="none" stroke="#ff4444" stroke-width="0.015"
                stroke-dasharray="0.04,0.03" opacity="0.2" />

              <!-- Outer ring: All 12 clock positions (0.55 radius) -->
              <g class="guide-outer" opacity="0.8">
                <!-- 12 o'clock (Follow) -->
                <circle cx="0" cy="-0.55" r="0.08" fill="none" stroke="#f90" stroke-width="0.02" />
                <text x="0" y="-0.48" text-anchor="middle" font-size="0.09" fill="#f90" font-weight="bold">12</text>
                <!-- 1 o'clock -->
                <circle cx="0.275" cy="-0.476" r="0.06" fill="none" stroke="#f90" stroke-width="0.015" opacity="0.7" />
                <!-- 2 o'clock -->
                <circle cx="0.476" cy="-0.275" r="0.06" fill="none" stroke="#f90" stroke-width="0.015" opacity="0.7" />
                <!-- 3 o'clock -->
                <circle cx="0.55" cy="0" r="0.08" fill="none" stroke="#f90" stroke-width="0.02" />
                <text x="0.55" y="0.035" text-anchor="middle" font-size="0.09" fill="#f90" font-weight="bold">3</text>
                <!-- 4 o'clock -->
                <circle cx="0.476" cy="0.275" r="0.06" fill="none" stroke="#f90" stroke-width="0.015" opacity="0.7" />
                <!-- 5 o'clock -->
                <circle cx="0.275" cy="0.476" r="0.06" fill="none" stroke="#f90" stroke-width="0.015" opacity="0.7" />
                <!-- 6 o'clock (Draw) -->
                <circle cx="0" cy="0.55" r="0.08" fill="none" stroke="#f90" stroke-width="0.02" />
                <text x="0" y="0.6" text-anchor="middle" font-size="0.09" fill="#f90" font-weight="bold">6</text>
                <!-- 7 o'clock -->
                <circle cx="-0.275" cy="0.476" r="0.06" fill="none" stroke="#f90" stroke-width="0.015" opacity="0.7" />
                <!-- 8 o'clock -->
                <circle cx="-0.476" cy="0.275" r="0.06" fill="none" stroke="#f90" stroke-width="0.015" opacity="0.7" />
                <!-- 9 o'clock -->
                <circle cx="-0.55" cy="0" r="0.08" fill="none" stroke="#f90" stroke-width="0.02" />
                <text x="-0.55" y="0.035" text-anchor="middle" font-size="0.09" fill="#f90" font-weight="bold">9</text>
                <!-- 10 o'clock -->
                <circle cx="-0.476" cy="-0.275" r="0.06" fill="none" stroke="#f90" stroke-width="0.015" opacity="0.7" />
                <!-- 11 o'clock -->
                <circle cx="-0.275" cy="-0.476" r="0.06" fill="none" stroke="#f90" stroke-width="0.015" opacity="0.7" />
              </g>

              <!-- Inner ring: Compass positions (0.3 radius) -->
              <g class="guide-inner" opacity="0.7">
                <!-- N -->
                <circle cx="0" cy="-0.3" r="0.08" fill="none" stroke="#0af" stroke-width="0.02" />
                <text x="0" y="-0.27" text-anchor="middle" font-size="0.09" fill="#0af" font-weight="bold">N</text>
                <!-- S -->
                <circle cx="0" cy="0.3" r="0.08" fill="none" stroke="#0af" stroke-width="0.02" />
                <text x="0" y="0.33" text-anchor="middle" font-size="0.09" fill="#0af" font-weight="bold">S</text>
                <!-- W -->
                <circle cx="-0.3" cy="0" r="0.08" fill="none" stroke="#0af" stroke-width="0.02" />
                <text x="-0.3" y="0.03" text-anchor="middle" font-size="0.09" fill="#0af" font-weight="bold">W</text>
                <!-- E -->
                <circle cx="0.3" cy="0" r="0.08" fill="none" stroke="#0af" stroke-width="0.02" />
                <text x="0.3" y="0.03" text-anchor="middle" font-size="0.09" fill="#0af" font-weight="bold">E</text>
                <!-- Diagonals -->
                <circle cx="0.21" cy="-0.21" r="0.06" fill="none" stroke="#0af" stroke-width="0.015" opacity="0.5" />
                <circle cx="-0.21" cy="-0.21" r="0.06" fill="none" stroke="#0af" stroke-width="0.015" opacity="0.5" />
                <circle cx="0.21" cy="0.21" r="0.06" fill="none" stroke="#0af" stroke-width="0.015" opacity="0.5" />
                <circle cx="-0.21" cy="0.21" r="0.06" fill="none" stroke="#0af" stroke-width="0.015" opacity="0.5" />
              </g>

              <!-- Center marker with spin type inside -->
              <circle cx="0" cy="0" r="0.12" fill="rgba(0,170,255,0.15)" stroke="#0fa" stroke-width="0.02" />
              <text id="spinTypeInner" x="0" y="0.04" text-anchor="middle" font-size="0.13" fill="#0fa" font-weight="bold">Draw</text>

              <!-- Cue tip contact point (draggable) -->
              <circle id="contact-point" cx="0" cy="0.55" r="0.1" fill="#0066cc" stroke="#003366" stroke-width="0.025"
                cursor="move" />
            </svg>
          </div>

          <!-- Power and Shoot column -->
          <div class="power-shoot-column">
            <!-- Power row -->
            <div class="power-row">
              <span class="control-label">Power</span>
              <input type="range" id="forceSlider-palette" min="1" max="10" value="10" step="0.5"
                aria-label="Shot power" />
              <span class="force-value"><span id="forceValue-palette">10</span></span>
            </div>
            <!-- Shoot button -->
            <div class="shoot-row">
              <button class="shoot-btn-compact" id="btnShoot" title="Execute the shot"
                aria-label="Shoot - Execute the current shot">
                <span>ðŸŽ¯</span>
                <span>Shoot</span>
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Hidden: Legacy spin type display for JS compatibility -->
  <span id="spinType" style="display:none;">Draw</span>

  <!-- REMOVED: Old two-column layout with shot stats moved to Shot Info palette -->
  <div style="display:none;">
        <div class="control-column">
        <!-- Right Column: Shot Info -->
        <div class="control-column">
          <!-- Shooter's View Diagram -->
          <div class="overlap-diagram-container" style="margin-bottom:12px;">
            <div class="overlap-diagram-wrapper">
              <svg id="overlap-diagram-palette" viewBox="-3 -1.5 6 3" width="160" height="80">
                <rect x="-3" y="-1.5" width="6" height="3" fill="#1a1a2e" />
                <circle id="overlap-obj-ball-palette" cx="0.5" cy="0" r="1" fill="none" stroke="#ff6b35"
                  stroke-width="0.06" />
                <text x="0.5" y="0.05" text-anchor="middle" font-size="0.28" fill="#ff6b35">OB</text>
                <circle id="overlap-ghost-ball-palette" cx="-0.5" cy="0" r="1" fill="rgba(255,215,0,0.15)"
                  stroke="#ffd700" stroke-width="0.06" stroke-dasharray="0.12,0.08" />
                <text id="overlap-ghost-label-palette" x="-0.5" y="0.05" text-anchor="middle" font-size="0.28"
                  fill="#ffd700">GB</text>
                <clipPath id="clip-obj-ball-palette">
                  <circle cx="0.5" cy="0" r="1" />
                </clipPath>
                <circle id="overlap-region-palette" cx="-0.5" cy="0" r="1" fill="rgba(0,255,170,0.25)"
                  clip-path="url(#clip-obj-ball-palette)" />
                <line x1="-3" y1="0" x2="3" y2="0" stroke="#333" stroke-width="0.02" stroke-dasharray="0.08,0.08" />
              </svg>
            </div>
            <div class="overlap-info">
              <div class="overlap-fraction-english" id="overlapEnglish-palette">Half ball</div>
              <div class="overlap-fraction-slash" id="overlapSlash-palette">1/2</div>
            </div>
          </div>
          <!-- Shot Stats -->
          <div class="shot-stats" style="display:flex;flex-direction:column;gap:6px;font-size:12px;">
            <div class="info-row"><span class="info-label">Cut Angle:</span> <span
                id="cutAngleDisplay-palette">--</span>
            </div>
            <div class="info-row"><span class="info-label">Shot Type:</span> <span
                id="shotTypeDisplay-palette">--</span>
            </div>
            <div class="info-row"><span class="info-label">Make %:</span> <span id="makeProbabilityDisplay"
                style="font-weight:bold;color:#0f8;">--</span></div>
          </div>
          <!-- Difficulty Bar -->
          <div class="difficulty-bar" style="margin-top:12px;padding-top:10px;">
            <span class="difficulty-label">Difficulty</span>
            <div class="difficulty-meter">
              <div class="difficulty-fill" id="difficultyFill-palette"></div>
            </div>
            <span class="difficulty-text" id="difficultyText-palette">--</span>
          </div>
          <!-- Instructions -->
          <div class="shot-mini-instructions" id="shotMiniInstructions"
            style="margin-top:10px;padding-top:10px;border-top:1px solid rgba(255,255,255,0.08);font-size:11px;color:#9ab;">
            Place balls and select a pocket
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Palette: Game & Solver (Top-Right) - minimized by default -->
  <div class="tool-palette minimized" id="palette-game" role="region" aria-label="Game settings and shot preferences">
    <div class="palette-header">
      <span class="palette-title"><span class="palette-title-icon" aria-hidden="true">ðŸŽ®</span> Game</span>
      <div class="palette-controls">
        <button class="palette-btn minimize" title="Expand" aria-label="Expand panel">+</button>
      </div>
    </div>
    <div class="palette-body">
      <div class="game-content">
        <!-- Game Mode -->
        <div class="game-mode-section" style="margin:0;padding:0;border:0;">
          <label for="gameModeSelect-palette" class="visually-hidden">Game mode</label>
          <select id="gameModeSelect-palette" class="game-mode-select" aria-label="Select game mode">
            <option value="9ball" selected>9-Ball</option>
            <option value="8ball">8-Ball</option>
            <option value="10ball">10-Ball</option>
            <option value="14.1">Straight Pool</option>
            <option value="1pocket">One Pocket</option>
          </select>
          <div class="game-mode-description" id="gameModeDescription-palette" aria-live="polite">Hit lowest ball first</div>
          <div class="suit-selector" id="suitSelector-palette" style="display: none;" role="radiogroup" aria-label="Select your suit">
            <label><input type="radio" name="player-suit-palette" value="solids" checked><span>Solids</span></label>
            <label><input type="radio" name="player-suit-palette" value="stripes"><span>Stripes</span></label>
          </div>
          <div class="pocket-selector" id="pocketSelector-palette" style="display: none;" role="radiogroup" aria-label="Select your scoring pocket">
            <span class="pocket-label" id="pocket-label">Your Pocket:</span>
            <label><input type="radio" name="player-pocket-palette" value="corner-bl" checked><span>BL</span></label>
            <label><input type="radio" name="player-pocket-palette" value="corner-br"><span>BR</span></label>
          </div>
        </div>
        <!-- Solver Options -->
        <div class="solver-options" style="min-width:0;">
          <div class="control-label" id="solver-label">Shot Preference:</div>
          <div class="solver-instructions" style="font-size:12px;color:#666;margin-bottom:8px;">Select an object ball
            and pocket</div>
          <div class="solver-radio-group" role="radiogroup" aria-labelledby="solver-label">
            <label><input type="radio" name="solver-mode-palette" value="auto" checked><span>Standard</span></label>
            <label><input type="radio" name="solver-mode-palette" value="kick"><span>Kick</span></label>
            <label><input type="radio" name="solver-mode-palette" value="bank"><span>Bank</span></label>
            <label><input type="radio" name="solver-mode-palette" value="combo"><span>Combo</span></label>
          </div>
        </div>
        <!-- Export/Save Section -->
        <div class="export-save-section"
          style="margin-top:16px;padding-top:16px;border-top:1px solid rgba(255,255,255,0.1);">
          <div class="export-buttons">
            <button class="export-btn primary" id="btnCopyLink" title="Copy shareable link to clipboard">
              <span class="btn-icon">ðŸ”—</span>
              <span>Link</span>
            </button>
            <button class="export-btn" id="btnExportPNG" title="Download as PNG image">
              <span class="btn-icon">ðŸ–¼ï¸</span>
              <span>PNG</span>
            </button>
            <button class="export-btn" id="btnExportSVG" title="Download as SVG vector">
              <span class="btn-icon">ðŸ“</span>
              <span>SVG</span>
            </button>
          </div>
          <!-- Saved Diagrams -->
          <div class="saved-diagrams">
            <div class="section-label" id="saved-diagrams-label">Saved Diagrams</div>
            <div class="save-input-row">
              <input type="text" id="saveDiagramName" placeholder="Name..." maxlength="50"
                     aria-label="Diagram name to save">
              <button id="btnSaveDiagram" title="Save current diagram" aria-label="Save current diagram">Save</button>
            </div>
            <div class="saved-list" id="savedDiagramsList" role="list" aria-labelledby="saved-diagrams-label">
              <div class="no-saved">No saved diagrams</div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Palette: Legend (Left-Middle) -->
  <div class="tool-palette" id="palette-legend" role="region" aria-label="Line color legend">
    <div class="palette-header">
      <span class="palette-title"><span class="palette-title-icon" aria-hidden="true">ðŸŽ¨</span> Legend</span>
      <div class="palette-controls">
        <button class="palette-btn minimize" title="Minimize" aria-label="Minimize panel">âˆ’</button>
      </div>
    </div>
    <div class="palette-body">
      <div class="legend-content">
        <div class="legend-item"><span class="legend-line aim-line"></span> Aim Line</div>
        <div class="legend-item"><span class="legend-line target-line"></span> Target Line</div>
        <div class="legend-item"><span class="legend-line obj-path"></span> Object Ball</div>
        <div class="legend-item"><span class="legend-line cb-path"></span> Cue Ball</div>
        <div class="legend-item"><span class="legend-line kick-path"></span> Kick Shot</div>
        <div class="legend-item"><span class="legend-line blocked-path"></span> Blocked</div>
        <div class="legend-item"><span class="legend-line combo-path"></span> Combo</div>
      </div>
    </div>
  </div>

  <!-- Palette: Shot Info (Bottom-Right) -->
  <div class="tool-palette" id="palette-shot" role="region" aria-label="Shot information and statistics">
    <div class="palette-header">
      <span class="palette-title"><span class="palette-title-icon" aria-hidden="true">ðŸ“Š</span> Shot Info</span>
      <div class="palette-controls">
        <button class="palette-btn minimize" title="Minimize" aria-label="Minimize panel">âˆ’</button>
      </div>
    </div>
    <div class="palette-body">
      <!-- Shooter's View Diagram -->
      <div class="overlap-diagram-container" style="margin-bottom:12px;">
        <div class="overlap-diagram-wrapper">
          <svg id="overlap-diagram-palette" viewBox="-3 -1.5 6 3" width="160" height="80"
               role="img" aria-label="Ball overlap diagram showing cut angle from shooter perspective">
            <rect x="-3" y="-1.5" width="6" height="3" fill="#1a1a2e" />
            <circle id="overlap-obj-ball-palette" cx="0.5" cy="0" r="1" fill="none" stroke="#ff6b35"
              stroke-width="0.06" />
            <text x="0.5" y="0.05" text-anchor="middle" font-size="0.28" fill="#ff6b35">OB</text>
            <circle id="overlap-ghost-ball-palette" cx="-0.5" cy="0" r="1" fill="rgba(255,215,0,0.15)" stroke="#ffd700"
              stroke-width="0.06" stroke-dasharray="0.12,0.08" />
            <text id="overlap-ghost-label-palette" x="-0.5" y="0.05" text-anchor="middle" font-size="0.28"
              fill="#ffd700">GB</text>
            <clipPath id="clip-obj-ball-palette">
              <circle cx="0.5" cy="0" r="1" />
            </clipPath>
            <circle id="overlap-region-palette" cx="-0.5" cy="0" r="1" fill="rgba(0,255,170,0.25)"
              clip-path="url(#clip-obj-ball-palette)" />
            <line x1="-3" y1="0" x2="3" y2="0" stroke="#333" stroke-width="0.02" stroke-dasharray="0.08,0.08" />
          </svg>
        </div>
        <div class="overlap-info">
          <div class="overlap-fraction-english" id="overlapEnglish-palette">Half ball</div>
          <div class="overlap-fraction-slash" id="overlapSlash-palette">1/2</div>
        </div>
      </div>
      <!-- Shot Stats -->
      <div class="shot-stats" style="display:flex;flex-direction:column;gap:6px;font-size:12px;">
        <div class="info-row"><span class="info-label">Cut Angle:</span> <span id="cutAngleDisplay-palette">--</span>
        </div>
        <div class="info-row"><span class="info-label">Shot Type:</span> <span id="shotTypeDisplay-palette">--</span>
        </div>
        <div class="info-row"><span class="info-label">Make %:</span> <span id="makeProbabilityDisplay"
            style="font-weight:bold;color:#0f8;">--</span></div>
      </div>
      <!-- Difficulty Bar -->
      <div class="difficulty-bar" style="margin-top:12px;padding-top:10px;">
        <span class="difficulty-label">Difficulty</span>
        <div class="difficulty-meter">
          <div class="difficulty-fill" id="difficultyFill-palette"></div>
        </div>
        <span class="difficulty-text" id="difficultyText-palette">--</span>
      </div>
      <!-- Instructions -->
      <div class="shot-mini-instructions" id="shotMiniInstructions"
        style="margin-top:10px;padding-top:10px;border-top:1px solid rgba(255,255,255,0.08);font-size:11px;color:#9ab;">
        Place balls and select a pocket
      </div>
    </div>
  </div>

  <!-- Palette: Quick Actions (Top Center) -->
  <div class="tool-palette" id="palette-actions" role="region" aria-label="Quick actions">
    <div class="palette-header">
      <span class="palette-title"><span class="palette-title-icon" aria-hidden="true">âš¡</span> Actions</span>
      <div class="palette-controls">
        <button class="palette-btn minimize" title="Minimize" aria-label="Minimize panel">âˆ’</button>
      </div>
    </div>
    <div class="palette-body">
      <div class="action-buttons">
        <button class="action-btn primary" id="btnRandomRack" title="Rack balls and animate break shot"
          aria-label="Rack - Set up balls for a break shot">
          <span class="btn-icon" aria-hidden="true">ðŸŽ±</span>
          <span>Rack</span>
        </button>
        <button class="action-btn" id="btnStartTour" title="Learn how to use this tool"
          aria-label="Tour - Learn how to use this tool">
          <span class="btn-icon" aria-hidden="true">ðŸ“š</span>
          <span>Tour</span>
        </button>
      </div>
    </div>
  </div>

  <!-- Palette: Save (Bottom Center) -->
  <div class="tool-palette" id="palette-save">
    <div class="palette-header">
      <span class="palette-title"><span class="palette-title-icon">ðŸ’¾</span> Save</span>
      <div class="palette-controls">
        <button class="palette-btn minimize" title="Minimize" aria-label="Minimize panel">âˆ’</button>
      </div>
    </div>
    <div class="palette-body">
      <div class="export-buttons">
        <button class="export-btn primary" id="btnCopyLink" title="Copy shareable link to clipboard"
          aria-label="Copy shareable link to clipboard">
          <span class="btn-icon" aria-hidden="true">ðŸ”—</span>
          <span>Link</span>
        </button>
        <button class="export-btn" id="btnExportPNG" title="Download as PNG image"
          aria-label="Download diagram as PNG image">
          <span class="btn-icon" aria-hidden="true">ðŸ–¼ï¸</span>
          <span>PNG</span>
        </button>
        <button class="export-btn" id="btnExportSVG" title="Download as SVG vector"
          aria-label="Download diagram as SVG vector">
          <span class="btn-icon" aria-hidden="true">ðŸ“</span>
          <span>SVG</span>
        </button>
      </div>
      <!-- Saved Diagrams -->
      <div class="saved-diagrams">
        <div class="section-label">Saved Diagrams</div>
        <div class="save-input-row">
          <input type="text" id="saveDiagramName" placeholder="Name..." maxlength="50">
          <button id="btnSaveDiagram" title="Save current diagram">Save</button>
        </div>
        <div class="saved-list" id="savedDiagramsList">
          <div class="no-saved">No saved diagrams</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Palette: Position Aids (Center-Right) - minimized by default -->
  <div class="tool-palette minimized" id="palette-aids" role="region" aria-label="Position aid toggles">
    <div class="palette-header">
      <span class="palette-title"><span class="palette-title-icon" aria-hidden="true">ðŸ“</span> Aids</span>
      <div class="palette-controls">
        <button class="palette-btn minimize" title="Expand" aria-label="Expand panel">+</button>
      </div>
    </div>
    <div class="palette-body">
      <!-- Position Aids toggles -->
      <div class="position-aids" style="margin-top:0;padding-top:0;border-top:none;">
        <label class="toggle-row">
          <input type="checkbox" id="toggleTangentLine">
          <span>Tangent Line (stop)</span>
        </label>
        <label class="toggle-row">
          <input type="checkbox" id="toggleFollowLine">
          <span>Follow Line (top)</span>
        </label>
        <label class="toggle-row">
          <input type="checkbox" id="toggleDrawLine">
          <span>Draw Line (back)</span>
        </label>
        <label class="toggle-row">
          <input type="checkbox" id="toggleShapeZone">
          <span>Shape Zone</span>
        </label>
      </div>
      <!-- Legend Section -->
      <div class="legend-section" style="margin-top:16px;padding-top:16px;border-top:1px solid rgba(255,255,255,0.1);">
        <div class="legend-content">
          <div class="legend-item"><span class="legend-line aim-line"></span> Aim Line</div>
          <div class="legend-item"><span class="legend-line target-line"></span> Target Line</div>
          <div class="legend-item"><span class="legend-line obj-path"></span> Object Ball</div>
          <div class="legend-item"><span class="legend-line cb-path"></span> Cue Ball</div>
          <div class="legend-item"><span class="legend-line kick-path"></span> Kick Shot</div>
          <div class="legend-item"><span class="legend-line blocked-path"></span> Blocked</div>
          <div class="legend-item"><span class="legend-line combo-path"></span> Combo</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Tour System Elements -->
  <div class="tour-overlay" id="tourOverlay" style="display:none;"></div>
  <div class="tour-spotlight" id="tourSpotlight" style="display:none;"></div>
  <div class="tour-tooltip" id="tourTooltip">
    <div class="tour-tooltip-arrow" id="tourArrow"></div>
    <div class="tour-tooltip-header">
      <h3 class="tour-tooltip-title" id="tourTitle">Welcome</h3>
      <span class="tour-tooltip-step" id="tourStep">Step 1 of 12</span>
    </div>
    <div class="tour-tooltip-body">
      <div class="tour-tooltip-content" id="tourContent">
        Content goes here
      </div>
      <div class="tour-tooltip-task" id="tourTask" style="display:none;">
        Task description
      </div>
    </div>
    <div class="tour-tooltip-footer">
      <button class="tour-btn tour-btn-skip" id="tourSkip">Skip Tour</button>
      <div>
        <button class="tour-btn tour-btn-back" id="tourBack" style="display:none;">Back</button>
        <button class="tour-btn tour-btn-next" id="tourNext">Next</button>
      </div>
    </div>
  </div>

  <!-- Toast notification for copy feedback -->
  <div class="toast-notification" id="toastNotification" role="status" aria-live="polite" aria-atomic="true">Link copied to clipboard!</div>

  <!-- Status banner for persistent messages (blocked paths, etc.) -->
  <div class="status-banner" id="statusBanner" role="alert" aria-live="assertive">
    <span class="status-icon" aria-hidden="true">ðŸš«</span>
    <span class="status-message" id="statusMessage">All lanes blocked.</span>
    <span class="status-suggestion" id="statusSuggestion">Jump shot?</span>
  </div>

  <!-- Restore buttons (shown when palette is hidden) -->
  <button class="palette-restore-btn" id="restore-balls" title="Show Balls">ðŸŽ±</button>
  <button class="palette-restore-btn" id="restore-cue" title="Show Cue Control">ðŸŽ¯</button>
  <button class="palette-restore-btn" id="restore-legend" title="Show Legend">ðŸŽ¨</button>
  <button class="palette-restore-btn" id="restore-game" title="Show Game">ðŸŽ®</button>
  <button class="palette-restore-btn" id="restore-shot" title="Show Shot Info">ðŸ“Š</button>
  <button class="palette-restore-btn" id="restore-share" title="Show Share">ðŸ“¤</button>

  <script>
    (function () {
      const container = document.getElementById('diagramContainer');
      const tableWrapper = document.getElementById('tableWrapper');
      const ballRack = document.getElementById('ballRack');
      const cueGhostLine = document.getElementById('cue-ghost-line');
      const actualKickPath = document.getElementById('actual-kick-path');
      const targetLine = document.getElementById('target-line');
      const ghostBallIndicator = document.getElementById('ghost-ball-indicator');
      const kickAimIndicator = document.getElementById('kick-aim-indicator');
      const kickAimLabel = document.getElementById('kick-aim-label');
      // Mirror system visualization elements
      const mirrorSystemOverlay = document.getElementById('mirror-system-overlay');
      const mirrorGhost = document.getElementById('mirror-ghost');
      const mirrorAimLine = document.getElementById('mirror-aim-line');
      const midpointMarker = document.getElementById('midpoint-marker');
      const incomingAngleArc = document.getElementById('incoming-angle-arc');
      const incomingAngleText = document.getElementById('incoming-angle-text');
      const outgoingAngleArc = document.getElementById('outgoing-angle-arc');
      const outgoingAngleText = document.getElementById('outgoing-angle-text');
      const englishEffectIndicator = document.getElementById('english-effect-indicator');
      const englishEffectArc = document.getElementById('english-effect-arc');
      const englishEffectText = document.getElementById('english-effect-text');
      const cueStick = document.getElementById('cue-stick');
      const cueShaft = document.getElementById('cue-shaft');
      const cueFerule = document.getElementById('cue-ferrule');
      const cueTip = document.getElementById('cue-tip');
      const bankPointIndicator = document.getElementById('bank-point-indicator');
      const bankPointLabel = document.getElementById('bank-point-label');
      const solverRadios = document.querySelectorAll('input[name="solver-mode"]');
      const tableSvg = document.getElementById('pool-table-svg');
      const cutAngleDisplay = document.getElementById('cutAngleDisplay');
      const overlapDisplay = document.getElementById('overlapDisplay');
      const objBallPath = document.getElementById('obj-ball-path');
      const cueBallPath = document.getElementById('cue-ball-path');
      const contactPoint = document.getElementById('contact-point');
      const contactDiagram = document.getElementById('contact-diagram');
      const spinTypeDisplay = document.getElementById('spinType');
      const spinTypeInner = document.getElementById('spinTypeInner');  // New: spin display inside SVG
      const forceSlider = document.getElementById('forceSlider');

      // Helper to update both spin type displays
      function updateSpinDisplay(spinText) {
        if (spinTypeDisplay) spinTypeDisplay.textContent = spinText;
        if (spinTypeInner) spinTypeInner.textContent = spinText;
      }
      const forceValueDisplay = document.getElementById('forceValue');
      const overlapGhostBall = document.getElementById('overlap-ghost-ball');
      const overlapGhostLabel = document.getElementById('overlap-ghost-label');
      const overlapRegion = document.getElementById('overlap-region');
      const overlapPercentDisplay = document.getElementById('overlapPercent');
      const overlapEnglishDisplay = document.getElementById('overlapEnglish');
      const overlapSlashDisplay = document.getElementById('overlapSlash');
      const cbFinalPosition = document.getElementById('cb-final-position');
      const obFinalPosition = document.getElementById('ob-final-position');
      const statusBanner = document.getElementById('statusBanner');
      const statusMessage = document.getElementById('statusMessage');
      const statusSuggestion = document.getElementById('statusSuggestion');

      // Combination shot elements
      const comboShotIndicator = document.getElementById('combo-shot-indicator');
      const comboPath1 = document.getElementById('combo-path-1');
      const comboPath2 = document.getElementById('combo-path-2');
      const comboPath3 = document.getElementById('combo-path-3');
      const comboHelperGhost = document.getElementById('combo-helper-ghost');
      const comboLabel = document.getElementById('combo-label');

      // Shot Instructions Panel elements
      const shotVerdict = document.getElementById('shotVerdict');
      const aimInstruction = document.getElementById('aimInstruction');
      const englishInstruction = document.getElementById('englishInstruction');
      const englishHint = document.getElementById('englishHint');
      const powerNeeded = document.getElementById('powerNeeded');
      const powerStatus = document.getElementById('powerStatus');
      const difficultyFill = document.getElementById('difficultyFill');
      const difficultyText = document.getElementById('difficultyText');
      const foulWarningBanner = document.getElementById('foulWarningBanner');
      const foulMessage = document.getElementById('foulMessage');
      const simpleViewToggle = document.getElementById('simpleViewToggle');
      const gameModeSelect = document.getElementById('gameModeSelect');
      const gameModeDescription = document.getElementById('gameModeDescription');
      const suitSelector = document.getElementById('suitSelector');
      const pocketSelector = document.getElementById('pocketSelector');
      const suitRadios = document.querySelectorAll('input[name="player-suit"]');
      const pocketRadios = document.querySelectorAll('input[name="player-pocket"]');

      // Simple view state
      let isSimpleView = false;

      // ========== GAME MODE SYSTEM ==========
      // Defines rules for different pool/billiards games

      const GAME_MODES = {
        NINE_BALL: {
          id: '9ball',
          name: '9-Ball',
          balls: 9,
          ballIds: ['1', '2', '3', '4', '5', '6', '7', '8', '9'],
          targetRule: 'rotation',   // Must hit lowest ball first
          callPocket: false,        // Slop counts
          comboAllowed: true,
          comboMustHitLowestFirst: true,
          description: 'Hit lowest ball first. Pocket 9 to win.'
        },
        EIGHT_BALL: {
          id: '8ball',
          name: '8-Ball',
          balls: 15,
          ballIds: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15'],
          targetRule: 'suit',       // Must hit your suit first
          suitGroups: {
            solids: ['1', '2', '3', '4', '5', '6', '7'],
            stripes: ['9', '10', '11', '12', '13', '14', '15'],
            eight: ['8']
          },
          callPocket: true,
          comboAllowed: true,
          comboMustHitSuitFirst: true,
          description: 'Hit your suit (solids/stripes) first.'
        },
        TEN_BALL: {
          id: '10ball',
          name: '10-Ball',
          balls: 10,
          ballIds: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10'],
          targetRule: 'rotation',
          callPocket: true,
          comboAllowed: true,
          comboMustHitLowestFirst: true,
          description: 'Hit lowest ball first. Call pocket.'
        },
        STRAIGHT_POOL: {
          id: '14.1',
          name: 'Straight Pool',
          balls: 15,
          ballIds: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15'],
          targetRule: 'any',        // Any ball is legal
          callPocket: true,
          comboAllowed: true,
          comboAnyBall: true,
          description: 'Any ball, call pocket. First to target score wins.'
        },
        ONE_POCKET: {
          id: '1pocket',
          name: 'One Pocket',
          balls: 15,
          ballIds: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15'],
          targetRule: 'any',
          callPocket: false,
          pocketRestriction: true,  // Only your designated pocket scores
          scoringPockets: ['corner-bl', 'corner-br'],  // Foot rail corners only
          comboAllowed: true,
          comboAnyBall: true,
          description: 'Any ball into YOUR pocket only. First to 8 wins.'
        }
      };

      // Current game state
      let currentGameMode = GAME_MODES.EIGHT_BALL;  // Default to 8-ball
      let playerSuit = 'solids';                     // For 8-ball: 'solids' or 'stripes'
      let playerPocket = 'corner-bl';                // For One Pocket: player's scoring pocket

      // Find lowest numbered ball currently on table
      function findLowestBallOnTable() {
        const numbered = Object.keys(ballPositions)
          .filter(id => !isNaN(parseInt(id)) && ballPositions[id])
          .map(id => parseInt(id))
          .sort((a, b) => a - b);
        return numbered.length > 0 ? String(numbered[0]) : null;
      }

      // Get array of ball IDs that are legal to hit first based on game rules
      function getLegalTargetBalls() {
        const ballsOnTable = Object.keys(ballPositions).filter(id =>
          id !== 'cue' && id !== 'ghost' && ballPositions[id]
        );

        switch (currentGameMode.targetRule) {
          case 'rotation':
            // Only the lowest ball is legal
            const lowest = findLowestBallOnTable();
            return lowest ? [lowest] : [];

          case 'suit':
            // Return all balls of player's suit (8-ball)
            if (!currentGameMode.suitGroups[playerSuit]) return ballsOnTable;
            return ballsOnTable.filter(b =>
              currentGameMode.suitGroups[playerSuit].includes(b)
            );

          case 'any':
          default:
            // All balls are legal targets
            return ballsOnTable;
        }
      }

      // Check if a specific ball is a legal first-contact target
      function isBallLegalTarget(ballId) {
        const legalBalls = getLegalTargetBalls();
        return legalBalls.includes(ballId);
      }

      // Pocket mouth centers (narrowest entry point for aiming)
      const pocketCenters = {
        'corner-tl': { x: 1.5, y: 1.5 },
        'corner-tr': { x: 98.5, y: 1.5 },
        'corner-bl': { x: 1.5, y: 48.5 },
        'corner-br': { x: 98.5, y: 48.5 },
        'side-top': { x: 50, y: 0 },
        'side-bottom': { x: 50, y: 50 }
      };

      const BALL_RADIUS = 1.125; // inches (2.25" diameter / 2)
      const GHOST_BALL_OFFSET = BALL_RADIUS * 2 + 0.3; // Add small visual buffer for clarity

      // Current ball size in pixels (calculated dynamically)
      let ballSizePx = 24;  // Default, updated by updateBallSizes()

      // Calculate and update ball sizes based on current SVG scale
      function updateBallSizes() {
        const rect = tableSvg.getBoundingClientRect();
        const viewBox = tableSvg.viewBox.baseVal;

        // Calculate pixels per SVG unit
        const pxPerUnit = rect.width / viewBox.width;

        // Ball diameter in SVG units is 2 * BALL_RADIUS = 2.25
        const ballDiameterSvg = BALL_RADIUS * 2;

        // Ball size in pixels
        ballSizePx = Math.round(ballDiameterSvg * pxPerUnit);

        // Set CSS variables for ball size and related proportional elements
        document.documentElement.style.setProperty('--ball-size', ballSizePx + 'px');
        document.documentElement.style.setProperty('--ball-font-size', Math.max(8, Math.round(ballSizePx * 0.45)) + 'px');
        document.documentElement.style.setProperty('--selection-ring', Math.max(1, Math.round(ballSizePx * 0.05)) + 'px');
      }

      // Selection state
      let selectedBallId = null;  // Last dragged object ball
      let selectedPocket = null;  // Clicked pocket

      // Cue ball contact state (offset from center, in ball radii)
      // Default to max draw (backspin) for break shots
      // Contact offset in SVG coordinates - max is ~0.55 for new compact diagram
      let contactOffset = { x: 0, y: 0.55 };  // x: english (+ = right), y: spin (- = follow, + = draw)
      let shotForce = 10;  // 1-10 scale - default to max power for breaks
      let isDraggingContact = false;

      // Geometry helper functions
      function vectorSubtract(a, b) {
        return { x: a.x - b.x, y: a.y - b.y };
      }

      function vectorLength(v) {
        return Math.sqrt(v.x * v.x + v.y * v.y);
      }

      function vectorNormalize(v) {
        const len = vectorLength(v);
        if (len === 0) return { x: 0, y: 0 };
        return { x: v.x / len, y: v.y / len };
      }

      function dotProduct(a, b) {
        return a.x * b.x + a.y * b.y;
      }

      // Calculate angle between two vectors (in degrees)
      function angleBetweenVectors(v1, v2) {
        const n1 = vectorNormalize(v1);
        const n2 = vectorNormalize(v2);
        const dot = Math.max(-1, Math.min(1, dotProduct(n1, n2))); // Clamp to [-1, 1]
        return Math.acos(dot) * (180 / Math.PI);
      }

      // Check if a line segment passes too close to a circle (blocked by ball)
      // Returns true if the path is blocked
      function isPathBlockedByBall(start, end, ballCenter, ballRadius) {
        // Vector from start to end
        const d = vectorSubtract(end, start);
        // Vector from start to ball center
        const f = vectorSubtract(start, ballCenter);

        const a = dotProduct(d, d);
        const b = 2 * dotProduct(f, d);
        const c = dotProduct(f, f) - ballRadius * ballRadius;

        let discriminant = b * b - 4 * a * c;
        if (discriminant < 0) {
          return false; // No intersection
        }

        discriminant = Math.sqrt(discriminant);
        const t1 = (-b - discriminant) / (2 * a);
        const t2 = (-b + discriminant) / (2 * a);

        // Check if intersection is within the segment (0 to 1)
        // Use small margin to avoid edge cases
        if ((t1 >= 0.05 && t1 <= 0.95) || (t2 >= 0.05 && t2 <= 0.95)) {
          return true; // Path is blocked
        }
        return false;
      }

      // Check if a path is blocked by ANY ball on the table
      // excludeBallIds: array of ball IDs to ignore (e.g., ['cue', 'ghost', selectedBallId])
      // Returns: { blocked: boolean, blockingBalls: array of ball IDs that block }
      function isPathBlockedByAnyBall(start, end, excludeBallIds = []) {
        const blockingBalls = [];
        const blockRadius = BALL_RADIUS * 2.1;  // Slightly larger for safety margin

        for (const ballId in ballPositions) {
          // Skip excluded balls
          if (excludeBallIds.includes(ballId)) continue;
          // Skip the ghost ball (it's a target, not a physical ball)
          if (ballId === 'ghost') continue;

          const ballPos = ballPositions[ballId];
          if (ballPos && isPathBlockedByBall(start, end, ballPos, blockRadius)) {
            blockingBalls.push(ballId);
          }
        }

        return {
          blocked: blockingBalls.length > 0,
          blockingBalls: blockingBalls
        };
      }

      // Check if direct shot to ghost ball is blocked by any obstacle
      // Returns true if the path is clear, false if blocked
      function isDirectPathClear(cuePos, ghostPos, targetBallId) {
        const excludeIds = ['cue', 'ghost', targetBallId];
        const result = isPathBlockedByAnyBall(cuePos, ghostPos, excludeIds);
        return !result.blocked;
      }

      // Get list of all blocking balls for a path
      function getBlockingBalls(start, end, excludeBallIds = []) {
        return isPathBlockedByAnyBall(start, end, excludeBallIds).blockingBalls;
      }

      // Mirror a point across a rail for kick shot calculation
      function mirrorAcrossRail(point, railName) {
        const rail = RAILS[railName];
        if (railName === 'top' || railName === 'bottom') {
          // Horizontal rail - mirror y coordinate
          return { x: point.x, y: 2 * rail.y - point.y };
        } else {
          // Vertical rail - mirror x coordinate
          return { x: 2 * rail.x - point.x, y: point.y };
        }
      }

      // Find intersection of line with rail
      function lineRailIntersection(start, end, railName) {
        const rail = RAILS[railName];
        const d = vectorSubtract(end, start);

        if (railName === 'top' || railName === 'bottom') {
          // Horizontal rail
          if (Math.abs(d.y) < 0.001) return null;
          const t = (rail.y - start.y) / d.y;
          if (t < 0 || t > 1) return null;
          const x = start.x + d.x * t;
          if (x < RAILS.left.x || x > RAILS.right.x) return null;
          return { x, y: rail.y };
        } else {
          // Vertical rail
          if (Math.abs(d.x) < 0.001) return null;
          const t = (rail.x - start.x) / d.x;
          if (t < 0 || t > 1) return null;
          const y = start.y + d.y * t;
          if (y < RAILS.top.y || y > RAILS.bottom.y) return null;
          return { x: rail.x, y };
        }
      }

      // ========== MIRROR SYSTEM VISUALIZATION ==========
      // Based on the pool/billiards mirror aiming system:
      // 1. Mirror the ghost ball across the kick rail
      // 2. Aim from cue ball directly at the mirrored ghost
      // 3. The rail intersection point is your aim point
      // Reference: https://drdavepoolinfo.com/faq/bank-kick/mirror/

      function updateMirrorSystemVisualization(kickPath, cuePos, ghostPos, english) {
        if (!kickPath || !kickPath.rails || kickPath.rails.length === 0) {
          mirrorSystemOverlay.setAttribute('visibility', 'hidden');
          return;
        }

        const railName = kickPath.rails[0];  // First rail for one-rail kicks
        const aimPoint = kickPath.aimPoint;

        // 1. Calculate mirror ghost position (ghost mirrored across the kick rail)
        const mirrorGhostPos = mirrorAcrossRail(ghostPos, railName);

        // 2. Position the mirror ghost indicator
        mirrorGhost.setAttribute('transform', `translate(${mirrorGhostPos.x}, ${mirrorGhostPos.y})`);

        // 3. Draw aim line from cue through mirror ghost (extended beyond)
        const aimDir = vectorNormalize(vectorSubtract(mirrorGhostPos, cuePos));
        const lineExtend = 120;  // Extend the line to show full aim direction
        mirrorAimLine.setAttribute('x1', cuePos.x);
        mirrorAimLine.setAttribute('y1', cuePos.y);
        mirrorAimLine.setAttribute('x2', cuePos.x + aimDir.x * lineExtend);
        mirrorAimLine.setAttribute('y2', cuePos.y + aimDir.y * lineExtend);

        // 4. Calculate and position midpoint marker (for equal-distance method)
        const midpoint = {
          x: (cuePos.x + ghostPos.x) / 2,
          y: (cuePos.y + ghostPos.y) / 2
        };
        midpointMarker.setAttribute('transform', `translate(${midpoint.x}, ${midpoint.y})`);

        // 5. Calculate incoming and outgoing angles
        const incomingVec = vectorNormalize(vectorSubtract(aimPoint, cuePos));
        const outgoingVec = vectorNormalize(vectorSubtract(ghostPos, aimPoint));

        // Get rail normal (perpendicular to rail)
        let railNormal;
        if (railName === 'top') railNormal = { x: 0, y: 1 };
        else if (railName === 'bottom') railNormal = { x: 0, y: -1 };
        else if (railName === 'left') railNormal = { x: 1, y: 0 };
        else railNormal = { x: -1, y: 0 };  // right

        // Calculate angles relative to rail normal
        const incomingAngle = Math.acos(Math.abs(dotProduct(incomingVec, railNormal))) * (180 / Math.PI);
        const outgoingAngle = Math.acos(Math.abs(dotProduct(outgoingVec, railNormal))) * (180 / Math.PI);

        // 6. Draw angle arcs
        const arcRadius = 4;
        const incomingArcPath = createAngleArc(aimPoint, incomingVec, railNormal, arcRadius, railName, true);
        const outgoingArcPath = createAngleArc(aimPoint, outgoingVec, railNormal, arcRadius, railName, false);

        incomingAngleArc.setAttribute('d', incomingArcPath);
        outgoingAngleArc.setAttribute('d', outgoingArcPath);

        // Position angle text
        const inTextOffset = vectorScale(vectorNormalize(vectorAdd(incomingVec, railNormal)), arcRadius + 1.5);
        incomingAngleText.setAttribute('x', aimPoint.x - inTextOffset.x);
        incomingAngleText.setAttribute('y', aimPoint.y - inTextOffset.y);
        incomingAngleText.textContent = `${incomingAngle.toFixed(0)}Â°`;

        const outTextOffset = vectorScale(vectorNormalize(vectorAdd(outgoingVec, railNormal)), arcRadius + 1.5);
        outgoingAngleText.setAttribute('x', aimPoint.x + outTextOffset.x);
        outgoingAngleText.setAttribute('y', aimPoint.y + outTextOffset.y);
        outgoingAngleText.textContent = `${outgoingAngle.toFixed(0)}Â°`;

        // 7. Show english effect on angle
        if (Math.abs(english) > 0.05) {
          // English affects the rebound angle
          // Running english (same direction as ball travel along rail) = wider angle
          // Reverse english (opposite direction) = narrower angle
          // Roughly 1 diamond (~12.5 units) per tip of english

          // Determine if this is running or reverse english based on rail and spin direction
          const isRunning = isRunningEnglish(railName, english, incomingVec);
          const effectDegrees = Math.abs(english) * 8;  // ~8 degrees per full tip

          englishEffectText.setAttribute('x', aimPoint.x);
          englishEffectText.setAttribute('y', aimPoint.y + (railName === 'top' ? 3 : -3));
          englishEffectText.textContent = isRunning ?
            `+${effectDegrees.toFixed(0)}Â° (running)` :
            `-${effectDegrees.toFixed(0)}Â° (reverse)`;

          englishEffectIndicator.setAttribute('visibility', 'visible');
        } else {
          englishEffectIndicator.setAttribute('visibility', 'hidden');
        }

        mirrorSystemOverlay.setAttribute('visibility', 'visible');
      }

      // Helper: Create an angle arc SVG path
      function createAngleArc(center, vec1, vec2, radius, railName, isIncoming) {
        // Calculate start and end angles for the arc
        const startAngle = Math.atan2(-vec1.y, -vec1.x);  // Flip to show angle FROM the direction
        const endAngle = Math.atan2(vec2.y, vec2.x);

        // Adjust for rail orientation
        let angle1, angle2;
        if (isIncoming) {
          angle1 = Math.atan2(-vec1.y, -vec1.x);
          angle2 = Math.atan2(-vec2.y, -vec2.x);
        } else {
          angle1 = Math.atan2(vec2.y, vec2.x);
          angle2 = Math.atan2(vec1.y, vec1.x);
        }

        const x1 = center.x + Math.cos(angle1) * radius;
        const y1 = center.y + Math.sin(angle1) * radius;
        const x2 = center.x + Math.cos(angle2) * radius;
        const y2 = center.y + Math.sin(angle2) * radius;

        // Determine arc sweep direction
        const largeArc = 0;
        const sweep = 1;

        return `M ${x1} ${y1} A ${radius} ${radius} 0 ${largeArc} ${sweep} ${x2} ${y2}`;
      }

      // Helper: Determine if english is "running" (widening) or "reverse" (narrowing)
      function isRunningEnglish(railName, english, incomingVec) {
        // Running english is when the spin direction matches the ball's travel along the rail
        // For a ball hitting the top rail traveling right, left english is running
        // For a ball hitting the top rail traveling left, right english is running

        if (railName === 'top' || railName === 'bottom') {
          // Horizontal rail - check x direction of travel
          const travelingRight = incomingVec.x > 0;
          if (railName === 'top') {
            // Top rail: traveling right + left english = running, traveling left + right english = running
            return (travelingRight && english < 0) || (!travelingRight && english > 0);
          } else {
            // Bottom rail: opposite
            return (travelingRight && english > 0) || (!travelingRight && english < 0);
          }
        } else {
          // Vertical rail - check y direction of travel
          const travelingDown = incomingVec.y > 0;
          if (railName === 'left') {
            return (travelingDown && english > 0) || (!travelingDown && english < 0);
          } else {
            return (travelingDown && english < 0) || (!travelingDown && english > 0);
          }
        }
      }

      // Hide mirror system overlay
      function hideMirrorSystemVisualization() {
        mirrorSystemOverlay.setAttribute('visibility', 'hidden');
      }

      // Check if a path from start to ghostPos would hit the object ball PREMATURELY
      // (i.e., before reaching the ghost position where CB should contact OB)
      // Returns true if the path would hit OB at the wrong position
      function wouldHitObjectBallPrematurely(start, ghostPos, objBallPos) {
        if (!objBallPos) return false;

        // Calculate path direction and length
        const pathVec = vectorSubtract(ghostPos, start);
        const pathLen = vectorLength(pathVec);
        if (pathLen < 0.1) return false;

        const pathDir = vectorNormalize(pathVec);

        // Find the closest point on the path segment to the object ball
        const toObj = vectorSubtract(objBallPos, start);
        const projDist = dotProduct(toObj, pathDir);

        // Clamp to segment [0, pathLen]
        const clampedProj = Math.max(0, Math.min(projDist, pathLen));
        const closestPoint = vectorAdd(start, vectorScale(pathDir, clampedProj));
        const distToObj = vectorLength(vectorSubtract(objBallPos, closestPoint));

        // The ghost is positioned BALL_RADIUS * 2 (one diameter) from OB
        // CB at ghost would just touch OB
        // If the path gets within 2 ball radii of OB center, check WHERE

        const collisionRadius = BALL_RADIUS * 2;  // Two balls just touching

        if (distToObj < collisionRadius) {
          // Path gets close enough to potentially hit OB
          // Check if this happens BEFORE the "approach zone"
          // The approach zone is the last portion of the path where we EXPECT to be near OB

          // Distance from closest point to ghost
          const distFromClosestToGhost = pathLen - clampedProj;

          // If closest approach is more than 2.5 ball radii from ghost,
          // we'd hit OB prematurely (not in the approach zone)
          const approachZone = BALL_RADIUS * 3;  // Generous approach zone

          if (distFromClosestToGhost > approachZone) {
            // Would hit OB before reaching the proper approach angle
            return true;
          }

          // Additional check: the approach angle should be roughly correct
          // CB should approach from the opposite side of OB from where OB needs to go
          // If CB would hit OB from the wrong side, reject
          const approachDir = vectorNormalize(vectorSubtract(ghostPos, start));
          const ghostToObj = vectorNormalize(vectorSubtract(objBallPos, ghostPos));

          // approachDir should be roughly aligned with ghostToObj (CB approaches ghost,
          // then contacts OB which is in the ghostToObj direction)
          const alignment = dotProduct(approachDir, ghostToObj);

          // If approaching from wrong side (negative alignment), it's premature
          if (alignment < -0.3) {
            return true;
          }
        }

        return false;
      }

      // Maximum angle change from english (in degrees)
      // Full english (~0.7 ball radius offset) can change angle by ~15 degrees
      const MAX_ENGLISH_ANGLE = 15;

      // ========== PHYSICS CONSTANTS FOR REALISTIC KICK SHOTS ==========

      // Table dimensions (our SVG uses 100x50 units, representing ~9ft x 4.5ft table)
      // 1 SVG unit â‰ˆ 1.08 inches on a 9ft table
      const SVG_UNITS_PER_FOOT = 100 / 9;  // ~11.1 units per foot

      // Rolling friction coefficient on cloth
      // Ball loses this fraction of speed per unit distance traveled
      // Typical pool cloth: ball rolling at 10 ft/s stops in ~15-20 feet
      // Deceleration â‰ˆ 0.2 ft/sÂ² â†’ friction_per_unit = decel / (units_per_foot)
      const ROLLING_FRICTION_DECAY = 0.008;  // Speed multiplier lost per SVG unit (0.8% per unit)

      // Coefficient of restitution for rail bounces
      // Good rails: 0.85-0.95, worn rails: 0.75-0.85
      const RAIL_COR = 0.88;  // Each bounce retains 88% of speed

      // Minimum speed (as fraction of initial) needed to pocket a ball
      // Below this, ball won't have enough momentum to reach pocket reliably
      const MIN_POCKETING_SPEED = 0.15;  // 15% of initial speed minimum

      // Shot force to initial speed mapping (our force is 1-10)
      // Force 1 = soft, barely reaches other end (~50 units travel)
      // Force 5 = medium (~100 units travel with margin)
      // Force 10 = hard break shot (~200+ units travel)
      const FORCE_TO_INITIAL_SPEED = (force) => 0.5 + force * 0.25;  // Range: 0.75 to 3.0

      // Energy transfer based on cut angle
      // Physics: transferred = cosÂ²(cutAngle)
      // Full ball (0Â°): 100%, Half (30Â°): 75%, Quarter (45Â°): 50%, Thin (60Â°): 25%
      function getEnergyTransferFraction(cutAngleDegrees) {
        const cutRad = cutAngleDegrees * Math.PI / 180;
        return Math.cos(cutRad) * Math.cos(cutRad);  // cosÂ²(Î¸)
      }

      // Calculate speed remaining after traveling a distance with friction
      function speedAfterDistance(initialSpeed, distance) {
        // Exponential decay model: speed = initial * e^(-friction * distance)
        // Or simpler linear model: speed = initial * (1 - friction * distance)
        // Using linear with floor at 0
        const remaining = initialSpeed * Math.pow(1 - ROLLING_FRICTION_DECAY, distance);
        return Math.max(0, remaining);
      }

      // Calculate speed after a rail bounce
      function speedAfterRail(speed) {
        return speed * RAIL_COR;
      }

      // Calculate cue ball speed when it reaches the ghost ball position
      // Given a kick path with bouncePoints and total rail bounces
      function calculateCBSpeedAtImpact(kickPath, shotForce) {
        const initialSpeed = FORCE_TO_INITIAL_SPEED(shotForce);
        let speed = initialSpeed;

        // Travel through each segment, applying friction and rail losses
        let lastPoint = null;
        for (let i = 0; i < kickPath.bouncePoints.length; i++) {
          const point = kickPath.bouncePoints[i];
          if (i === 0 && kickPath.cuePos) {
            // First segment: cue to first bounce
            const dist = vectorLength(vectorSubtract(point, kickPath.cuePos));
            speed = speedAfterDistance(speed, dist);
          } else if (lastPoint) {
            // Subsequent segments
            const dist = vectorLength(vectorSubtract(point, lastPoint));
            speed = speedAfterDistance(speed, dist);
          }
          // Apply rail COR after each bounce
          speed = speedAfterRail(speed);
          lastPoint = point;
        }

        // Final segment: last bounce to ghost ball
        if (lastPoint && kickPath.ghostPos) {
          const dist = vectorLength(vectorSubtract(kickPath.ghostPos, lastPoint));
          speed = speedAfterDistance(speed, dist);
        }

        return speed;
      }

      // Calculate if object ball can reach the pocket with remaining energy
      function canOBReachPocket(cbSpeedAtImpact, cutAngleDegrees, obToPacketDist) {
        // Energy transferred to OB
        const energyFraction = getEnergyTransferFraction(cutAngleDegrees);
        const obInitialSpeed = cbSpeedAtImpact * Math.sqrt(energyFraction);  // sqrt because KE âˆ vÂ²

        // OB speed after traveling to pocket
        const obFinalSpeed = speedAfterDistance(obInitialSpeed, obToPacketDist);

        return {
          obInitialSpeed,
          obFinalSpeed,
          canReach: obFinalSpeed > MIN_POCKETING_SPEED * 0.5,  // Some margin
          margin: obFinalSpeed / MIN_POCKETING_SPEED  // >1 means comfortable, <1 means risky
        };
      }

      // Score a kick path based on viability (higher = better)
      // Returns 0 if path is not viable, 1-100 for viable paths
      function scoreKickPath(kickPath, shotForce, cutAngleDegrees, obToPocketDist) {
        // Add position info for calculation
        const enrichedPath = {
          ...kickPath,
          cuePos: kickPath.cuePos,
          ghostPos: kickPath.ghostPos
        };

        const cbSpeed = calculateCBSpeedAtImpact(enrichedPath, shotForce);
        const pocketCheck = canOBReachPocket(cbSpeed, cutAngleDegrees, obToPocketDist);

        if (!pocketCheck.canReach) {
          return { score: 0, viable: false, reason: 'Not enough power to pocket', ...pocketCheck, cbSpeed, cutAngleDegrees };
        }

        // CRITICAL: Steep cut angles make kick shots extremely difficult
        // A kick shot compounds difficulty - you need precision on BOTH the kick AND the cut
        // Near-90Â° cuts are practically impossible even on direct shots
        if (cutAngleDegrees > 75) {
          return {
            score: 0,
            viable: false,
            reason: `Cut angle too steep (${cutAngleDegrees.toFixed(0)}Â°) for kick shot`,
            ...pocketCheck,
            cbSpeed,
            cutAngleDegrees
          };
        }

        // Score based on margin (how comfortably the ball reaches the pocket)
        let score = Math.min(100, pocketCheck.margin * 50);

        // Bonus for fewer rails (simpler shot)
        score += (3 - kickPath.rails.length) * 10;

        // Penalty for scratches
        if (kickPath.scratches) {
          score -= 30;
        }

        // Penalty for extreme english
        const englishPenalty = Math.abs(kickPath.requiredEnglish || 0) * 10;
        score -= englishPenalty;

        // HEAVY penalty for steep cut angles (even below 75Â°)
        // Cut angle difficulty scales exponentially - a 60Â° cut is MUCH harder than 30Â°
        // On a kick shot, this compounds with the kick difficulty
        if (cutAngleDegrees > 60) {
          // 60-75Â°: -20 to -50 points (very hard cuts)
          score -= (cutAngleDegrees - 60) * 2;
        } else if (cutAngleDegrees > 45) {
          // 45-60Â°: -5 to -20 points (hard cuts)
          score -= (cutAngleDegrees - 45) * 1;
        } else if (cutAngleDegrees > 30) {
          // 30-45Â°: minor penalty (moderate cuts)
          score -= (cutAngleDegrees - 30) * 0.3;
        }
        // 0-30Â°: no penalty (easy to moderate cuts)

        // Determine difficulty label considering cut angle
        let difficulty;
        if (cutAngleDegrees > 60 || score < 30) {
          difficulty = 'Hard';
        } else if (cutAngleDegrees > 45 || score < 60) {
          difficulty = 'Medium';
        } else {
          difficulty = 'Easy';
        }

        return {
          score: Math.max(0, score),
          viable: score > 10,  // Need minimum score to be considered viable
          ...pocketCheck,
          cbSpeed,
          cutAngleDegrees,
          difficulty
        };
      }

      // Pocket zones for scratch detection (center and radius/size)
      const POCKET_ZONES = {
        'corner-tl': { x: 1.5, y: 1.5, r: 3.5 },
        'corner-tr': { x: 98.5, y: 1.5, r: 3.5 },
        'corner-bl': { x: 1.5, y: 48.5, r: 3.5 },
        'corner-br': { x: 98.5, y: 48.5, r: 3.5 },
        'side-top': { x: 50, y: 1, r: 2.5 },
        'side-bottom': { x: 50, y: 49, r: 2.5 }
      };

      // Check if a point is inside a pocket zone
      function isInPocketZone(point) {
        for (const [name, pocket] of Object.entries(POCKET_ZONES)) {
          const dx = point.x - pocket.x;
          const dy = point.y - pocket.y;
          if (dx * dx + dy * dy < pocket.r * pocket.r) {
            return name;
          }
        }
        return null;
      }

      // Check if a line segment passes through any pocket
      function pathCrossesPocket(start, end) {
        // Check multiple points along the path
        const steps = 20;
        for (let i = 1; i < steps; i++) {
          const t = i / steps;
          const point = {
            x: start.x + (end.x - start.x) * t,
            y: start.y + (end.y - start.y) * t
          };
          const pocket = isInPocketZone(point);
          if (pocket) return pocket;
        }
        return null;
      }

      // Calculate the natural reflection angle off a rail (no english)
      // Returns angle in degrees from rail direction (0 = parallel to rail)
      function calculateReflectionAngle(incomingDir, railName) {
        const rail = RAILS[railName];
        // Angle of incoming direction relative to rail normal
        const dotNormal = dotProduct(incomingDir, rail.normal);
        return Math.acos(Math.abs(dotNormal)) * (180 / Math.PI);
      }

      // Calculate required english to achieve a specific exit angle
      // Returns english value from -1 (full left) to +1 (full right)
      // Returns null if the angle adjustment is impossible
      function calculateRequiredEnglish(cuePos, aimPoint, targetPos, railName) {
        // Calculate incoming direction
        const incomingDir = vectorNormalize(vectorSubtract(aimPoint, cuePos));

        // Calculate needed outgoing direction
        const neededDir = vectorNormalize(vectorSubtract(targetPos, aimPoint));

        // Get rail normal
        const rail = RAILS[railName];

        // Calculate incoming angle (from rail normal)
        const inAngle = Math.acos(Math.abs(dotProduct(incomingDir, rail.normal))) * (180 / Math.PI);

        // Calculate required outgoing angle (from rail normal)
        const outAngle = Math.acos(Math.abs(dotProduct(neededDir, rail.normal))) * (180 / Math.PI);

        // Natural reflection would give outAngle = inAngle
        // Angle difference needed
        const angleDiff = outAngle - inAngle;

        // Check if achievable with english
        if (Math.abs(angleDiff) > MAX_ENGLISH_ANGLE) {
          return null; // Can't achieve this angle with english alone
        }

        // Convert angle difference to english amount
        // Positive angleDiff = need wider angle = running english
        // Determine which direction is "running" based on rail and direction
        let english = angleDiff / MAX_ENGLISH_ANGLE;

        // Determine running vs check english direction based on geometry
        // Running english is in the direction the ball is moving along the rail
        if (railName === 'top' || railName === 'bottom') {
          // Horizontal rail - english affects left/right
          const movingRight = neededDir.x > 0;
          const isTopRail = railName === 'top';
          // Running english: same direction as ball movement along rail
          if (isTopRail) {
            english = movingRight ? angleDiff / MAX_ENGLISH_ANGLE : -angleDiff / MAX_ENGLISH_ANGLE;
          } else {
            english = movingRight ? -angleDiff / MAX_ENGLISH_ANGLE : angleDiff / MAX_ENGLISH_ANGLE;
          }
        } else {
          // Vertical rail
          const movingDown = neededDir.y > 0;
          const isLeftRail = railName === 'left';
          if (isLeftRail) {
            english = movingDown ? -angleDiff / MAX_ENGLISH_ANGLE : angleDiff / MAX_ENGLISH_ANGLE;
          } else {
            english = movingDown ? angleDiff / MAX_ENGLISH_ANGLE : -angleDiff / MAX_ENGLISH_ANGLE;
          }
        }

        // Clamp to valid range
        return Math.max(-1, Math.min(1, english));
      }

      // Calculate where the ball will actually go given incoming direction, rail, and english
      function calculateExitDirection(incomingDir, railName, english) {
        const rail = RAILS[railName];

        // Reflect incoming direction across rail normal
        const dotNormal = dotProduct(incomingDir, rail.normal);
        const reflected = {
          x: incomingDir.x - 2 * dotNormal * rail.normal.x,
          y: incomingDir.y - 2 * dotNormal * rail.normal.y
        };

        // Apply english effect (rotate the exit direction)
        const angleAdjust = english * MAX_ENGLISH_ANGLE * (Math.PI / 180);
        const cos = Math.cos(angleAdjust);
        const sin = Math.sin(angleAdjust);

        return vectorNormalize({
          x: reflected.x * cos - reflected.y * sin,
          y: reflected.x * sin + reflected.y * cos
        });
      }

      // Calculate actual kick path endpoint given user's english
      // Returns where the CB will actually end up after bouncing off the rail
      function calculateActualKickDestination(cuePos, aimPoint, railName, userEnglish) {
        // Direction from cue to aim point
        const incomingDir = vectorNormalize(vectorSubtract(aimPoint, cuePos));

        // Calculate exit direction with user's english
        const exitDir = calculateExitDirection(incomingDir, railName, userEnglish);

        // Project the exit direction to find where it would go
        // (extend to a reasonable distance)
        const projectionDist = 100;  // Project far enough to cross the table
        return vectorAdd(aimPoint, vectorScale(exitDir, projectionDist));
      }

      // Calculate how far off-target the user's english will be for a kick shot
      // Returns { actualEndpoint, error, errorAngle }
      function calculateKickEnglishError(cuePos, aimPoint, ghostPos, railName, userEnglish, requiredEnglish) {
        // Get direction from cue to aim point
        const incomingDir = vectorNormalize(vectorSubtract(aimPoint, cuePos));

        // Calculate where CB would go with user's english
        const actualExitDir = calculateExitDirection(incomingDir, railName, userEnglish);

        // Calculate where CB should go (with required english)
        const idealExitDir = calculateExitDirection(incomingDir, railName, requiredEnglish);

        // Actual destination (project to same distance as ghost ball)
        const distToGhost = vectorLength(vectorSubtract(ghostPos, aimPoint));
        const actualEndpoint = vectorAdd(aimPoint, vectorScale(actualExitDir, distToGhost));

        // Error distance (how far from ghost ball)
        const error = vectorLength(vectorSubtract(actualEndpoint, ghostPos));

        // Error angle (difference between actual and required exit directions)
        const errorAngle = Math.acos(Math.min(1, Math.abs(dotProduct(actualExitDir, idealExitDir)))) * (180 / Math.PI);

        return {
          actualEndpoint,
          error,
          errorAngle,
          actualExitDir,
          idealExitDir
        };
      }

      // "Throw" calculation for bank shots
      // When CB hits OB with side spin, some spin transfers and affects OB's path off the rail
      // Throw amount depends on: cut angle, CB speed, side spin amount
      const THROW_FACTOR = 0.3;  // Maximum throw angle in degrees per unit of english at full cut

      function calculateBankThrow(cutAngleDeg, english) {
        // Throw is maximized at ~30-45 degree cuts, minimal at full ball or thin cuts
        // sin(2*cutAngle) peaks at 45 degrees
        const cutRad = cutAngleDeg * Math.PI / 180;
        const cutFactor = Math.sin(2 * cutRad);  // 0 at 0Â°, 1 at 45Â°, 0 at 90Â°

        // Throw angle in degrees
        return english * THROW_FACTOR * cutFactor * 15;  // Up to ~4.5 degrees at max
      }

      // Find a kick shot path that avoids ALL obstacles on the table
      // Returns { bouncePoints, rails, aimPoint, requiredEnglish, scratches, viability } or null
      function findKickPath(cuePos, ghostPos, objBallPos, currentEnglish, shotForce, pocketPos, targetBallId = null) {
        const blockRadius = BALL_RADIUS * 2.5; // Clearance needed
        const excludeIds = ['cue', 'ghost', targetBallId].filter(Boolean);

        // Check if direct path is blocked by ANY ball (not just the object ball)
        const directPathCheck = isPathBlockedByAnyBall(cuePos, ghostPos, excludeIds);
        if (!directPathCheck.blocked) {
          return null; // Direct shot is fine, no kick needed
        }

        // Direction from ghost to OB (used for cut angle calculation)
        // This is constant regardless of which rail we kick from
        const ghostToObj = vectorNormalize(vectorSubtract(objBallPos, ghostPos));

        // Distance from object ball to pocket
        const obToPocketDist = pocketPos ? vectorLength(vectorSubtract(pocketPos, objBallPos)) : 50;

        // Try one-rail kicks
        const railNames = ['top', 'bottom', 'left', 'right'];
        const validKicks = [];

        for (const railName of railNames) {
          // Mirror ghost ball across the rail
          const mirroredGhost = mirrorAcrossRail(ghostPos, railName);

          // Find where line from cue to mirrored ghost crosses the rail
          // This is our aim point!
          const aimPoint = lineRailIntersection(cuePos, mirroredGhost, railName);

          if (aimPoint) {
            // Check if both segments of the kick path avoid ALL balls on table
            const segment1Check = isPathBlockedByAnyBall(cuePos, aimPoint, excludeIds);
            const segment2Check = isPathBlockedByAnyBall(aimPoint, ghostPos, excludeIds);

            if (!segment1Check.blocked && !segment2Check.blocked) {
              // CRITICAL: Check if path from bounce to ghost would hit target ball prematurely
              // This catches kicks that dodge blockers but approach OB from the wrong side
              if (wouldHitObjectBallPrematurely(aimPoint, ghostPos, objBallPos)) {
                continue; // Skip this kick - would hit OB at wrong position
              }

              // IMPORTANT: Calculate cut angle based on APPROACH from bounce point, not from cue!
              // Different rails give different approach angles, affecting shot difficulty
              const approachDir = vectorNormalize(vectorSubtract(ghostPos, aimPoint));
              const cutAngleDegrees = Math.acos(Math.abs(dotProduct(approachDir, ghostToObj))) * (180 / Math.PI);

              // Calculate required english for this kick
              const requiredEnglish = calculateRequiredEnglish(cuePos, aimPoint, ghostPos, railName);

              // Check for pocket scratches on both segments
              const scratch1 = pathCrossesPocket(cuePos, aimPoint);
              const scratch2 = pathCrossesPocket(aimPoint, ghostPos);
              const scratches = scratch1 || scratch2;

              // Valid kick path found
              const dist1 = vectorLength(vectorSubtract(aimPoint, cuePos));
              const dist2 = vectorLength(vectorSubtract(ghostPos, aimPoint));

              // Calculate english error (difference between user's english and required)
              const reqEng = requiredEnglish !== null ? requiredEnglish : 0;
              const englishError = calculateKickEnglishError(cuePos, aimPoint, ghostPos, railName, currentEnglish, reqEng);

              // Calculate actual bounce point with user's current english
              const actualExitDir = calculateExitDirection(
                vectorNormalize(vectorSubtract(aimPoint, cuePos)),
                railName,
                currentEnglish
              );
              const actualDestination = vectorAdd(aimPoint, vectorScale(actualExitDir, dist2));

              const kickPath = {
                rails: [railName],
                bouncePoints: [aimPoint],
                aimPoint: aimPoint,
                cuePos: cuePos,
                ghostPos: ghostPos,
                requiredEnglish: reqEng,
                currentEnglish: currentEnglish,
                englishPossible: requiredEnglish !== null,
                englishError: englishError.error,
                englishErrorAngle: englishError.errorAngle,
                actualDestination: actualDestination,  // Where CB actually goes with user's english
                scratches: scratches,
                totalLength: dist1 + dist2,
                cutAngle: cutAngleDegrees  // Store cut angle for sorting/display
              };

              // Score this path for viability
              kickPath.viability = scoreKickPath(kickPath, shotForce || 5, cutAngleDegrees, obToPocketDist);
              validKicks.push(kickPath);
            }
          }
        }

        // If no one-rail kick works OR we want to compare with two-rail options, try two-rail kicks
        if (validKicks.length === 0 || validKicks.every(k => !k.viability.viable)) {
          for (const rail1 of railNames) {
            for (const rail2 of railNames) {
              if (rail1 === rail2) continue;
              // Skip opposite rails (usually not useful)
              if ((rail1 === 'top' && rail2 === 'bottom') ||
                (rail1 === 'bottom' && rail2 === 'top') ||
                (rail1 === 'left' && rail2 === 'right') ||
                (rail1 === 'right' && rail2 === 'left')) continue;

              // Double mirror: first across rail2, then across rail1
              const mirror1 = mirrorAcrossRail(ghostPos, rail2);
              const mirror2 = mirrorAcrossRail(mirror1, rail1);

              // Find first bounce point (this is our aim point for 2-rail kicks)
              const aimPoint = lineRailIntersection(cuePos, mirror2, rail1);
              if (!aimPoint) continue;

              // Find second bounce point
              const bounce2 = lineRailIntersection(aimPoint, ghostPos, rail2);
              if (!bounce2) continue;

              // Check all three segments for ALL ball collisions
              const seg1Check = isPathBlockedByAnyBall(cuePos, aimPoint, excludeIds);
              const seg2Check = isPathBlockedByAnyBall(aimPoint, bounce2, excludeIds);
              const seg3Check = isPathBlockedByAnyBall(bounce2, ghostPos, excludeIds);

              if (!seg1Check.blocked && !seg2Check.blocked && !seg3Check.blocked) {
                // CRITICAL: Check if final segment (bounce2 â†’ ghost) would hit target ball prematurely
                if (wouldHitObjectBallPrematurely(bounce2, ghostPos, objBallPos)) {
                  continue; // Skip this kick - would hit OB at wrong position
                }

                // IMPORTANT: Calculate cut angle based on APPROACH from final bounce point
                // For 2-rail kicks, CB approaches ghost from bounce2
                const approachDir = vectorNormalize(vectorSubtract(ghostPos, bounce2));
                const cutAngleDegrees = Math.acos(Math.abs(dotProduct(approachDir, ghostToObj))) * (180 / Math.PI);

                // Calculate required english for first rail
                const requiredEnglish = calculateRequiredEnglish(cuePos, aimPoint, bounce2, rail1);

                // Check for pocket scratches
                const scratch1 = pathCrossesPocket(cuePos, aimPoint);
                const scratch2 = pathCrossesPocket(aimPoint, bounce2);
                const scratch3 = pathCrossesPocket(bounce2, ghostPos);
                const scratches = scratch1 || scratch2 || scratch3;

                const d1 = vectorLength(vectorSubtract(aimPoint, cuePos));
                const d2 = vectorLength(vectorSubtract(bounce2, aimPoint));
                const d3 = vectorLength(vectorSubtract(ghostPos, bounce2));

                // Calculate english error for 2-rail kicks (just for first rail impact)
                const reqEng = requiredEnglish !== null ? requiredEnglish : 0;
                const englishError = calculateKickEnglishError(cuePos, aimPoint, bounce2, rail1, currentEnglish, reqEng);

                const kickPath = {
                  rails: [rail1, rail2],
                  bouncePoints: [aimPoint, bounce2],
                  aimPoint: aimPoint,
                  cuePos: cuePos,
                  ghostPos: ghostPos,
                  requiredEnglish: reqEng,
                  currentEnglish: currentEnglish,
                  englishPossible: requiredEnglish !== null,
                  englishError: englishError.error,
                  englishErrorAngle: englishError.errorAngle,
                  scratches: scratches,
                  totalLength: d1 + d2 + d3,
                  cutAngle: cutAngleDegrees  // Store cut angle for sorting/display
                };

                // Score this path for viability
                kickPath.viability = scoreKickPath(kickPath, shotForce || 5, cutAngleDegrees, obToPocketDist);
                validKicks.push(kickPath);
              }
            }
          }
        }

        // If no 2-rail kick works, try 3-rail kicks
        if (validKicks.length === 0 || validKicks.every(k => !k.viability.viable)) {
          for (const rail1 of railNames) {
            for (const rail2 of railNames) {
              if (rail1 === rail2) continue;
              for (const rail3 of railNames) {
                if (rail3 === rail2) continue;
                // Skip if rail3 equals rail1 (would be redundant)
                if (rail3 === rail1) continue;

                // Triple mirror: ghost across rail3, then rail2, then rail1
                const mirror1 = mirrorAcrossRail(ghostPos, rail3);
                const mirror2 = mirrorAcrossRail(mirror1, rail2);
                const mirror3 = mirrorAcrossRail(mirror2, rail1);

                // Find first bounce point
                const bounce1 = lineRailIntersection(cuePos, mirror3, rail1);
                if (!bounce1) continue;

                // Find second bounce point
                const bounce2 = lineRailIntersection(bounce1, mirror1, rail2);
                if (!bounce2) continue;

                // Find third bounce point
                const bounce3 = lineRailIntersection(bounce2, ghostPos, rail3);
                if (!bounce3) continue;

                // Check all four segments for ball collisions
                const seg1Check = isPathBlockedByAnyBall(cuePos, bounce1, excludeIds);
                const seg2Check = isPathBlockedByAnyBall(bounce1, bounce2, excludeIds);
                const seg3Check = isPathBlockedByAnyBall(bounce2, bounce3, excludeIds);
                const seg4Check = isPathBlockedByAnyBall(bounce3, ghostPos, excludeIds);

                if (!seg1Check.blocked && !seg2Check.blocked && !seg3Check.blocked && !seg4Check.blocked) {
                  // Check if final segment would hit OB prematurely
                  if (wouldHitObjectBallPrematurely(bounce3, ghostPos, objBallPos)) {
                    continue;
                  }

                  // Calculate cut angle from final approach
                  const approachDir = vectorNormalize(vectorSubtract(ghostPos, bounce3));
                  const cutAngleDegrees = Math.acos(Math.abs(dotProduct(approachDir, ghostToObj))) * (180 / Math.PI);

                  // Calculate distances
                  const d1 = vectorLength(vectorSubtract(bounce1, cuePos));
                  const d2 = vectorLength(vectorSubtract(bounce2, bounce1));
                  const d3 = vectorLength(vectorSubtract(bounce3, bounce2));
                  const d4 = vectorLength(vectorSubtract(ghostPos, bounce3));

                  // Check for scratches
                  const scratches = pathCrossesPocket(cuePos, bounce1) ||
                    pathCrossesPocket(bounce1, bounce2) ||
                    pathCrossesPocket(bounce2, bounce3) ||
                    pathCrossesPocket(bounce3, ghostPos);

                  const kickPath = {
                    rails: [rail1, rail2, rail3],
                    bouncePoints: [bounce1, bounce2, bounce3],
                    aimPoint: bounce1,
                    cuePos: cuePos,
                    ghostPos: ghostPos,
                    requiredEnglish: 0,  // Complex to calculate for 3-rail
                    currentEnglish: currentEnglish,
                    englishPossible: true,
                    englishError: 0,
                    englishErrorAngle: 0,
                    scratches: scratches,
                    totalLength: d1 + d2 + d3 + d4,
                    cutAngle: cutAngleDegrees
                  };

                  kickPath.viability = scoreKickPath(kickPath, shotForce || 5, cutAngleDegrees, obToPocketDist);
                  // Reduce score for 3-rail (harder shot)
                  kickPath.viability.score -= 15;
                  validKicks.push(kickPath);
                }
              }
            }
          }
        }

        // Sort kicks: prefer viable paths with high scores and lower cut angles
        if (validKicks.length > 0) {
          validKicks.sort((a, b) => {
            // First priority: viable paths over non-viable
            if (a.viability.viable && !b.viability.viable) return -1;
            if (!a.viability.viable && b.viability.viable) return 1;

            // Second priority: higher viability score (includes scratch penalty, english, cut angle)
            if (Math.abs(a.viability.score - b.viability.score) > 5) {
              return b.viability.score - a.viability.score;  // Higher score first
            }

            // Third priority: lower cut angle (easier shot)
            // Even if scores are similar, prefer the less-angled cut
            const cutA = a.cutAngle || 0;
            const cutB = b.cutAngle || 0;
            if (Math.abs(cutA - cutB) > 5) {
              return cutA - cutB;  // Lower cut angle first
            }

            // Fourth priority: avoid scratches
            if (!a.scratches && b.scratches) return -1;
            if (a.scratches && !b.scratches) return 1;

            // Fifth priority: fewer rails (simpler shot)
            if (a.rails.length !== b.rails.length) {
              return a.rails.length - b.rails.length;
            }

            // Fifth priority: shorter path
            return a.totalLength - b.totalLength;
          });

          // Return best viable path, or best non-viable if none are viable
          return validKicks[0];
        }

        return null; // No valid kick path found
      }

      // ========== BANK SHOT CALCULATIONS ==========
      // Bank shot: Object ball bounces off rail before going into pocket

      // Find bank shot paths for a given object ball and pocket
      // Returns array of { bankPoint, bankRail, ghostPos, cutAngle, viability, throwAngle, requiredEnglish }
      function findBankShots(cuePos, objBallPos, pocketPos, shotForce, currentEnglish = 0, targetBallId = null) {
        const railNames = ['top', 'bottom', 'left', 'right'];
        const validBanks = [];
        const excludeIds = ['cue', 'ghost', targetBallId].filter(Boolean);

        for (const railName of railNames) {
          // Mirror pocket across the rail
          const mirroredPocket = mirrorAcrossRail(pocketPos, railName);

          // Line from OB to mirrored pocket
          const bankPoint = lineRailIntersection(objBallPos, mirroredPocket, railName);

          if (bankPoint) {
            // Check if bank point is valid (not too close to pocket openings)
            const tooCloseToCorner = (
              (bankPoint.x < 6 || bankPoint.x > 94) && (bankPoint.y < 6 || bankPoint.y > 44)
            );
            if (tooCloseToCorner) continue;

            // Calculate ghost ball position for this bank shot
            // Ghost ball is positioned so OB travels from OB pos toward bank point
            const obToBankDir = vectorNormalize(vectorSubtract(bankPoint, objBallPos));
            const ghostPos = {
              x: objBallPos.x - obToBankDir.x * GHOST_BALL_OFFSET,
              y: objBallPos.y - obToBankDir.y * GHOST_BALL_OFFSET
            };

            // Check if ghost ball is on the table
            if (!isOnPlayingSurface(ghostPos.x, ghostPos.y)) continue;

            // Check if cue ball can reach ghost ball (not blocked by ANY ball)
            const cueToGhostCheck = isPathBlockedByAnyBall(cuePos, ghostPos, excludeIds);
            if (cueToGhostCheck.blocked) continue;

            // CRITICAL: Check if CB path to ghost would hit OB prematurely from wrong side
            if (wouldHitObjectBallPrematurely(cuePos, ghostPos, objBallPos)) {
              continue; // Skip this bank - CB would hit OB at wrong angle
            }

            // Check if OB can reach bank point (not blocked by other balls)
            const obToBankCheck = isPathBlockedByAnyBall(objBallPos, bankPoint, excludeIds);
            if (obToBankCheck.blocked) continue;

            // Check if path from bank point to pocket is clear
            const bankToPocketCheck = isPathBlockedByAnyBall(bankPoint, pocketPos, excludeIds);
            if (bankToPocketCheck.blocked) continue;

            // Calculate cut angle for this shot
            const cueToGhost = vectorNormalize(vectorSubtract(ghostPos, cuePos));
            const obToBankNorm = obToBankDir;
            const dotProd = Math.abs(dotProduct(cueToGhost, obToBankNorm));
            const cutAngleDeg = Math.acos(Math.min(1, dotProd)) * (180 / Math.PI);

            // Calculate distances
            const obToBankDist = vectorLength(vectorSubtract(bankPoint, objBallPos));
            const bankToPocketDist = vectorLength(vectorSubtract(pocketPos, bankPoint));
            const cueToGhostDist = vectorLength(vectorSubtract(ghostPos, cuePos));

            // Calculate throw from CB spin transfer to OB
            // Throw depends on cut angle and side english amount
            // Positive english (right) throws OB left, negative throws right
            const throwAngle = calculateBankThrow(cutAngleDeg, currentEnglish);

            // Determine if this is a cut to the left or right relative to the bank direction
            // Cross product to determine cut direction (positive = cutting left, negative = cutting right)
            const crossZ = cueToGhost.x * obToBankNorm.y - cueToGhost.y * obToBankNorm.x;
            const cutDirection = crossZ > 0 ? 1 : -1;  // 1 = cutting left, -1 = cutting right

            // Calculate how throw affects the bank
            // Throw is perpendicular to OB's travel direction
            const throwRad = throwAngle * Math.PI / 180;
            const throwOffset = Math.tan(throwRad) * obToBankDist;  // How far off the bank point will be

            // Actual bank point with throw considered
            // Get perpendicular to OB travel direction
            const perpToBank = { x: -obToBankDir.y, y: obToBankDir.x };
            const actualBankPoint = {
              x: bankPoint.x + perpToBank.x * throwOffset * cutDirection,
              y: bankPoint.y + perpToBank.y * throwOffset * cutDirection
            };

            // Calculate english needed to compensate for natural throw
            // To cancel throw, apply opposite english
            const compensatingEnglish = -currentEnglish;  // Info: apply opposite to cancel throw

            // Score this bank shot
            const viability = scoreBankShot(
              cueToGhostDist,
              cutAngleDeg,
              obToBankDist,
              bankToPocketDist,
              shotForce
            );

            validBanks.push({
              bankPoint,
              actualBankPoint,  // Where OB actually hits rail with current throw
              bankRail: railName,
              ghostPos,
              cutAngle: cutAngleDeg,
              cutDirection,
              throwAngle,
              currentEnglish,
              obToBankDist,
              bankToPocketDist,
              totalOBDist: obToBankDist + bankToPocketDist,
              viability
            });
          }
        }

        // Sort by viability score
        validBanks.sort((a, b) => b.viability.score - a.viability.score);
        return validBanks;
      }

      // Score a bank shot based on physics viability
      function scoreBankShot(cueToGhostDist, cutAngleDeg, obToBankDist, bankToPocketDist, shotForce) {
        const initialSpeed = FORCE_TO_INITIAL_SPEED(shotForce);

        // CB speed at impact (after traveling to ghost ball)
        const cbSpeedAtImpact = speedAfterDistance(initialSpeed, cueToGhostDist);

        // Energy transfer to OB based on cut angle
        const energyFraction = getEnergyTransferFraction(cutAngleDeg);
        const obInitialSpeed = cbSpeedAtImpact * Math.sqrt(energyFraction);

        // OB speed after reaching the bank point
        const obSpeedAtBank = speedAfterDistance(obInitialSpeed, obToBankDist);

        // Speed after rail bounce
        const obSpeedAfterRail = speedAfterRail(obSpeedAtBank);

        // OB speed when reaching pocket
        const obFinalSpeed = speedAfterDistance(obSpeedAfterRail, bankToPocketDist);

        const canReach = obFinalSpeed > MIN_POCKETING_SPEED * 0.5;
        const margin = obFinalSpeed / MIN_POCKETING_SPEED;

        if (!canReach) {
          return { score: 0, viable: false, reason: 'Not enough power', obFinalSpeed, margin, cutAngleDeg };
        }

        // CRITICAL: Very steep cut angles make bank shots nearly impossible
        // Bank shots compound difficulty - precision on cut AND bank angle
        if (cutAngleDeg > 70) {
          return {
            score: 0,
            viable: false,
            reason: `Cut angle too steep (${cutAngleDeg.toFixed(0)}Â°) for bank shot`,
            obFinalSpeed,
            margin,
            cutAngleDeg
          };
        }

        // Score based on margin and shot difficulty
        let score = Math.min(100, margin * 40);

        // ENHANCED penalty for steep cut angles
        // Bank shots are already difficult; steep cuts compound this
        if (cutAngleDeg > 55) {
          // 55-70Â°: -15 to -45 points (very hard)
          score -= (cutAngleDeg - 55) * 2;
        } else if (cutAngleDeg > 45) {
          // 45-55Â°: -5 to -15 points (hard)
          score -= (cutAngleDeg - 45) * 1;
        } else if (cutAngleDeg > 30) {
          // 30-45Â°: minor penalty
          score -= (cutAngleDeg - 30) * 0.3;
        }

        // Penalty for long bank distances (more error accumulation)
        const totalDist = obToBankDist + bankToPocketDist;
        if (totalDist > 60) score -= (totalDist - 60) * 0.3;

        // Determine difficulty considering cut angle
        let difficulty;
        if (cutAngleDeg > 55 || score < 25) {
          difficulty = 'Hard';
        } else if (cutAngleDeg > 40 || score < 50) {
          difficulty = 'Medium';
        } else {
          difficulty = 'Easy';
        }

        return {
          score: Math.max(0, score),
          viable: score > 10,
          obFinalSpeed,
          margin,
          cutAngleDeg,
          difficulty
        };
      }

      // ==================== COMBINATION SHOT DETECTION ====================

      // Find combination shots: hit helper ball (OB1) into target ball (OB2) to pocket OB2
      function findCombinationShots(cuePos, targetBallId, pocketId) {
        const combos = [];
        const targetPos = ballPositions[targetBallId];
        const pocketPos = pocketCenters[pocketId];

        if (!targetPos || !pocketPos) return combos;

        // Get all potential helper balls
        const helperBalls = Object.keys(ballPositions).filter(id =>
          id !== 'cue' && id !== 'ghost' && id !== targetBallId && ballPositions[id]
        );

        for (const helperBallId of helperBalls) {
          const helperPos = ballPositions[helperBallId];
          if (!helperPos) continue;

          // Calculate where helper needs to hit target to send it toward pocket
          // Ghost ball position for helper â†’ target collision
          const targetToPocket = vectorNormalize({
            x: pocketPos.x - targetPos.x,
            y: pocketPos.y - targetPos.y
          });

          // Target ghost position (where helper should contact target)
          const targetGhostPos = {
            x: targetPos.x - targetToPocket.x * BALL_RADIUS * 2,
            y: targetPos.y - targetToPocket.y * BALL_RADIUS * 2
          };

          // Calculate where cue needs to hit helper to send it toward target ghost
          const helperToTargetGhost = vectorNormalize({
            x: targetGhostPos.x - helperPos.x,
            y: targetGhostPos.y - helperPos.y
          });

          // Helper ghost position (where cue should contact helper)
          const helperGhostPos = {
            x: helperPos.x - helperToTargetGhost.x * BALL_RADIUS * 2,
            y: helperPos.y - helperToTargetGhost.y * BALL_RADIUS * 2
          };

          // Check alignment: does helper â†’ target direction align with target â†’ pocket?
          const helperToTarget = vectorNormalize({
            x: targetPos.x - helperPos.x,
            y: targetPos.y - helperPos.y
          });

          const alignment = helperToTarget.x * targetToPocket.x + helperToTarget.y * targetToPocket.y;

          // Need good alignment (helper pushes target toward pocket)
          if (alignment < 0.3) continue;

          // Calculate cut angles
          const cueToHelperGhost = vectorNormalize({
            x: helperGhostPos.x - cuePos.x,
            y: helperGhostPos.y - cuePos.y
          });

          // Cut angle 1: cue â†’ helper
          const cutAngle1Rad = Math.acos(Math.max(-1, Math.min(1,
            cueToHelperGhost.x * helperToTargetGhost.x + cueToHelperGhost.y * helperToTargetGhost.y
          )));
          const cutAngle1 = cutAngle1Rad * 180 / Math.PI;

          // Cut angle 2: helper â†’ target â†’ pocket
          const cutAngle2Rad = Math.acos(Math.max(-1, Math.min(1, alignment)));
          const cutAngle2 = cutAngle2Rad * 180 / Math.PI;

          // Skip if cut angles are too steep (very low probability shots)
          if (cutAngle1 > 70 || cutAngle2 > 70) continue;

          // Check paths are clear
          // Path 1: Cue â†’ Helper ghost
          const path1Check = isPathBlockedByAnyBall(cuePos, helperGhostPos, ['cue', helperBallId]);
          if (path1Check.blocked) continue;

          // CRITICAL: Check if CB path to helper ghost would hit helper prematurely
          if (wouldHitObjectBallPrematurely(cuePos, helperGhostPos, helperPos)) {
            continue; // Skip - CB would hit helper at wrong angle
          }

          // Path 2: Helper â†’ Target ghost
          const path2Check = isPathBlockedByAnyBall(helperPos, targetGhostPos, [helperBallId, targetBallId]);
          if (path2Check.blocked) continue;

          // CRITICAL: Check if helper path to target ghost would hit target prematurely
          if (wouldHitObjectBallPrematurely(helperPos, targetGhostPos, targetPos)) {
            continue; // Skip - helper would hit target at wrong angle
          }

          // Path 3: Target â†’ Pocket
          const path3Check = isPathBlockedByAnyBall(targetPos, pocketPos, [targetBallId]);
          if (path3Check.blocked) continue;

          // Calculate distances
          const dist1 = Math.hypot(helperGhostPos.x - cuePos.x, helperGhostPos.y - cuePos.y);
          const dist2 = Math.hypot(targetGhostPos.x - helperPos.x, targetGhostPos.y - helperPos.y);
          const dist3 = Math.hypot(pocketPos.x - targetPos.x, pocketPos.y - targetPos.y);

          // Score the combination shot
          const comboScore = scoreComboShot(alignment, cutAngle1, cutAngle2, dist1, dist2, dist3);

          combos.push({
            helperBallId,
            targetBallId,
            pocketId,
            helperPos,
            targetPos,
            pocketPos,
            helperGhostPos,
            targetGhostPos,
            alignment,
            cutAngle1,
            cutAngle2,
            dist1,
            dist2,
            dist3,
            score: comboScore.score,
            viable: comboScore.viable,
            difficulty: comboScore.difficulty,
            reason: comboScore.reason
          });
        }

        // Sort by score (best first)
        return combos.sort((a, b) => b.score - a.score);
      }

      // Score a combination shot based on alignment, cut angles, and distances
      function scoreComboShot(alignment, cutAngle1, cutAngle2, dist1, dist2, dist3) {
        // CRITICAL: Very steep individual cut angles make combos nearly impossible
        // Each collision compounds error - both cuts need to be achievable
        const maxCutAngle = Math.max(cutAngle1, cutAngle2);
        if (maxCutAngle > 65) {
          return {
            score: 0,
            viable: false,
            difficulty: 'Hard',
            reason: `Cut angle too steep (${maxCutAngle.toFixed(0)}Â°) for combo shot`
          };
        }

        // Base score from alignment (0.3 to 1.0 maps to 0 to 50)
        let score = (alignment - 0.3) / 0.7 * 50;

        // ENHANCED penalty for cut angles (compound difficulty)
        // Combos are already hard - each cut angle adds exponential difficulty
        const totalCutAngle = cutAngle1 + cutAngle2;

        // Individual cut angle penalties
        if (cutAngle1 > 50) score -= (cutAngle1 - 50) * 1.5;
        else if (cutAngle1 > 35) score -= (cutAngle1 - 35) * 0.8;

        if (cutAngle2 > 50) score -= (cutAngle2 - 50) * 1.5;
        else if (cutAngle2 > 35) score -= (cutAngle2 - 35) * 0.8;

        // Combined cut angle penalty
        if (totalCutAngle > 80) score -= (totalCutAngle - 80) * 1.0;
        else if (totalCutAngle > 50) score -= (totalCutAngle - 50) * 0.5;

        // Penalty for long distances (more error accumulation)
        const totalDist = dist1 + dist2 + dist3;
        if (totalDist > 80) score -= (totalDist - 80) * 0.3;

        // Bonus for short, aligned combos
        if (dist2 < 15 && alignment > 0.8) score += 20;

        // Determine difficulty based on cut angles and score
        let difficulty;
        if (maxCutAngle > 50 || totalCutAngle > 70 || score < 20) {
          difficulty = 'Hard';
        } else if (maxCutAngle > 35 || totalCutAngle > 50 || score < 40) {
          difficulty = 'Medium';
        } else {
          difficulty = 'Easy';
        }

        const viable = score > 10;

        return {
          score: Math.max(0, Math.min(100, score)),
          viable,
          difficulty,
          reason: viable ? null : 'Poor alignment or difficult angles'
        };
      }

      // Check if a combination shot is legal for the current game mode
      function isComboLegalForGameMode(combo) {
        // In rotation games (9-ball, 10-ball), must hit lowest ball first
        if (currentGameMode.comboMustHitLowestFirst) {
          const lowest = findLowestBallOnTable();
          if (combo.helperBallId !== lowest) {
            return { legal: false, reason: `Must hit ${lowest}-ball first` };
          }
        }

        // In 8-ball, must hit your suit first
        if (currentGameMode.comboMustHitSuitFirst) {
          const suitBalls = currentGameMode.suitGroups[playerSuit];
          if (suitBalls && !suitBalls.includes(combo.helperBallId)) {
            return { legal: false, reason: `Must hit ${playerSuit} first` };
          }
        }

        return { legal: true, reason: null };
      }

      // Find all legal combination shots for current game state
      function findLegalCombinationShots(cuePos, pocketId) {
        const allCombos = [];

        // Get balls that could be pocketed
        const ballsOnTable = Object.keys(ballPositions).filter(id =>
          id !== 'cue' && id !== 'ghost' && ballPositions[id]
        );

        for (const targetBallId of ballsOnTable) {
          const combos = findCombinationShots(cuePos, targetBallId, pocketId);

          for (const combo of combos) {
            const legality = isComboLegalForGameMode(combo);
            if (legality.legal) {
              allCombos.push(combo);
            }
          }
        }

        // Sort by score
        return allCombos.sort((a, b) => b.score - a.score);
      }

      // Solver preference enum
      const SOLVER_MODE = {
        AUTO: 'auto',
        PREFER_KICK: 'kick',
        PREFER_BANK: 'bank',
        PREFER_COMBO: 'combo'
      };

      let currentSolverMode = SOLVER_MODE.AUTO;
      let currentComboShot = null; // Track active combo shot for display

      // Draw combination shot visualization
      function drawComboShot(combo) {
        if (!combo) {
          hideComboShot();
          return;
        }

        const cuePos = ballPositions['cue'];
        if (!cuePos) return;

        // Path 1: Cue â†’ Helper ghost (dashed)
        comboPath1.setAttribute('d', `M ${cuePos.x} ${cuePos.y} L ${combo.helperGhostPos.x} ${combo.helperGhostPos.y}`);

        // Path 2: Helper â†’ Target
        comboPath2.setAttribute('d', `M ${combo.helperPos.x} ${combo.helperPos.y} L ${combo.targetPos.x} ${combo.targetPos.y}`);

        // Path 3: Target â†’ Pocket
        comboPath3.setAttribute('d', `M ${combo.targetPos.x} ${combo.targetPos.y} L ${combo.pocketPos.x} ${combo.pocketPos.y}`);

        // Position helper ghost indicator
        comboHelperGhost.setAttribute('transform', `translate(${combo.helperGhostPos.x}, ${combo.helperGhostPos.y})`);

        // Position COMBO label near the helper ball
        comboLabel.setAttribute('x', combo.helperPos.x);
        comboLabel.setAttribute('y', combo.helperPos.y - 2.5);

        // Show the indicator
        comboShotIndicator.setAttribute('visibility', 'visible');
        currentComboShot = combo;
      }

      // Hide combination shot visualization
      function hideComboShot() {
        comboShotIndicator.setAttribute('visibility', 'hidden');
        currentComboShot = null;
      }

      // Get ball hit fraction name from cut angle
      function getBallHitName(cutAngle) {
        if (cutAngle < 7) return 'Full ball';
        if (cutAngle < 22) return '3/4 ball';
        if (cutAngle < 40) return '1/2 ball';
        if (cutAngle < 58) return '1/4 ball';
        return 'Thin cut';
      }

      // Standard ball-hit fractions used in pool
      const BALL_HIT_FRACTIONS = [
        { threshold: 0.9375, english: 'Full ball', slash: 'Full' },
        { threshold: 0.8125, english: 'Seven-eighths', slash: '7/8' },
        { threshold: 0.6875, english: 'Three-quarters', slash: '3/4' },
        { threshold: 0.5625, english: 'Five-eighths', slash: '5/8' },
        { threshold: 0.4375, english: 'Half ball', slash: '1/2' },
        { threshold: 0.3125, english: 'Three-eighths', slash: '3/8' },
        { threshold: 0.1875, english: 'Quarter ball', slash: '1/4' },
        { threshold: 0.0625, english: 'One-eighth', slash: '1/8' },
        { threshold: 0, english: 'Thin cut', slash: 'Thin' }
      ];

      // Convert overlap fraction to nearest standard pool fraction
      function getOverlapFraction(overlapFraction) {
        for (const frac of BALL_HIT_FRACTIONS) {
          if (overlapFraction >= frac.threshold) {
            return frac;
          }
        }
        return BALL_HIT_FRACTIONS[BALL_HIT_FRACTIONS.length - 1];
      }

      // Update the shooter's eye view overlap diagram
      // Shows ghost ball and object ball overlap as seen from behind cue ball
      function updateOverlapDiagram(overlapFraction) {
        // Ball radius in the diagram is 1 unit
        // Object ball is fixed at x=0.5
        // Ghost ball position: offset based on overlap
        // offset = (1 - overlap) * 2 * radius
        // For overlap=1 (full): ghost at 0.5 (same as OB)
        // For overlap=0.5 (half): ghost at -0.5 (offset by 1 radius)
        // For overlap=0 (miss): ghost at -1.5 (offset by 2 radii)

        const objBallX = 0.5;
        const ballRadius = 1;
        const offset = (1 - overlapFraction) * 2 * ballRadius;
        const ghostBallX = objBallX - offset;

        // Update ghost ball position
        overlapGhostBall.setAttribute('cx', ghostBallX);
        overlapGhostLabel.setAttribute('x', ghostBallX);
        overlapRegion.setAttribute('cx', ghostBallX);

        // Get nearest standard pool fraction
        const fraction = getOverlapFraction(overlapFraction);

        // Update all displays
        overlapPercentDisplay.textContent = Math.round(overlapFraction * 100) + '%';
        overlapEnglishDisplay.textContent = fraction.english;
        overlapSlashDisplay.textContent = fraction.slash;
      }

      // Update Shot Instructions Panel - THE KEY ANSWER to the user's question
      function updateShotInstructions(shotData) {
        if (!shotData || !shotData.isReady) {
          // Not enough info to provide instructions
          shotVerdict.textContent = 'Setup Needed';
          shotVerdict.className = 'shot-verdict setup-needed';
          aimInstruction.textContent = 'Place balls and select pocket';
          aimInstruction.classList.remove('highlight');
          englishInstruction.textContent = '--';
          englishHint.textContent = '';
          powerNeeded.textContent = '--';
          powerStatus.textContent = '';
          powerStatus.className = '';
          difficultyFill.className = 'difficulty-fill';
          difficultyText.textContent = '--';
          difficultyText.className = 'difficulty-text';
          return;
        }

        // Check if selected ball is a legal target for current game mode
        let illegalBallWarning = '';
        if (shotData.selectedBallId && !shotData.isLegalTarget && shotData.targetRule !== 'any') {
          // Build warning message based on game mode
          if (shotData.targetRule === 'rotation') {
            const lowestBall = shotData.legalTargetBalls[0];
            illegalBallWarning = `Must hit ${lowestBall}-ball first!`;
          } else if (shotData.targetRule === 'suit') {
            illegalBallWarning = `Must hit your suit first!`;
          }
        }

        // Check if object ball path to pocket is blocked
        let obPathBlockedWarning = '';
        if (shotData.obPathBlocked && shotData.obBlockingBalls && shotData.obBlockingBalls.length > 0) {
          const blockingBallIds = shotData.obBlockingBalls.join(', ');
          obPathBlockedWarning = `Path blocked by ${blockingBallIds}-ball!`;
        }

        // Determine shot type and aim point description
        let aimText = '';
        let englishText = 'Center';
        let englishHintText = '';

        if (shotData.isKickShot) {
          const railName = shotData.kickRail.charAt(0).toUpperCase() + shotData.kickRail.slice(1);
          aimText = `${railName} rail kick point`;
          aimInstruction.classList.add('highlight');

          // English for kick
          if (shotData.requiredEnglish !== undefined) {
            const eng = shotData.requiredEnglish;
            if (Math.abs(eng) < 0.15) {
              englishText = 'Center';
            } else if (eng > 0) {
              englishText = eng > 0.5 ? 'Strong Right' : 'Slight Right';
              englishHintText = 'Running english (widens angle)';
            } else {
              englishText = eng < -0.5 ? 'Strong Left' : 'Slight Left';
              englishHintText = 'Check english (tightens angle)';
            }
          }
        } else if (shotData.isBankShot) {
          const railName = shotData.bankRail.charAt(0).toUpperCase() + shotData.bankRail.slice(1);
          aimText = `Ghost ball (bank off ${railName})`;
          aimInstruction.classList.add('highlight');
          englishHintText = shotData.throwInfo || '';
        } else if (shotData.isComboShot) {
          // Combination shot
          aimText = `Hit ${shotData.comboHelperBall}-ball into ${shotData.comboTargetBall}-ball`;
          aimInstruction.classList.add('highlight');
          englishHintText = `Combo (${shotData.comboDifficulty || 'Hard'})`;
        } else {
          // Direct shot
          aimText = `Ghost ball (${shotData.ballHitFraction})`;
          aimInstruction.classList.add('highlight');
        }

        // English from contact offset
        const engX = shotData.contactX || 0;
        const engY = shotData.contactY || 0;
        if (!shotData.isKickShot) {
          const parts = [];
          if (engY < -0.15) parts.push('Follow');
          else if (engY > 0.15) parts.push('Draw');
          if (engX < -0.15) parts.push('Left');
          else if (engX > 0.15) parts.push('Right');
          if (parts.length > 0) {
            englishText = parts.join(' + ');
          }
          englishHintText = engY < -0.15 ? 'CB follows through' : engY > 0.15 ? 'CB pulls back' : '';
        }

        // Power assessment
        const currentPower = shotData.power || 5;
        const minPower = shotData.minPowerNeeded || 3;
        const powerEnough = currentPower >= minPower;

        powerNeeded.textContent = `${currentPower}/10`;
        if (powerEnough) {
          powerStatus.textContent = '(enough)';
          powerStatus.className = 'enough';
        } else {
          powerStatus.textContent = `(need ${minPower}+)`;
          powerStatus.className = 'not-enough';
        }

        // Calculate difficulty based on multiple factors
        let difficultyScore = 0;
        const cutAngle = shotData.cutAngle || 0;
        const distance = shotData.totalDistance || 50;

        // Cut angle difficulty (0-30 easy, 30-50 medium, 50+ hard)
        if (cutAngle > 60) difficultyScore += 40;
        else if (cutAngle > 45) difficultyScore += 25;
        else if (cutAngle > 30) difficultyScore += 15;
        else difficultyScore += 5;

        // Distance difficulty
        if (distance > 80) difficultyScore += 25;
        else if (distance > 50) difficultyScore += 15;
        else difficultyScore += 5;

        // Kick/bank/combo adds difficulty
        if (shotData.isKickShot) difficultyScore += 20;
        if (shotData.isBankShot) difficultyScore += 15;
        if (shotData.isComboShot) {
          // Combo shots have compound cut angle difficulty
          difficultyScore += 25;
          if (shotData.comboCutAngle1 > 40 || shotData.comboCutAngle2 > 40) {
            difficultyScore += 15;
          }
        }

        // English requirement adds difficulty
        if (Math.abs(engX) > 0.5 || Math.abs(engY) > 0.5) difficultyScore += 10;

        // Power issues
        if (!powerEnough) difficultyScore += 20;

        // Determine verdict and difficulty level
        let verdict, verdictClass, diffLevel, diffClass;

        // Override verdict if illegal ball is selected or path is blocked
        if (illegalBallWarning) {
          verdict = 'FOUL';
          verdictClass = 'foul';
          diffLevel = 'Illegal';
          diffClass = 'foul';
        } else if (obPathBlockedWarning) {
          verdict = 'Blocked';
          verdictClass = 'very-hard';
          diffLevel = 'Blocked';
          diffClass = 'very-hard';
        } else if (difficultyScore <= 25) {
          verdict = 'Makeable';
          verdictClass = 'makeable';
          diffLevel = 'Easy';
          diffClass = 'easy';
        } else if (difficultyScore <= 45) {
          verdict = 'Makeable';
          verdictClass = 'makeable';
          diffLevel = 'Medium';
          diffClass = 'medium';
        } else if (difficultyScore <= 70) {
          verdict = 'Difficult';
          verdictClass = 'difficult';
          diffLevel = 'Hard';
          diffClass = 'hard';
        } else {
          verdict = 'Very Hard';
          verdictClass = 'very-hard';
          diffLevel = 'Very Hard';
          diffClass = 'very-hard';
        }

        // Update UI
        shotVerdict.textContent = verdict;
        shotVerdict.className = 'shot-verdict ' + verdictClass;
        aimInstruction.textContent = aimText;
        englishInstruction.textContent = englishText;
        englishHint.textContent = englishHintText;

        // Show/hide foul warning banner (for fouls or blocked paths)
        if (illegalBallWarning) {
          foulWarningBanner.style.display = 'flex';
          foulMessage.textContent = illegalBallWarning;
        } else if (obPathBlockedWarning) {
          foulWarningBanner.style.display = 'flex';
          foulMessage.textContent = obPathBlockedWarning;
        } else {
          foulWarningBanner.style.display = 'none';
        }

        difficultyFill.className = 'difficulty-fill ' + diffClass;
        difficultyText.textContent = diffLevel;
        difficultyText.className = 'difficulty-text ' + diffClass;
      }

      // Calculate overlap fraction (1 = full ball, 0 = no overlap)
      function calculateOverlap(cutAngleDegrees) {
        const cutAngleRad = cutAngleDegrees * (Math.PI / 180);
        return 1 - Math.sin(cutAngleRad);
      }

      // Get spin type description from contact offset
      function getSpinType(offset) {
        const threshold = 0.15;
        const parts = [];

        if (offset.y < -threshold) parts.push('Follow');
        else if (offset.y > threshold) parts.push('Draw');

        if (offset.x < -threshold) parts.push('Left');
        else if (offset.x > threshold) parts.push('Right');

        if (parts.length === 0) return 'Center';
        return parts.join(' + ');
      }

      // Calculate perpendicular vector (90Â° rotation)
      function vectorPerpendicular(v) {
        return { x: -v.y, y: v.x };
      }

      // Scale a vector
      function vectorScale(v, s) {
        return { x: v.x * s, y: v.y * s };
      }

      // Add two vectors
      function vectorAdd(a, b) {
        return { x: a.x + b.x, y: a.y + b.y };
      }

      // Clamp a value between min and max
      function clamp(val, min, max) {
        return Math.max(min, Math.min(max, val));
      }

      // Rail boundaries (cushion nose positions) - ball center can reach rail + BALL_RADIUS
      const RAILS = {
        top: { y: 2 + BALL_RADIUS, normal: { x: 0, y: 1 } },      // Ball bounces when center.y <= 3.125
        bottom: { y: 48 - BALL_RADIUS, normal: { x: 0, y: -1 } }, // Ball bounces when center.y >= 46.875
        left: { x: 2 + BALL_RADIUS, normal: { x: 1, y: 0 } },     // Ball bounces when center.x <= 3.125
        right: { x: 98 - BALL_RADIUS, normal: { x: -1, y: 0 } }   // Ball bounces when center.x >= 96.875
      };

      // Find intersection of ray with rail, returns { point, rail, t } or null
      function findRailIntersection(start, direction, maxDist) {
        let closest = null;
        let minT = maxDist;

        // Check horizontal rails (top/bottom)
        ['top', 'bottom'].forEach(railName => {
          const rail = RAILS[railName];
          if (Math.abs(direction.y) > 0.001) {
            const t = (rail.y - start.y) / direction.y;
            if (t > 0.1 && t < minT) {
              const x = start.x + direction.x * t;
              if (x >= RAILS.left.x && x <= RAILS.right.x) {
                minT = t;
                closest = { point: { x, y: rail.y }, rail: railName, normal: rail.normal, t };
              }
            }
          }
        });

        // Check vertical rails (left/right)
        ['left', 'right'].forEach(railName => {
          const rail = RAILS[railName];
          if (Math.abs(direction.x) > 0.001) {
            const t = (rail.x - start.x) / direction.x;
            if (t > 0.1 && t < minT) {
              const y = start.y + direction.y * t;
              if (y >= RAILS.top.y && y <= RAILS.bottom.y) {
                minT = t;
                closest = { point: { x: rail.x, y }, rail: railName, normal: rail.normal, t };
              }
            }
          }
        });

        return closest;
      }

      // Reflect direction off rail with english effects
      // Running english (spin with travel) widens angle, check english narrows it
      function reflectOffRail(direction, railNormal, contactOff) {
        // Basic reflection: r = d - 2(dÂ·n)n
        const dot = dotProduct(direction, railNormal);
        let reflected = {
          x: direction.x - 2 * dot * railNormal.x,
          y: direction.y - 2 * dot * railNormal.y
        };

        // Apply sidespin (english) effect
        // English is contactOff.x: positive = right spin, negative = left spin
        const english = contactOff.x;

        if (Math.abs(english) > 0.05) {
          // Determine if this is running or check english
          // Running english: spin direction matches the direction ball will travel along rail
          // For horizontal rails (top/bottom): travel is in x direction after bounce
          // For vertical rails (left/right): travel is in y direction after bounce

          let isRunning = false;
          if (railNormal.y !== 0) {
            // Horizontal rail (top or bottom) - travel along x axis
            // Running = english pushes ball in same direction as reflected.x
            isRunning = (english > 0 && reflected.x > 0) || (english < 0 && reflected.x < 0);
          } else {
            // Vertical rail (left or right) - travel along y axis
            // Running = english pushes ball in same direction as reflected.y
            isRunning = (english > 0 && reflected.y < 0) || (english < 0 && reflected.y > 0);
          }

          // Modify angle: running widens (more parallel), check narrows (more perpendicular)
          const englishEffect = Math.abs(english) * 0.4;  // Up to ~20% angle change

          if (railNormal.y !== 0) {
            // Horizontal rail - modify x component
            const modifier = isRunning ? (1 + englishEffect) : (1 - englishEffect);
            reflected.x *= modifier;
          } else {
            // Vertical rail - modify y component
            const modifier = isRunning ? (1 + englishEffect) : (1 - englishEffect);
            reflected.y *= modifier;
          }

          // Renormalize
          reflected = vectorNormalize(reflected);
        }

        return reflected;
      }

      // Calculate cue ball path after contact with rail bounces
      // Physics: CB travels perpendicular to OB path (90Â° rule for stun), then bounces off rails
      // Energy transfer: CB retains sinÂ²(cutAngle) of energy, OB gets cosÂ²(cutAngle)
      // Follow/Draw creates initial curve (friction on cloth), English affects bounce angles
      function calculateCueBallPath(ghostBallPos, objBallDirection, contactOff, force, cutAngleDeg) {
        // Tangent line is perpendicular to object ball path
        const tangent1 = vectorPerpendicular(objBallDirection);
        const tangent2 = vectorScale(tangent1, -1);

        // Get cue ball position to determine which tangent direction
        const cuePos = ballPositions['cue'];
        if (!cuePos) return null;

        // The CB deflects in the direction of its velocity component perpendicular to the contact line
        const cueToGhost = vectorSubtract(ghostBallPos, cuePos);
        const dot1 = dotProduct(tangent1, cueToGhost);
        const tangent = dot1 > 0 ? tangent1 : tangent2;

        // Physics: CB speed after collision = initial_speed Ã— sin(cut_angle)
        // For stun shot, CB retains sin(cutAngle) of its speed
        const cutAngleRad = (cutAngleDeg || 30) * Math.PI / 180;
        const cbSpeedFactor = Math.sin(cutAngleRad);

        // Base path length from force, scaled by energy retained
        const baseLength = 10 + force * 5;  // 15 to 60 units base
        let totalLength = baseLength * Math.max(0.1, cbSpeedFactor);  // Min 10% to show something

        // Calculate spin effect for the curved first segment
        // Follow (y < 0) curves forward, Draw (y > 0) curves backward
        const spinAmount = Math.abs(contactOff.y) * (force / 5);
        const hasSpin = Math.abs(contactOff.y) > 0.05;
        const isFollow = contactOff.y < -0.05;
        const isDraw = contactOff.y > 0.05;

        // For near-full ball hits (cut < 10Â°), spin dominates the CB motion
        const isFullBallHit = cutAngleDeg < 10;

        // Spin adds energy to CB path (follow continues forward, draw pulls back)
        if (hasSpin) {
          // Spin effect adds to path length - more spin = more CB travel
          const spinBonus = spinAmount * baseLength * 0.5;
          totalLength = Math.max(totalLength, spinBonus);
        }

        // Determine CB direction based on cut angle and spin
        let curveDirection;
        if (isFullBallHit && isDraw) {
          // Draw on full ball: CB comes back toward shooter
          curveDirection = vectorScale(objBallDirection, -1);
        } else if (isFullBallHit && isFollow) {
          // Follow on full ball: CB continues forward with OB
          curveDirection = objBallDirection;
        } else if (isDraw) {
          // Draw on cut shot: curves back
          curveDirection = vectorScale(objBallDirection, -1);
        } else {
          // Follow or stun on cut shot: curves forward
          curveDirection = objBallDirection;
        }

        // First segment: curved path showing follow/draw effect
        // The curve length is where spin "settles" into natural roll
        const curveLength = Math.min(8 + force * 2, totalLength * 0.6);  // 10-18 units, max 60% of path
        const curveAmount = spinAmount * (isFullBallHit ? 30 : 20);  // More curve effect on full ball hits

        // Calculate bezier curve points for first segment
        const start = { ...ghostBallPos };
        const tangentEnd = vectorAdd(start, vectorScale(tangent, curveLength));
        const curvedEnd = hasSpin
          ? vectorAdd(tangentEnd, vectorScale(curveDirection, curveAmount))
          : tangentEnd;

        // Control point for smooth bezier curve
        const controlDist = curveLength * 0.5;
        const controlBase = vectorAdd(start, vectorScale(tangent, controlDist));
        const controlCurveShift = vectorScale(curveDirection, curveAmount * 0.3);
        const control = hasSpin
          ? vectorAdd(controlBase, controlCurveShift)
          : controlBase;

        // Direction at end of curve (for subsequent straight segments)
        // Approximate: direction from control to end
        let direction = vectorNormalize(vectorSubtract(curvedEnd, control));

        // Check if curve segment hits a rail
        // Sample points along bezier to detect rail intersection
        let curveHitsRail = false;
        let railHitPoint = null;
        let railHitT = 1;
        let hitRailNormal = null;

        for (let t = 0.1; t <= 1; t += 0.1) {
          // Quadratic bezier: B(t) = (1-t)Â²P0 + 2(1-t)tP1 + tÂ²P2
          const mt = 1 - t;
          const px = mt * mt * start.x + 2 * mt * t * control.x + t * t * curvedEnd.x;
          const py = mt * mt * start.y + 2 * mt * t * control.y + t * t * curvedEnd.y;

          // Check rail boundaries
          if (py <= RAILS.top.y) {
            curveHitsRail = true;
            railHitPoint = { x: px, y: RAILS.top.y };
            railHitT = t;
            hitRailNormal = RAILS.top.normal;
            break;
          } else if (py >= RAILS.bottom.y) {
            curveHitsRail = true;
            railHitPoint = { x: px, y: RAILS.bottom.y };
            railHitT = t;
            hitRailNormal = RAILS.bottom.normal;
            break;
          } else if (px <= RAILS.left.x) {
            curveHitsRail = true;
            railHitPoint = { x: RAILS.left.x, y: py };
            railHitT = t;
            hitRailNormal = RAILS.left.normal;
            break;
          } else if (px >= RAILS.right.x) {
            curveHitsRail = true;
            railHitPoint = { x: RAILS.right.x, y: py };
            railHitT = t;
            hitRailNormal = RAILS.right.normal;
            break;
          }
        }

        // Build the path result
        const result = {
          // First segment is always the bezier curve (or portion of it)
          curveStart: start,
          curveControl: control,
          curveEnd: curveHitsRail ? railHitPoint : curvedEnd,
          hasCurve: hasSpin,
          segments: []  // Additional straight segments after bounces
        };

        // If curve hits rail, calculate bounces from that point
        if (curveHitsRail) {
          // Get direction at point of rail contact (tangent to bezier)
          const mt = 1 - railHitT;
          const dx = 2 * mt * (control.x - start.x) + 2 * railHitT * (curvedEnd.x - control.x);
          const dy = 2 * mt * (control.y - start.y) + 2 * railHitT * (curvedEnd.y - control.y);
          direction = vectorNormalize({ x: dx, y: dy });

          // Reflect and continue
          direction = reflectOffRail(direction, hitRailNormal, contactOff);
          let currentPos = { ...railHitPoint };
          let remainingLength = totalLength - (curveLength * railHitT);
          let bounces = 1;
          const maxBounces = 3;

          while (remainingLength > 1 && bounces <= maxBounces) {
            const intersection = findRailIntersection(currentPos, direction, remainingLength);

            if (intersection && intersection.t < remainingLength) {
              result.segments.push({ start: { ...currentPos }, end: { ...intersection.point } });
              direction = reflectOffRail(direction, intersection.normal, contactOff);
              currentPos = intersection.point;
              remainingLength -= intersection.t;
              bounces++;
            } else {
              const endPoint = vectorAdd(currentPos, vectorScale(direction, remainingLength));
              result.segments.push({ start: { ...currentPos }, end: endPoint });
              break;
            }
          }
        } else {
          // Curve didn't hit rail - continue with straight segments from curve end
          let currentPos = { ...curvedEnd };
          let remainingLength = totalLength - curveLength;
          let bounces = 0;
          const maxBounces = 3;

          while (remainingLength > 1 && bounces <= maxBounces) {
            const intersection = findRailIntersection(currentPos, direction, remainingLength);

            if (intersection && intersection.t < remainingLength) {
              result.segments.push({ start: { ...currentPos }, end: { ...intersection.point } });
              direction = reflectOffRail(direction, intersection.normal, contactOff);
              currentPos = intersection.point;
              remainingLength -= intersection.t;
              bounces++;
            } else {
              const endPoint = vectorAdd(currentPos, vectorScale(direction, remainingLength));
              result.segments.push({ start: { ...currentPos }, end: endPoint });
              break;
            }
          }
        }

        return result;
      }

      // Ball definitions in order
      const balls = [
        { id: 'cue', label: 'CUE', cls: 'ball-cue' },
        { id: 'ghost', label: 'AIM', cls: 'ball-ghost' },
        { id: '1', label: '1', cls: 'ball-1' },
        { id: '2', label: '2', cls: 'ball-2' },
        { id: '3', label: '3', cls: 'ball-3' },
        { id: '4', label: '4', cls: 'ball-4' },
        { id: '5', label: '5', cls: 'ball-5' },
        { id: '6', label: '6', cls: 'ball-6' },
        { id: '7', label: '7', cls: 'ball-7' },
        { id: '8', label: '8', cls: 'ball-8' },
        { id: '9', label: '9', cls: 'ball-9' },
        { id: '10', label: '10', cls: 'ball-10' },
        { id: '11', label: '11', cls: 'ball-11' },
        { id: '12', label: '12', cls: 'ball-12' },
        { id: '13', label: '13', cls: 'ball-13' },
        { id: '14', label: '14', cls: 'ball-14' },
        { id: '15', label: '15', cls: 'ball-15' },
        { id: 'gray', label: 'OBJ', cls: 'ball-gray' }
      ];

      let draggedBall = null;
      let offsetX = 0, offsetY = 0;
      let dragStartPos = null;      // Track mouse position at start
      let dragStartTime = null;     // Track time for long-press detection
      let isDragging = false;       // True if actually dragging (not just click)
      const DRAG_THRESHOLD = 5;     // Pixels to move before considered a drag
      const LONG_PRESS_TIME = 400;  // Milliseconds for long-press selection
      const ballPositions = {}; // Track SVG coordinates for balls on table

      // Create balls in palette (or fallback to rack)
      function createBalls() {
        const paletteGrid = document.getElementById('paletteBallGrid');
        const paletteSpecial = document.getElementById('paletteBallSpecial');

        balls.forEach((ball, i) => {
          const el = document.createElement('div');
          el.className = `ball ${ball.cls}`;
          el.id = `ball-${ball.id}`;
          el.dataset.ballId = ball.id;

          // Create SVG label instead of text content
          const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
          svg.setAttribute('viewBox', '0 0 100 100');
          svg.setAttribute('class', 'ball-label-svg');

          const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
          text.setAttribute('x', '50');
          text.setAttribute('y', '50');
          text.setAttribute('text-anchor', 'middle');
          text.setAttribute('dominant-baseline', 'central');
          text.textContent = ball.label;

          // Apply different styling based on ball type
          if (ball.id === 'cue') {
            text.setAttribute('class', 'ball-label ball-label-cue');
          } else if (ball.id === 'ghost') {
            text.setAttribute('class', 'ball-label ball-label-ghost');
          } else {
            text.setAttribute('class', 'ball-label ball-label-number');
          }

          svg.appendChild(text);
          el.appendChild(svg);

          // Put cue and ghost in special row, others in grid
          if (paletteGrid && paletteSpecial) {
            if (ball.id === 'cue' || ball.id === 'ghost') {
              paletteSpecial.appendChild(el);
            } else {
              paletteGrid.appendChild(el);
            }
          } else {
            // Fallback to old rack
            ballRack.appendChild(el);
          }
        });
      }

      // Convert page coordinates to SVG coordinates
      function pageToSvg(pageX, pageY) {
        const rect = tableSvg.getBoundingClientRect();
        const viewBox = tableSvg.viewBox.baseVal;

        const scaleX = viewBox.width / rect.width;
        const scaleY = viewBox.height / rect.height;

        return {
          x: (pageX - rect.left) * scaleX + viewBox.x,
          y: (pageY - rect.top) * scaleY + viewBox.y
        };
      }

      // Convert SVG coordinates to page position (for ball placement)
      function svgToPage(svgX, svgY) {
        const rect = tableSvg.getBoundingClientRect();
        const viewBox = tableSvg.viewBox.baseVal;

        const scaleX = rect.width / viewBox.width;
        const scaleY = rect.height / viewBox.height;

        return {
          x: (svgX - viewBox.x) * scaleX + rect.left,
          y: (svgY - viewBox.y) * scaleY + rect.top
        };
      }

      // Check if SVG point is on the playing surface
      function isOnPlayingSurface(svgX, svgY) {
        return svgX >= 2 && svgX <= 98 && svgY >= 2 && svgY <= 48;
      }

      // Update the cue stick visualization
      // Shows a semi-realistic cue stick extending from behind cue ball toward the aim point
      function updateCueStick(cuePos, aimTarget) {
        if (!cuePos || !aimTarget) {
          cueStick.setAttribute('visibility', 'hidden');
          return;
        }

        // Calculate direction from cue ball to aim target
        const direction = vectorNormalize(vectorSubtract(aimTarget, cuePos));

        // Cue stick dimensions (in SVG units)
        const CUE_LENGTH = 45;        // Total length of visible cue
        const TIP_WIDTH = 0.5;        // Width at tip (narrow)
        const BUTT_WIDTH = 1.2;       // Width at butt end (wide)
        const FERRULE_LENGTH = 1.5;   // Length of ferrule (white part)
        const TIP_OFFSET = 0.8;       // How far tip is from cue ball center

        // Calculate perpendicular vector for width
        const perp = { x: -direction.y, y: direction.x };

        // Tip position (slightly away from cue ball center toward aim)
        const tipPos = {
          x: cuePos.x - direction.x * TIP_OFFSET,
          y: cuePos.y - direction.y * TIP_OFFSET
        };

        // Butt position (far behind cue ball)
        const buttPos = {
          x: tipPos.x - direction.x * CUE_LENGTH,
          y: tipPos.y - direction.y * CUE_LENGTH
        };

        // Ferrule end position
        const ferruleEnd = {
          x: tipPos.x - direction.x * FERRULE_LENGTH,
          y: tipPos.y - direction.y * FERRULE_LENGTH
        };

        // Calculate taper - width increases linearly from tip to butt
        const ferruleWidth = TIP_WIDTH + (BUTT_WIDTH - TIP_WIDTH) * (FERRULE_LENGTH / CUE_LENGTH);

        // Build shaft polygon (ferrule end to butt)
        // Four corners: ferrule-left, ferrule-right, butt-right, butt-left
        const shaftPoints = [
          ferruleEnd.x + perp.x * ferruleWidth / 2, ferruleEnd.y + perp.y * ferruleWidth / 2,
          ferruleEnd.x - perp.x * ferruleWidth / 2, ferruleEnd.y - perp.y * ferruleWidth / 2,
          buttPos.x - perp.x * BUTT_WIDTH / 2, buttPos.y - perp.y * BUTT_WIDTH / 2,
          buttPos.x + perp.x * BUTT_WIDTH / 2, buttPos.y + perp.y * BUTT_WIDTH / 2
        ].join(' ');
        cueShaft.setAttribute('points', shaftPoints);

        // Build ferrule polygon (tip to ferrule end)
        const ferrulePoints = [
          tipPos.x + perp.x * TIP_WIDTH / 2, tipPos.y + perp.y * TIP_WIDTH / 2,
          tipPos.x - perp.x * TIP_WIDTH / 2, tipPos.y - perp.y * TIP_WIDTH / 2,
          ferruleEnd.x - perp.x * ferruleWidth / 2, ferruleEnd.y - perp.y * ferruleWidth / 2,
          ferruleEnd.x + perp.x * ferruleWidth / 2, ferruleEnd.y + perp.y * ferruleWidth / 2
        ].join(' ');
        cueFerule.setAttribute('points', ferrulePoints);

        // Position tip circle
        cueTip.setAttribute('cx', tipPos.x);
        cueTip.setAttribute('cy', tipPos.y);
        cueTip.setAttribute('r', TIP_WIDTH / 2);

        cueStick.setAttribute('visibility', 'visible');
      }

      // Update the cue-ghost connection line
      // Store current kick path info for display
      let currentKickPath = null;

      function updateCueGhostLine() {
        const cuePos = ballPositions['cue'];
        const ghostPos = ballPositions['ghost'];
        const objBallPos = selectedBallId ? ballPositions[selectedBallId] : null;
        const pocketPos = selectedPocket ? pocketCenters[selectedPocket] : null;

        // Hide kick aim indicator and actual path by default
        kickAimIndicator.setAttribute('visibility', 'hidden');
        actualKickPath.setAttribute('visibility', 'hidden');
        hideMirrorSystemVisualization();

        if (cuePos && ghostPos) {
          // Check if we need a kick shot (object ball blocking direct path)
          let pathD;
          currentKickPath = null;

          if (objBallPos) {
            // Pass shotForce, pocketPos, and targetBallId for physics-based path evaluation
            // This checks ALL balls on table as obstacles, not just the object ball
            const kickPath = findKickPath(cuePos, ghostPos, objBallPos, contactOffset.x, shotForce, pocketPos, selectedBallId);

            if (kickPath) {
              // Draw kick shot path with bounce points
              currentKickPath = kickPath;
              pathD = `M ${cuePos.x} ${cuePos.y}`;
              for (const point of kickPath.bouncePoints) {
                pathD += ` L ${point.x} ${point.y}`;
              }
              pathD += ` L ${ghostPos.x} ${ghostPos.y}`;

              // Show kick aim indicator at the first rail contact point
              const aimPoint = kickPath.aimPoint;
              kickAimIndicator.setAttribute('transform', `translate(${aimPoint.x}, ${aimPoint.y})`);

              // Position label based on which rail we're aiming at
              const railName = kickPath.rails[0];
              let labelY = -1.5;
              if (railName === 'bottom') labelY = 1.8;
              kickAimLabel.setAttribute('y', labelY);

              // Show rail name with viability info
              const railLabel = railName.charAt(0).toUpperCase() + railName.slice(1);
              let labelText = railLabel;

              // Add difficulty indicator based on viability
              if (kickPath.viability) {
                if (!kickPath.viability.viable) {
                  labelText += ' âœ—';  // Not viable - won't reach pocket
                } else if (kickPath.viability.difficulty === 'Hard') {
                  labelText += ' â—';  // Hard shot
                } else if (kickPath.viability.difficulty === 'Medium') {
                  labelText += ' â—';  // Medium difficulty
                }
                // Easy shots get no extra indicator
              }

              if (kickPath.scratches) {
                labelText += ' âš ';  // Warning for scratch risk
              }
              kickAimLabel.textContent = labelText;

              // Color the aim indicator based on viability
              const aimDiamond = kickAimIndicator.querySelector('polygon');
              if (aimDiamond) {
                if (!kickPath.viability || !kickPath.viability.viable) {
                  aimDiamond.setAttribute('fill', '#ff4444');  // Red = not viable
                } else if (kickPath.viability.difficulty === 'Hard') {
                  aimDiamond.setAttribute('fill', '#ff8800');  // Orange = hard
                } else if (kickPath.viability.difficulty === 'Medium') {
                  aimDiamond.setAttribute('fill', '#ffcc00');  // Yellow = medium
                } else {
                  aimDiamond.setAttribute('fill', '#44ff44');  // Green = easy
                }
              }

              kickAimIndicator.setAttribute('visibility', 'visible');

              // Update mirror system visualization (aiming aid overlay)
              try {
                updateMirrorSystemVisualization(kickPath, cuePos, ghostPos, contactOffset.x);
              } catch (e) {
                console.error('Mirror system visualization error:', e);
                hideMirrorSystemVisualization();
              }

              // Show actual kick path if user's english differs from required
              // This helps users see the effect of their english choice
              const englishDiff = Math.abs(kickPath.currentEnglish - kickPath.requiredEnglish);
              const hasSignificantEnglishError = englishDiff > 0.15 && kickPath.actualDestination;

              if (hasSignificantEnglishError) {
                // Draw red dashed line showing where CB actually goes with current english
                let actualPathD = `M ${cuePos.x} ${cuePos.y} L ${kickPath.aimPoint.x} ${kickPath.aimPoint.y}`;
                actualPathD += ` L ${kickPath.actualDestination.x} ${kickPath.actualDestination.y}`;
                actualKickPath.setAttribute('d', actualPathD);
                actualKickPath.setAttribute('visibility', 'visible');

                // Update label to show english is off
                const engDir = kickPath.requiredEnglish > kickPath.currentEnglish ? 'â†’' : 'â†';
                kickAimLabel.textContent = labelText + ` ${engDir}`;  // Arrow shows which way to adjust
              }
            }
          }

          // If no kick needed or no obj ball, draw direct line
          if (!pathD) {
            pathD = `M ${cuePos.x} ${cuePos.y} L ${ghostPos.x} ${ghostPos.y}`;
          }

          cueGhostLine.setAttribute('d', pathD);
          cueGhostLine.setAttribute('visibility', 'visible');

          // Update cue stick - aim at kick point if kick shot, otherwise at ghost ball
          const aimTarget = currentKickPath ? currentKickPath.aimPoint : ghostPos;
          updateCueStick(cuePos, aimTarget);
        } else {
          cueGhostLine.setAttribute('visibility', 'hidden');
          cueStick.setAttribute('visibility', 'hidden');
          currentKickPath = null;
        }

        // Update shot geometry whenever cue-ghost line changes
        updateShotGeometry();
      }

      // Update target line and calculate aiming angles
      function updateShotGeometry() {
        const ghostPos = ballPositions['ghost'];
        const objBallPos = selectedBallId ? ballPositions[selectedBallId] : null;
        const pocketPos = selectedPocket ? pocketCenters[selectedPocket] : null;
        const cuePos = ballPositions['cue'];

        // Need object ball and pocket selected to show target line
        if (objBallPos && pocketPos) {
          targetLine.setAttribute('x1', objBallPos.x);
          targetLine.setAttribute('y1', objBallPos.y);
          targetLine.setAttribute('x2', pocketPos.x);
          targetLine.setAttribute('y2', pocketPos.y);
          targetLine.setAttribute('visibility', 'visible');

          // Calculate ghost ball position (where cue ball should contact object ball)
          // Ghost ball is positioned along the obj-pocket line, one ball diameter back from object ball
          const objToPocket = vectorNormalize(vectorSubtract(pocketPos, objBallPos));
          const ghostBallX = objBallPos.x - objToPocket.x * GHOST_BALL_OFFSET;
          const ghostBallY = objBallPos.y - objToPocket.y * GHOST_BALL_OFFSET;
          const ghostBallPosition = { x: ghostBallX, y: ghostBallY };

          ghostBallIndicator.setAttribute('transform', `translate(${ghostBallX}, ${ghostBallY})`);
          ghostBallIndicator.setAttribute('visibility', 'visible');

          // Calculate cut angle FIRST so we can use it for path calculations
          // (Need cue and ghost positions for this)
          let cutAngle = 30;  // Default to half-ball if we can't calculate
          if (cuePos && ghostPos) {
            const aimVector = vectorSubtract(ghostPos, cuePos);
            const targetVector = vectorSubtract(pocketPos, objBallPos);
            cutAngle = angleBetweenVectors(aimVector, targetVector);
          }

          // Physics: OB receives cosÂ²(cutAngle) of energy, speed âˆ cos(cutAngle)
          const cutAngleRad = cutAngle * Math.PI / 180;
          const obSpeedFactor = Math.cos(cutAngleRad);

          // Object ball path - length scaled by energy transfer and force
          const baseObjPathLength = 10 + shotForce * 5;
          let objPathLength = baseObjPathLength * obSpeedFactor;

          // Check distance to target pocket - if OB would reach pocket, stop there
          const distToPocket = vectorLength(vectorSubtract(pocketPos, objBallPos));
          const pocketRadius = 2.5;  // Pocket opening radius
          let obMadeIt = false;  // Did OB reach the pocket?

          // If path length reaches the pocket, stop at pocket center
          if (objPathLength >= distToPocket - pocketRadius) {
            objPathLength = distToPocket;
            obMadeIt = true;
          }

          // Check if object ball path to pocket is blocked by other balls
          const obPathExcludeIds = ['cue', 'ghost', selectedBallId].filter(Boolean);
          const obPathBlockCheck = isPathBlockedByAnyBall(objBallPos, pocketPos, obPathExcludeIds);
          const obPathBlocked = obPathBlockCheck.blocked;
          const obBlockingBalls = obPathBlockCheck.blockingBalls || [];

          // If OB path is blocked, OB won't make it to pocket
          if (obPathBlocked) {
            obMadeIt = false;
          }

          // Check if we should show a bank shot instead of direct shot
          let currentBankShot = null;
          let showingBank = false;

          // In auto mode, consider alternatives if cue-to-ghost OR ob-to-pocket path is blocked
          const directPathBlocked = currentKickPath !== null || obPathBlocked;

          if (cuePos && (currentSolverMode === 'bank' || (currentSolverMode === 'auto' && directPathBlocked))) {
            // Check all balls on table as obstacles when finding bank shots
            const bankShots = findBankShots(cuePos, objBallPos, pocketPos, shotForce, contactOffset.x, selectedBallId);
            if (bankShots.length > 0) {
              const bestBank = bankShots[0];
              // In bank mode, always show bank. In auto mode, show bank if kick isn't viable
              const kickNotViable = currentKickPath && (!currentKickPath.viability || !currentKickPath.viability.viable);
              if (currentSolverMode === 'bank' || (bestBank.viability.viable && kickNotViable)) {
                currentBankShot = bestBank;
                showingBank = true;
              }
            }
          }

          // Hide bank indicator by default
          bankPointIndicator.setAttribute('visibility', 'hidden');

          // Check if we should show a combo shot
          let currentCombo = null;
          let showingCombo = false;

          if (cuePos && selectedPocket && (currentSolverMode === 'combo' || currentSolverMode === 'auto')) {
            // Find combo shots that can pocket the target ball
            const combos = findCombinationShots(cuePos, selectedBallId, selectedPocket);
            if (combos.length > 0) {
              const bestCombo = combos[0];
              // In combo mode, always show combo if viable.
              // In auto mode, show combo only if kick and direct are blocked and combo is viable
              const directBlocked = currentKickPath !== null; // Kick path exists = direct is blocked
              const kickNotViable = currentKickPath && (!currentKickPath.viability || !currentKickPath.viability.viable);
              const shouldShowCombo = currentSolverMode === 'combo' ||
                (bestCombo.viable && directBlocked && kickNotViable);

              if (shouldShowCombo) {
                currentCombo = bestCombo;
                showingCombo = true;
              }
            }
          }

          // Hide combo indicator by default
          hideComboShot();

          // Determine if ALL lanes are blocked (no viable shot path exists)
          // A shot is viable if:
          // - Direct: cue can reach ghost (no kick needed) AND OB can reach pocket (not blocked)
          // - Kick: a viable kick path exists (handles cue-to-ghost blocking)
          // - Bank: a viable bank shot exists (OB bounces off rail to pocket)
          // - Combo: a viable combo exists (use another ball to pocket the target)
          const cueToGhostBlocked = currentKickPath !== null;  // If kick path exists, direct was blocked
          const kickViable = currentKickPath && currentKickPath.viability && currentKickPath.viability.viable;
          const bankViable = currentBankShot && currentBankShot.viability && currentBankShot.viability.viable;
          const comboViable = currentCombo && currentCombo.viable;
          const directViable = !cueToGhostBlocked && !obPathBlocked;  // Both paths must be clear

          // All lanes blocked if no viable option exists
          const hasViablePath = directViable || kickViable || bankViable || comboViable;
          const allLanesBlocked = !hasViablePath;

          // Update status banner
          if (allLanesBlocked && selectedBallId && selectedPocket) {
            statusMessage.textContent = 'All lanes blocked.';
            statusSuggestion.textContent = 'Jump shot?';
            statusBanner.classList.add('visible');
          } else {
            statusBanner.classList.remove('visible');
          }

          let objPathEnd;
          if (showingCombo && currentCombo) {
            // Combination shot path visualization
            drawComboShot(currentCombo);

            // For combo shots, the OB path is from target ball to pocket
            const targetBallPos = currentCombo.targetPos;
            const comboPocketPos = currentCombo.pocketPos;
            objPathEnd = comboPocketPos;

            // Draw the target ball path (separate from combo indicator paths)
            const obPathD = `M ${targetBallPos.x} ${targetBallPos.y} L ${comboPocketPos.x} ${comboPocketPos.y}`;
            objBallPath.setAttribute('d', obPathD);
            objBallPath.setAttribute('visibility', 'visible');

            // Update ghost ball to helper ghost position for aiming
            ghostBallIndicator.setAttribute('transform', `translate(${currentCombo.helperGhostPos.x}, ${currentCombo.helperGhostPos.y})`);
            ballPositions['ghost'] = currentCombo.helperGhostPos;

            // Also move the ghost ball element to match
            const ghostBallElCombo = document.getElementById('ball-ghost');
            if (ghostBallElCombo && ghostBallElCombo.classList.contains('on-table')) {
              positionBallOnTable(ghostBallElCombo, currentCombo.helperGhostPos.x, currentCombo.helperGhostPos.y);
            }

            // Combo shot - check if target would reach pocket
            obMadeIt = currentCombo.viable;

          } else if (showingBank && currentBankShot) {
            // Bank shot path: OB â†’ bank point â†’ pocket
            const idealBankPoint = currentBankShot.bankPoint;
            const actualBankPoint = currentBankShot.actualBankPoint || idealBankPoint;

            // Update ghost ball position for bank shot
            const bankGhostPos = currentBankShot.ghostPos;
            ghostBallIndicator.setAttribute('transform', `translate(${bankGhostPos.x}, ${bankGhostPos.y})`);
            ballPositions['ghost'] = bankGhostPos;  // Update stored position for cue line

            // Also move the ghost ball element to match
            const ghostBallEl = document.getElementById('ball-ghost');
            if (ghostBallEl && ghostBallEl.classList.contains('on-table')) {
              positionBallOnTable(ghostBallEl, bankGhostPos.x, bankGhostPos.y);
            }

            // Check if throw significantly affects the shot
            const throwError = vectorLength(vectorSubtract(actualBankPoint, idealBankPoint));
            const hasSignificantThrow = throwError > 0.3;  // ~0.3 SVG units threshold

            // Calculate where OB actually ends up after bank with throw
            // After hitting the actual bank point, OB reflects toward the pocket
            // but ends up slightly off due to the altered angle
            let actualPocketEndpoint = pocketPos;
            if (hasSignificantThrow) {
              // Calculate the reflected direction from actual bank point
              const obToActualBank = vectorNormalize(vectorSubtract(actualBankPoint, objBallPos));
              const railName = currentBankShot.bankRail;

              // Simple reflection off the rail at the actual bank point
              let reflectedDir;
              if (railName === 'top' || railName === 'bottom') {
                reflectedDir = { x: obToActualBank.x, y: -obToActualBank.y };
              } else {
                reflectedDir = { x: -obToActualBank.x, y: obToActualBank.y };
              }

              // Project to find where OB actually goes (same distance as ideal would travel)
              const idealBankToPocketDist = currentBankShot.bankToPocketDist;
              actualPocketEndpoint = vectorAdd(actualBankPoint, vectorScale(reflectedDir, idealBankToPocketDist));
            }

            // Draw OB path with bank bounce - show actual path with throw
            const obPathD = `M ${objBallPos.x} ${objBallPos.y} L ${actualBankPoint.x} ${actualBankPoint.y} L ${actualPocketEndpoint.x} ${actualPocketEndpoint.y}`;
            objBallPath.setAttribute('d', obPathD);
            objBallPath.setAttribute('visibility', 'visible');
            objPathEnd = actualPocketEndpoint;

            // Check if the actual path still reaches the pocket (within tolerance)
            const pocketMissDistance = vectorLength(vectorSubtract(actualPocketEndpoint, pocketPos));
            const pocketOpeningRadius = 2.5;
            obMadeIt = currentBankShot.viability.viable && pocketMissDistance < pocketOpeningRadius;

            // Show bank point indicator at the IDEAL point (where player should aim)
            bankPointIndicator.setAttribute('transform', `translate(${idealBankPoint.x}, ${idealBankPoint.y})`);

            // Position label based on rail
            const railName = currentBankShot.bankRail;
            let labelY = -1.3;
            if (railName === 'bottom') labelY = 1.6;
            bankPointLabel.setAttribute('y', labelY);

            // Update label to show throw info if significant
            let labelText = 'BANK';
            if (hasSignificantThrow && Math.abs(currentBankShot.throwAngle) > 0.5) {
              const throwDir = currentBankShot.throwAngle > 0 ? 'â†' : 'â†’';
              labelText += ` ${throwDir}`;  // Show throw direction
            }
            bankPointLabel.textContent = labelText;

            // Color based on viability (factoring in throw-induced miss)
            const bankDiamond = bankPointIndicator.querySelector('polygon');
            if (bankDiamond) {
              if (!obMadeIt) {
                bankDiamond.setAttribute('fill', '#ff4444');  // Red = miss (throw or power)
              } else if (currentBankShot.viability.difficulty === 'Hard') {
                bankDiamond.setAttribute('fill', '#ff8800');
              } else if (currentBankShot.viability.difficulty === 'Medium') {
                bankDiamond.setAttribute('fill', '#ffcc00');
              } else {
                bankDiamond.setAttribute('fill', '#44ff44');
              }
            }
            bankPointIndicator.setAttribute('visibility', 'visible');

          } else {
            // Direct shot path: OB â†’ pocket
            objPathEnd = vectorAdd(objBallPos, vectorScale(objToPocket, objPathLength));

            // If path is blocked, find where OB would stop (at the blocking ball)
            if (obPathBlocked && obBlockingBalls.length > 0) {
              // Find the closest blocking ball along the path
              let closestBlockDist = Infinity;
              let blockPoint = objPathEnd;
              for (const blockBallId of obBlockingBalls) {
                const blockBallPos = ballPositions[blockBallId];
                if (blockBallPos) {
                  const distToBlock = vectorLength(vectorSubtract(blockBallPos, objBallPos));
                  if (distToBlock < closestBlockDist) {
                    closestBlockDist = distToBlock;
                    // OB stops one ball diameter before hitting the blocking ball
                    const stopDist = Math.max(0, distToBlock - BALL_RADIUS * 2);
                    blockPoint = vectorAdd(objBallPos, vectorScale(objToPocket, stopDist));
                  }
                }
              }
              objPathEnd = blockPoint;
            }

            const obPathD = `M ${objBallPos.x} ${objBallPos.y} L ${objPathEnd.x} ${objPathEnd.y}`;
            objBallPath.setAttribute('d', obPathD);
            objBallPath.setAttribute('visibility', 'visible');

            // Change path style if blocked
            if (obPathBlocked) {
              objBallPath.setAttribute('stroke', '#ff4444');  // Red for blocked
              objBallPath.setAttribute('stroke-dasharray', '2,2');  // Dashed
            } else {
              objBallPath.setAttribute('stroke', '#ffaa00');  // Normal orange-yellow
              objBallPath.setAttribute('stroke-dasharray', 'none');
            }
          }

          // Show OB final position indicator
          if (obMadeIt) {
            // Ball made it to pocket - show at pocket center
            obFinalPosition.setAttribute('transform', `translate(${pocketPos.x}, ${pocketPos.y})`);
          } else {
            // Ball stopped before pocket - show at path end
            obFinalPosition.setAttribute('transform', `translate(${objPathEnd.x}, ${objPathEnd.y})`);
          }
          obFinalPosition.setAttribute('visibility', 'visible');

          // Cue ball path after contact (curved first segment + rail bounces)
          // Physics: CB retains sinÂ²(cutAngle) of energy
          if (cuePos) {
            const cbPath = calculateCueBallPath(ghostBallPosition, objToPocket, contactOffset, shotForce, cutAngle);
            if (cbPath) {
              // Build path string: bezier curve first, then straight segments
              let pathD;
              if (cbPath.hasCurve) {
                // Quadratic bezier for follow/draw curve effect
                pathD = `M ${cbPath.curveStart.x} ${cbPath.curveStart.y} Q ${cbPath.curveControl.x} ${cbPath.curveControl.y} ${cbPath.curveEnd.x} ${cbPath.curveEnd.y}`;
              } else {
                // Straight line for stun shot
                pathD = `M ${cbPath.curveStart.x} ${cbPath.curveStart.y} L ${cbPath.curveEnd.x} ${cbPath.curveEnd.y}`;
              }

              // Add straight segments for rail bounces
              cbPath.segments.forEach(seg => {
                pathD += ` L ${seg.end.x} ${seg.end.y}`;
              });

              cueBallPath.setAttribute('d', pathD);
              cueBallPath.setAttribute('visibility', 'visible');

              // Position final resting indicator at end of path
              let finalPos;
              if (cbPath.segments.length > 0) {
                finalPos = cbPath.segments[cbPath.segments.length - 1].end;
              } else {
                finalPos = cbPath.curveEnd;
              }
              cbFinalPosition.setAttribute('transform', `translate(${finalPos.x}, ${finalPos.y})`);
              cbFinalPosition.setAttribute('visibility', 'visible');
            } else {
              cueBallPath.setAttribute('visibility', 'hidden');
              cbFinalPosition.setAttribute('visibility', 'hidden');
            }
          } else {
            cueBallPath.setAttribute('visibility', 'hidden');
            cbFinalPosition.setAttribute('visibility', 'hidden');
          }

          // Update displays with cut angle (already calculated above)
          const overlap = calculateOverlap(cutAngle);
          const hitName = getBallHitName(cutAngle);

          cutAngleDisplay.textContent = cutAngle.toFixed(1) + 'Â°';
          overlapDisplay.textContent = `${hitName} (${(overlap * 100).toFixed(0)}%)`;

          // Update shooter's eye view overlap diagram
          updateOverlapDiagram(overlap);

          // Calculate minimum power needed based on distances
          const cueToGhostDist = cuePos ? vectorLength(vectorSubtract(ghostBallPosition, cuePos)) : 30;
          const obToPocketDist = vectorLength(vectorSubtract(pocketPos, objBallPos));
          const totalDist = cueToGhostDist + obToPocketDist;
          // Rough estimate: need ~1 power unit per 10 SVG units at 45Â° cut
          const cutFactor = Math.cos(cutAngle * Math.PI / 180);
          const minPowerNeeded = Math.ceil(Math.max(2, totalDist / (15 * cutFactor)));

          // Determine shot type for display
          const isKick = !!currentKickPath;
          const isBank = showingBank;
          const isCombo = showingCombo;

          // Determine aim instruction text
          let aimInstructionText = '';
          if (isKick) {
            const railName = currentKickPath.rails[0].charAt(0).toUpperCase() + currentKickPath.rails[0].slice(1);
            aimInstructionText = `${railName} rail kick point`;
          } else if (isBank) {
            const railName = currentBankShot.bankRail.charAt(0).toUpperCase() + currentBankShot.bankRail.slice(1);
            aimInstructionText = `Ghost ball (bank off ${railName})`;
          } else if (isCombo) {
            aimInstructionText = `Hit ${currentCombo.helperBallId}-ball into ${currentCombo.targetBallId}-ball`;
          } else {
            aimInstructionText = `Ghost ball (${hitName})`;
          }

          // Check for foul (illegal ball selection)
          const isLegalTarget = isBallLegalTarget(selectedBallId);
          const isFoul = selectedBallId && !isLegalTarget && currentGameMode.targetRule !== 'any';

          // Calculate difficulty level
          let difficultyScore = 0;
          if (cutAngle > 60) difficultyScore += 40;
          else if (cutAngle > 45) difficultyScore += 25;
          else if (cutAngle > 30) difficultyScore += 15;
          else difficultyScore += 5;
          if (totalDist > 80) difficultyScore += 25;
          else if (totalDist > 50) difficultyScore += 15;
          else difficultyScore += 5;
          if (isKick) difficultyScore += 20;
          if (isBank) difficultyScore += 15;
          if (isCombo) difficultyScore += 25;

          let difficultyLevel;
          if (difficultyScore <= 25) difficultyLevel = 'easy';
          else if (difficultyScore <= 45) difficultyLevel = 'medium';
          else if (difficultyScore <= 70) difficultyLevel = 'hard';
          else difficultyLevel = 'very-hard';

          // Build shot data for instructions panel
          const shotData = {
            isReady: true,
            cutAngle: cutAngle,
            ballHitFraction: hitName,
            totalDistance: totalDist,
            contactX: contactOffset.x,
            contactY: contactOffset.y,
            power: shotForce,
            minPowerNeeded: Math.min(10, minPowerNeeded),
            // Original property names (for updateShotInstructions)
            isKickShot: isKick,
            isBankShot: isBank,
            isComboShot: isCombo,
            // Alias property names (for updatePaletteDisplays)
            isKick: isKick,
            isBank: isBank,
            isCombo: isCombo,
            // Additional display properties
            difficulty: difficultyLevel,
            overlap: overlap,
            isFoul: isFoul,
            aimInstruction: aimInstructionText,
            kickRail: currentKickPath ? currentKickPath.rails[0] : null,
            bankRail: currentBankShot ? currentBankShot.bankRail : null,
            requiredEnglish: currentKickPath ? currentKickPath.requiredEnglish : 0,
            throwInfo: currentBankShot && Math.abs(currentBankShot.throwAngle || 0) > 0.5
              ? `Throw: ${currentBankShot.throwAngle > 0 ? 'left' : 'right'}` : '',
            // Combo shot info
            comboHelperBall: currentCombo ? currentCombo.helperBallId : null,
            comboTargetBall: currentCombo ? currentCombo.targetBallId : null,
            comboDifficulty: currentCombo ? currentCombo.difficulty : null,
            comboCutAngle1: currentCombo ? currentCombo.cutAngle1 : null,
            comboCutAngle2: currentCombo ? currentCombo.cutAngle2 : null,
            // Legal target ball info for game mode warnings
            selectedBallId: selectedBallId,
            isLegalTarget: isLegalTarget,
            legalTargetBalls: getLegalTargetBalls(),
            gameModeName: currentGameMode.name,
            targetRule: currentGameMode.targetRule,
            // Object ball path blocked info
            obPathBlocked: obPathBlocked && !showingBank && !showingCombo,  // Only relevant for direct shots
            obBlockingBalls: obBlockingBalls,
            allLanesBlocked: allLanesBlocked
          };
          updateShotInstructions(shotData);
        } else {
          targetLine.setAttribute('visibility', 'hidden');
          ghostBallIndicator.setAttribute('visibility', 'hidden');
          objBallPath.setAttribute('visibility', 'hidden');
          obFinalPosition.setAttribute('visibility', 'hidden');
          cueBallPath.setAttribute('visibility', 'hidden');
          cbFinalPosition.setAttribute('visibility', 'hidden');
          cutAngleDisplay.textContent = '--';
          overlapDisplay.textContent = '--';
          updateOverlapDiagram(0.5);  // Default to half-ball view
          updateShotInstructions(null);  // Clear instructions
          statusBanner.classList.remove('visible');  // Hide status banner
        }
      }

      // Select a ball (highlight it)
      function selectBall(ballId) {
        // Remove previous selection highlight
        if (selectedBallId) {
          const prevBall = document.getElementById(`ball-${selectedBallId}`);
          if (prevBall) prevBall.classList.remove('selected');
        }

        selectedBallId = ballId;

        // Add selection highlight
        if (selectedBallId) {
          const ball = document.getElementById(`ball-${selectedBallId}`);
          if (ball) ball.classList.add('selected');
        }

        updateShotGeometry();
      }

      // Select a pocket (highlight it)
      function selectPocket(pocketId) {
        // Remove previous pocket highlight
        document.querySelectorAll('.pocket-target').forEach(p => p.classList.remove('selected'));

        selectedPocket = pocketId;

        // Add highlight to selected pocket
        if (selectedPocket) {
          const pocket = document.querySelector(`.pocket-target[data-pocket="${selectedPocket}"]`);
          if (pocket) pocket.classList.add('selected');
        }

        // Auto-position ghost ball when pocket is selected
        autoPositionGhostBall();

        // Update aim line to point at new ghost ball position
        updateCueGhostLine();
      }

      // Auto-position the ghost ball (AIM) to the correct contact point
      // Places it exactly one ball diameter behind the object ball, along the pocket line
      // So ghost ball and object ball are just touching (not overlapping)
      function autoPositionGhostBall() {
        // Don't auto-position during break setup - ghost ball is manually positioned
        if (isBreakSetup) return;

        const objBallPos = selectedBallId ? ballPositions[selectedBallId] : null;
        const pocketPos = selectedPocket ? pocketCenters[selectedPocket] : null;

        // Need both object ball and pocket selected
        if (!objBallPos || !pocketPos) return;

        // Calculate ideal ghost ball position
        // Ghost ball center is offset from object ball with small visual buffer
        const objToPocket = vectorNormalize(vectorSubtract(pocketPos, objBallPos));
        const ghostBallX = objBallPos.x - objToPocket.x * GHOST_BALL_OFFSET;
        const ghostBallY = objBallPos.y - objToPocket.y * GHOST_BALL_OFFSET;

        // Check if position is on the playing surface
        if (!isOnPlayingSurface(ghostBallX, ghostBallY)) return;

        // Update ghost ball position
        ballPositions['ghost'] = { x: ghostBallX, y: ghostBallY };

        // Move the ghost ball element
        const ghostBall = document.getElementById('ball-ghost');
        if (ghostBall) {
          positionBallOnTable(ghostBall, ghostBallX, ghostBallY);
        }
      }

      // Setup pocket click handlers
      function setupPocketHandlers() {
        document.querySelectorAll('.pocket-target').forEach(pocket => {
          pocket.addEventListener('click', (e) => {
            e.stopPropagation();
            const pocketId = pocket.dataset.pocket;
            // Toggle selection
            if (selectedPocket === pocketId) {
              selectPocket(null);
            } else {
              selectPocket(pocketId);
            }
          });
        });
      }

      // Position ball element on table using SVG coordinates
      function positionBallOnTable(ball, svgX, svgY) {
        const wrapperRect = tableWrapper.getBoundingClientRect();
        const pagePos = svgToPage(svgX, svgY);

        // Use half of current ball size for centering offset
        const halfBall = ballSizePx / 2;

        ball.style.position = 'absolute';
        ball.style.left = (pagePos.x - wrapperRect.left - halfBall) + 'px';
        ball.style.top = (pagePos.y - wrapperRect.top - halfBall) + 'px';
        ball.classList.add('on-table');

        if (ball.parentElement !== tableWrapper) {
          tableWrapper.appendChild(ball);
        }
      }

      // Reposition all balls on table (call on resize)
      function repositionAllBalls() {
        Object.keys(ballPositions).forEach(ballId => {
          const pos = ballPositions[ballId];
          const ball = document.getElementById(`ball-${ballId}`);
          if (ball && pos) {
            positionBallOnTable(ball, pos.x, pos.y);
          }
        });
      }

      // Start drag (or prepare for potential drag)
      function startDrag(e) {
        // Ignore clicks on palette elements or other UI controls
        if (e.target.closest('.tool-palette') ||
          e.target.closest('.palette-restore-btn') ||
          e.target.closest('.tour-tooltip') ||
          e.target.closest('.status-banner')) {
          return;
        }

        const ball = e.target.closest('.ball');
        const clientX = e.clientX || (e.touches && e.touches[0].clientX);
        const clientY = e.clientY || (e.touches && e.touches[0].clientY);

        if (!ball) {
          // Clicked on empty space - check if we should move selected ball there
          if (selectedBallId && selectedBallId !== 'cue' && selectedBallId !== 'ghost') {
            const svgPos = pageToSvg(clientX, clientY);
            if (isOnPlayingSurface(svgPos.x, svgPos.y)) {
              // Move selected ball to clicked position
              const selectedBall = document.getElementById(`ball-${selectedBallId}`);
              if (selectedBall) {
                ballPositions[selectedBallId] = { x: svgPos.x, y: svgPos.y };
                positionBallOnTable(selectedBall, svgPos.x, svgPos.y);
                autoPositionGhostBall();
                updateCueGhostLine();
              }
            }
          }
          return;
        }

        e.preventDefault();
        draggedBall = ball;
        isDragging = false;  // Not dragging yet, just clicked
        dragStartTime = Date.now();

        const rect = ball.getBoundingClientRect();
        dragStartPos = { x: clientX, y: clientY };

        const halfBall = ballSizePx / 2;
        offsetX = clientX - rect.left - halfBall;
        offsetY = clientY - rect.top - halfBall;
      }

      // Actually begin the drag (called when threshold exceeded)
      function beginActualDrag() {
        if (!draggedBall || isDragging) return;

        isDragging = true;
        draggedBall.classList.add('dragging');

        // Move to table wrapper for dragging if from rack
        if (!draggedBall.classList.contains('on-table')) {
          const rect = draggedBall.getBoundingClientRect();
          const wrapperRect = tableWrapper.getBoundingClientRect();
          draggedBall.style.position = 'absolute';
          draggedBall.style.left = (rect.left - wrapperRect.left) + 'px';
          draggedBall.style.top = (rect.top - wrapperRect.top) + 'px';
          tableWrapper.appendChild(draggedBall);
        }
      }

      // During drag
      function doDrag(e) {
        if (!draggedBall) return;

        const clientX = e.clientX || (e.touches && e.touches[0].clientX);
        const clientY = e.clientY || (e.touches && e.touches[0].clientY);

        // Check if we should start actual dragging (threshold check)
        if (!isDragging && dragStartPos) {
          const dx = clientX - dragStartPos.x;
          const dy = clientY - dragStartPos.y;
          if (Math.sqrt(dx * dx + dy * dy) < DRAG_THRESHOLD) {
            return; // Haven't moved enough yet
          }
          beginActualDrag();
        }

        if (!isDragging) return;

        e.preventDefault();

        const wrapperRect = tableWrapper.getBoundingClientRect();
        const halfBall = ballSizePx / 2;
        const newLeft = clientX - wrapperRect.left - offsetX - halfBall;
        const newTop = clientY - wrapperRect.top - offsetY - halfBall;

        draggedBall.style.left = newLeft + 'px';
        draggedBall.style.top = newTop + 'px';

        // Update ball position and shot info in real-time during drag
        const ballId = draggedBall.dataset.ballId;
        const centerX = clientX - offsetX;
        const centerY = clientY - offsetY;
        const svgPos = pageToSvg(centerX, centerY);

        if (isOnPlayingSurface(svgPos.x, svgPos.y)) {
          ballPositions[ballId] = { x: svgPos.x, y: svgPos.y };
          // Auto-position ghost ball if dragging object ball or if dragging cue
          if (ballId === selectedBallId) {
            autoPositionGhostBall();
          }
          updateCueGhostLine();
        }
      }

      // End drag (or handle click if no drag occurred)
      function endDrag(e) {
        // Always capture the ball reference first, then clear state immediately
        // This prevents any possibility of state getting stuck
        const ball = draggedBall;
        const wasDragging = isDragging;
        const holdTime = dragStartTime ? Date.now() - dragStartTime : 0;

        // Clear state FIRST to prevent stuck state
        draggedBall = null;
        dragStartPos = null;
        dragStartTime = null;
        isDragging = false;

        if (!ball) return;

        const ballId = ball.dataset.ballId;

        // If it was just a click (not a drag):
        // - Long press (>400ms) = select the ball
        // - Short click = do nothing (use double-click to select)
        if (!wasDragging) {
          if (ballId !== 'cue' && ballId !== 'ghost' && holdTime >= LONG_PRESS_TIME) {
            selectBall(ballId);
          }
          // Short click does nothing - use double-click instead
          return;
        }

        // It was an actual drag - complete the drop
        ball.classList.remove('dragging');

        const rect = ball.getBoundingClientRect();
        const halfBall = ballSizePx / 2;
        const centerX = rect.left + halfBall;
        const centerY = rect.top + halfBall;

        const svgPos = pageToSvg(centerX, centerY);

        if (isOnPlayingSurface(svgPos.x, svgPos.y)) {
          // Place on table
          ballPositions[ballId] = { x: svgPos.x, y: svgPos.y };
          positionBallOnTable(ball, svgPos.x, svgPos.y);
          ball.classList.add('on-table');

          // Auto-select object balls when dropped (not cue or ghost)
          if (ballId !== 'cue' && ballId !== 'ghost') {
            selectBall(ballId);
            // Auto-position ghost ball when object ball is moved
            autoPositionGhostBall();
          }
        } else {
          // Return to rack
          delete ballPositions[ballId];
          ball.style.position = '';
          ball.style.left = '';
          ball.style.top = '';
          ball.classList.remove('on-table');
          ballRack.appendChild(ball);

          // Deselect if this ball was selected
          if (selectedBallId === ballId) {
            selectBall(null);
          }
        }

        updateCueGhostLine();
      }

      // Cancel drag completely (reset all state)
      function cancelDrag() {
        if (draggedBall) {
          draggedBall.classList.remove('dragging');
        }
        draggedBall = null;
        dragStartPos = null;
        isDragging = false;
      }

      // Double-click to select ball (alternative to long-press)
      function handleBallDoubleClick(e) {
        const ball = e.target.closest('.ball');
        if (!ball) return;

        const ballId = ball.dataset.ballId;
        if (ballId !== 'cue' && ballId !== 'ghost') {
          selectBall(ballId);
        }
      }

      // Event listeners
      document.addEventListener('mousedown', startDrag);
      document.addEventListener('mousemove', doDrag);
      document.addEventListener('mouseup', endDrag);
      document.addEventListener('dblclick', handleBallDoubleClick);
      // Safety: cancel drag if mouse leaves window
      document.addEventListener('mouseleave', cancelDrag);
      // Safety: cancel drag on blur (user switches tabs/windows)
      window.addEventListener('blur', cancelDrag);

      document.addEventListener('touchstart', startDrag, { passive: false });
      document.addEventListener('touchmove', doDrag, { passive: false });
      document.addEventListener('touchend', endDrag);
      document.addEventListener('touchcancel', cancelDrag);

      // Reposition on resize
      // On resize, update ball sizes and reposition all balls
      window.addEventListener('resize', () => {
        updateBallSizes();
        repositionAllBalls();
      });

      // Contact point drag handlers
      function getContactDiagramCoords(e) {
        const rect = contactDiagram.getBoundingClientRect();
        const viewBox = contactDiagram.viewBox.baseVal;
        const clientX = e.clientX || (e.touches && e.touches[0].clientX);
        const clientY = e.clientY || (e.touches && e.touches[0].clientY);

        const scaleX = viewBox.width / rect.width;
        const scaleY = viewBox.height / rect.height;

        return {
          x: (clientX - rect.left) * scaleX + viewBox.x,
          y: (clientY - rect.top) * scaleY + viewBox.y
        };
      }

      // Helper to clamp coords to safe zone and update contact point
      function setContactPosition(coords) {
        const maxRadius = 0.56;  // Half ball radius = safe zone
        const dist = Math.sqrt(coords.x * coords.x + coords.y * coords.y);

        if (dist > maxRadius) {
          // Clamp to max radius
          coords.x = (coords.x / dist) * maxRadius;
          coords.y = (coords.y / dist) * maxRadius;
        }

        contactOffset = { x: coords.x, y: coords.y };
        contactPoint.setAttribute('cx', coords.x);
        contactPoint.setAttribute('cy', coords.y);

        // Update spin type display
        updateSpinDisplay(getSpinType(contactOffset));

        // Update shot geometry
        updateShotGeometry();
      }

      function startContactDrag(e) {
        // Allow clicking anywhere on the diagram (not just the contact point)
        if (e.target === contactPoint || e.target.closest('#contact-diagram')) {
          e.preventDefault();
          isDraggingContact = true;

          // Snap contact point to clicked location immediately
          const coords = getContactDiagramCoords(e);
          setContactPosition(coords);
        }
      }

      function doContactDrag(e) {
        if (!isDraggingContact) return;
        e.preventDefault();

        const coords = getContactDiagramCoords(e);
        setContactPosition(coords);
      }

      function endContactDrag(e) {
        isDraggingContact = false;
      }

      // Double-click to reset contact point to center
      function resetContactPoint(e) {
        if (e.target === contactPoint || e.target.closest('#contact-diagram')) {
          contactOffset = { x: 0, y: 0 };
          contactPoint.setAttribute('cx', 0);
          contactPoint.setAttribute('cy', 0);
          updateSpinDisplay('Center');
          updateShotGeometry();
        }
      }

      // Contact point event listeners
      contactDiagram.addEventListener('mousedown', startContactDrag);
      document.addEventListener('mousemove', doContactDrag);
      document.addEventListener('mouseup', endContactDrag);
      contactDiagram.addEventListener('touchstart', startContactDrag, { passive: false });
      document.addEventListener('touchmove', doContactDrag, { passive: false });
      document.addEventListener('touchend', endContactDrag);
      contactDiagram.addEventListener('dblclick', resetContactPoint);

      // Force slider handler
      forceSlider.addEventListener('input', (e) => {
        shotForce = parseFloat(e.target.value);
        forceValueDisplay.textContent = shotForce;
        updateShotGeometry();
      });

      // Solver mode change handler
      solverRadios.forEach(radio => {
        radio.addEventListener('change', (e) => {
          currentSolverMode = e.target.value;
          updateCueGhostLine();  // Re-evaluate shot with new solver mode
        });
      });

      // Simple view toggle handler - hides CB path and other complexity
      simpleViewToggle.addEventListener('change', (e) => {
        isSimpleView = e.target.checked;
        // Update visibility of complex elements
        cueBallPath.style.opacity = isSimpleView ? '0' : '1';
        cbFinalPosition.style.opacity = isSimpleView ? '0' : '1';
        obFinalPosition.style.opacity = isSimpleView ? '0' : '1';
        actualKickPath.style.opacity = isSimpleView ? '0' : '1';
        // Make aim line more prominent in simple view
        cueGhostLine.setAttribute('stroke-width', isSimpleView ? '0.5' : '0.3');
        // Update target line opacity
        targetLine.style.opacity = isSimpleView ? '0.5' : '1';
      });

      // Game mode change handler
      gameModeSelect.addEventListener('change', (e) => {
        const modeId = e.target.value;
        // Find the matching game mode
        for (const key in GAME_MODES) {
          if (GAME_MODES[key].id === modeId) {
            currentGameMode = GAME_MODES[key];
            break;
          }
        }

        // Update description
        gameModeDescription.textContent = currentGameMode.description;

        // Show/hide suit selector for 8-ball
        suitSelector.style.display = currentGameMode.targetRule === 'suit' ? 'block' : 'none';

        // Show/hide pocket selector for One Pocket
        pocketSelector.style.display = currentGameMode.pocketRestriction ? 'block' : 'none';

        // Update visualizations
        updateCueGhostLine();
        highlightLegalBalls();

        // Highlight scoring pockets for One Pocket mode
        if (currentGameMode.pocketRestriction) {
          highlightScoringPockets();
        } else {
          // Reset pocket styles to default
          document.querySelectorAll('.pocket-target').forEach(pocket => {
            pocket.style.stroke = '';
            pocket.style.strokeWidth = '';
          });
        }
      });

      // Suit selector handler (for 8-ball)
      suitRadios.forEach(radio => {
        radio.addEventListener('change', (e) => {
          playerSuit = e.target.value;
          updateCueGhostLine();
          highlightLegalBalls();
        });
      });

      // Pocket selector handler (for One Pocket)
      pocketRadios.forEach(radio => {
        radio.addEventListener('change', (e) => {
          playerPocket = e.target.value;
          updateCueGhostLine();
          highlightScoringPockets();
        });
      });

      // Highlight legal target balls based on game rules
      function highlightLegalBalls() {
        const legalBalls = getLegalTargetBalls();

        // Update visual state of all balls on table
        for (const ballId in ballPositions) {
          if (ballId === 'cue' || ballId === 'ghost') continue;

          const ballElement = document.getElementById(`ball-${ballId}`);
          if (ballElement) {
            const isLegal = legalBalls.includes(ballId);
            ballElement.style.opacity = isLegal ? '1' : '0.5';
            ballElement.style.filter = isLegal ? 'none' : 'grayscale(50%)';
          }
        }
      }

      // Highlight scoring pockets for One Pocket
      function highlightScoringPockets() {
        if (!currentGameMode.pocketRestriction) return;

        document.querySelectorAll('.pocket-target').forEach(pocket => {
          // Use data-pocket attribute, not id (pocket elements use data-pocket)
          const pocketId = pocket.dataset.pocket;
          if (pocketId === playerPocket) {
            pocket.style.stroke = '#0fa';  // Player's pocket - green
            pocket.style.strokeWidth = '0.8';
            pocket.style.filter = 'drop-shadow(0 0 3px #0fa)';
          } else if (currentGameMode.scoringPockets.includes(pocketId)) {
            pocket.style.stroke = '#f44';  // Opponent's pocket - red
            pocket.style.strokeWidth = '0.8';
            pocket.style.filter = 'drop-shadow(0 0 3px #f44)';
          } else {
            pocket.style.stroke = '#666';  // Neutral pockets - gray
            pocket.style.strokeWidth = '0.3';
            pocket.style.filter = 'none';
          }
        });
      }

      // APPROACH ANGLE TEST: Tests per-rail cut angle calculation
      // Different rails give different approach angles to the ghost ball
      // The solver should pick the rail that best aligns with the pocket direction
      function setupDemoShot() {
        // Initial 8-ball rack setup - British style
        // Rack at foot spot, cue ball in kitchen, aiming at head ball

        const FOOT_SPOT = { x: 75, y: 25 };
        const BALL_D = BALL_RADIUS * 2;
        const ROW_SPACING = BALL_D * Math.sin(Math.PI / 3);

        // Generate British-style 8-ball rack
        const trianglePattern = [
          [0],                          // Row 0: 1 ball (apex)
          [-0.5, 0.5],                  // Row 1: 2 balls
          [-1, 0, 1],                   // Row 2: 3 balls (8 in center)
          [-1.5, -0.5, 0.5, 1.5],       // Row 3: 4 balls
          [-2, -1, 0, 1, 2]             // Row 4: 5 balls
        ];

        // British 8-ball rack rules:
        // - 8-ball in center (row 2, position 1)
        // - Solid on one back corner, stripe on other back corner
        // - Alternating pattern for visual appeal
        const solids = ['1', '2', '3', '4', '5', '6', '7'];
        const stripes = ['9', '10', '11', '12', '13', '14', '15'];

        // Define specific positions for proper rack
        const rackLayout = [
          '1',          // Row 0: apex (1-ball)
          '9', '2',     // Row 1: stripe, solid
          '3', '8', '10', // Row 2: solid, 8-ball, stripe
          '11', '4', '5', '12', // Row 3: stripe, solid, solid, stripe
          '6', '13', '7', '14', '15'  // Row 4: solid, stripe, solid, stripe, stripe
        ];

        // Calculate positions
        const rackPositions = {};
        let layoutIndex = 0;
        for (let row = 0; row < trianglePattern.length; row++) {
          for (let col = 0; col < trianglePattern[row].length; col++) {
            const x = FOOT_SPOT.x + row * ROW_SPACING;
            const y = FOOT_SPOT.y + trianglePattern[row][col] * BALL_D;
            const ballId = rackLayout[layoutIndex++];
            rackPositions[ballId] = { x, y };
          }
        }

        // Place racked balls on table
        for (const ballId in rackPositions) {
          ballPositions[ballId] = rackPositions[ballId];
          const ball = document.getElementById(`ball-${ballId}`);
          if (ball) {
            positionBallOnTable(ball, rackPositions[ballId].x, rackPositions[ballId].y);
            ball.style.display = '';
          }
        }

        // Place cue ball in kitchen break area (behind head string, center-ish)
        const cueBallX = 20;  // Behind second diamond
        const cueBallY = 25;  // Center of table
        ballPositions['cue'] = { x: cueBallX, y: cueBallY };
        const cueBall = document.getElementById('ball-cue');
        if (cueBall) {
          positionBallOnTable(cueBall, cueBallX, cueBallY);
          cueBall.style.display = '';
        }

        // Calculate ghost ball position for aiming at head ball (1-ball at apex)
        const headBallPos = rackPositions['1'];
        const ghostBallX = headBallPos.x - BALL_D - 0.1;  // Just in front of head ball
        const ghostBallY = headBallPos.y;
        ballPositions['ghost'] = { x: ghostBallX, y: ghostBallY };

        // Don't select a ball initially - leave them all in the rack/tray
        selectedBallId = null;
        selectedPocket = null;

        // Set top spin (12 o'clock / follow) - already set as default
        contactPoint.setAttribute('cx', contactOffset.x);
        contactPoint.setAttribute('cy', contactOffset.y);
        updateSpinDisplay(getSpinType(contactOffset));

        // Set medium-high force for break
        shotForce = 7;
        forceSlider.value = shotForce;
        forceValueDisplay.textContent = shotForce;

        // Update all visualizations
        updateCueGhostLine();

        // Highlight legal balls based on game mode
        highlightLegalBalls();
      }

      // Initialize
      updateBallSizes();  // Calculate ball size based on current SVG scale
      createBalls();
      setupPocketHandlers();

      // Set up initial 8-ball rack (skip if ?empty=1 for testing)
      setTimeout(() => {
        const urlParams = new URLSearchParams(window.location.search);
        if (!urlParams.has('empty')) {
          randomRack();  // Use the simplified rack function
        }
      }, 100);

      // ============================================
      // FLOATING PALETTE MANAGEMENT
      // ============================================

      // Palette elements
      const palettes = {
        balls: document.getElementById('palette-balls'),
        cue: document.getElementById('palette-cue'),
        legend: document.getElementById('palette-legend'),
        game: document.getElementById('palette-game'),
        shot: document.getElementById('palette-shot'),
        actions: document.getElementById('palette-actions'),
        save: document.getElementById('palette-save'),
        aids: document.getElementById('palette-aids')
      };

      const restoreButtons = {
        balls: document.getElementById('restore-balls'),
        cue: document.getElementById('restore-cue'),
        legend: document.getElementById('restore-legend'),
        game: document.getElementById('restore-game'),
        shot: document.getElementById('restore-shot'),
        actions: null,  // No restore button for actions palette
        save: null,     // No restore button for save palette
        aids: null      // No restore button for aids palette
      };

      // Balls are now created directly in palette by createBalls()
      function createPaletteBalls() {
        // No longer needed - balls created directly in palette
      }

      // Palette minimize/close handlers
      function setupPaletteControls() {
        Object.keys(palettes).forEach(key => {
          const palette = palettes[key];
          const restoreBtn = restoreButtons[key];

          if (!palette) return;

          const minimizeBtn = palette.querySelector('.palette-btn.minimize');
          const closeBtn = palette.querySelector('.palette-btn.close');

          // Minimize toggle - button click
          if (minimizeBtn) {
            minimizeBtn.addEventListener('click', (e) => {
              e.stopPropagation();
              palette.classList.toggle('minimized');
              minimizeBtn.textContent = palette.classList.contains('minimized') ? '+' : 'âˆ’';
            });
          }

          // Click on header/title toggles minimize (no more dragging)
          const header = palette.querySelector('.palette-header');
          if (header) {
            header.style.cursor = 'pointer';
            header.addEventListener('click', (e) => {
              // Don't toggle if clicking the minimize button itself
              if (e.target.closest('.palette-btn')) return;
              e.stopPropagation();
              palette.classList.toggle('minimized');
              if (minimizeBtn) {
                minimizeBtn.textContent = palette.classList.contains('minimized') ? '+' : 'âˆ’';
              }
            });
          }

          // Also allow clicking entire minimized panel to expand
          palette.addEventListener('click', (e) => {
            if (palette.classList.contains('minimized')) {
              // Only respond if clicking on the minimized panel itself
              if (e.target.closest('.palette-btn')) return;
              e.stopPropagation();
              palette.classList.remove('minimized');
              if (minimizeBtn) {
                minimizeBtn.textContent = 'âˆ’';
              }
            }
          });

          // Close (hide) palette
          if (closeBtn) {
            closeBtn.addEventListener('click', (e) => {
              e.stopPropagation();
              palette.classList.add('hidden');
              if (restoreBtn) restoreBtn.classList.add('visible');
            });
          }

          // Restore button
          if (restoreBtn) {
            restoreBtn.addEventListener('click', () => {
              palette.classList.remove('hidden');
              restoreBtn.classList.remove('visible');
            });
          }
        });
      }

      // Palette dragging removed - click header to minimize instead
      function setupPaletteDragging() {
        // Dragging disabled - palettes now minimize on header click
        // Keeping function stub for compatibility
      }

      // Sync palette controls with original controls
      function setupPaletteSync() {
        // Force slider sync
        const forcePalette = document.getElementById('forceSlider-palette');
        const forceValuePalette = document.getElementById('forceValue-palette');

        if (forcePalette) {
          forcePalette.value = forceSlider.value;
          forcePalette.addEventListener('input', (e) => {
            shotForce = parseFloat(e.target.value);
            forceSlider.value = e.target.value;
            forceValueDisplay.textContent = shotForce;
            if (forceValuePalette) forceValuePalette.textContent = shotForce;
            updateShotGeometry();
          });
        }

        // Sync original slider to palette
        forceSlider.addEventListener('input', () => {
          if (forcePalette) forcePalette.value = forceSlider.value;
          if (forceValuePalette) forceValuePalette.textContent = forceSlider.value;
        });

        // Game mode sync
        const gamePalette = document.getElementById('gameModeSelect-palette');
        const gameDescPalette = document.getElementById('gameModeDescription-palette');
        const suitPalette = document.getElementById('suitSelector-palette');
        const pocketPalette = document.getElementById('pocketSelector-palette');

        if (gamePalette) {
          gamePalette.value = gameModeSelect.value;
          gamePalette.addEventListener('change', (e) => {
            gameModeSelect.value = e.target.value;
            gameModeSelect.dispatchEvent(new Event('change'));
            // Update palette-specific elements
            const mode = GAME_MODES[Object.keys(GAME_MODES).find(k => GAME_MODES[k].id === e.target.value)];
            if (mode && gameDescPalette) {
              gameDescPalette.textContent = mode.description.split('.')[0];
            }
            if (suitPalette) suitPalette.style.display = e.target.value === '8ball' ? 'block' : 'none';
            if (pocketPalette) pocketPalette.style.display = e.target.value === '1pocket' ? 'block' : 'none';
          });
        }

        // Solver mode sync
        const solverPaletteRadios = document.querySelectorAll('input[name="solver-mode-palette"]');
        solverPaletteRadios.forEach(radio => {
          radio.addEventListener('change', (e) => {
            const originalRadio = document.querySelector(`input[name="solver-mode"][value="${e.target.value}"]`);
            if (originalRadio) {
              originalRadio.checked = true;
              originalRadio.dispatchEvent(new Event('change'));
            }
          });
        });

        // Sync original solver to palette
        solverRadios.forEach(radio => {
          radio.addEventListener('change', (e) => {
            const paletteRadio = document.querySelector(`input[name="solver-mode-palette"][value="${e.target.value}"]`);
            if (paletteRadio) paletteRadio.checked = true;
          });
        });
      }

      // Update palette displays when shot geometry changes
      // Note: Uses querySelector with #palette-shot prefix to avoid duplicate ID issues
      function updatePaletteDisplays(shotData) {
        const shotPalette = document.getElementById('palette-shot');
        if (!shotPalette) return;

        // Cut angle
        const cutPalette = shotPalette.querySelector('#cutAngleDisplay-palette');
        if (cutPalette && shotData) {
          cutPalette.textContent = shotData.cutAngle !== undefined ? shotData.cutAngle.toFixed(1) + 'Â°' : '--';
        }

        // Shot type
        const typePalette = shotPalette.querySelector('#shotTypeDisplay-palette');
        if (typePalette && shotData) {
          let typeText = 'Direct';
          if (shotData.isCombo) typeText = 'Combo';
          else if (shotData.isBank) typeText = 'Bank';
          else if (shotData.isKick) typeText = 'Kick';
          typePalette.textContent = typeText;
        }

        // Difficulty
        const diffFillPalette = shotPalette.querySelector('#difficultyFill-palette');
        const diffTextPalette = shotPalette.querySelector('#difficultyText-palette');
        if (diffFillPalette && diffTextPalette && shotData && shotData.difficulty) {
          diffFillPalette.className = 'difficulty-fill ' + shotData.difficulty;
          diffTextPalette.className = 'difficulty-text ' + shotData.difficulty;
          diffTextPalette.textContent = shotData.difficulty.replace('-', ' ').replace(/\b\w/g, l => l.toUpperCase());
        }

        // Overlap displays
        const overlapEnglishP = shotPalette.querySelector('#overlapEnglish-palette');
        const overlapSlashP = shotPalette.querySelector('#overlapSlash-palette');
        const overlapGhostP = shotPalette.querySelector('#overlap-ghost-ball-palette');
        const overlapRegionP = shotPalette.querySelector('#overlap-region-palette');

        if (shotData && shotData.overlap !== undefined) {
          const overlap = shotData.overlap;
          const fractionInfo = getOverlapFraction(overlap);

          if (overlapEnglishP) overlapEnglishP.textContent = fractionInfo.english;
          if (overlapSlashP) overlapSlashP.textContent = fractionInfo.slash;

          // Update ghost ball position in palette diagram
          const ghostX = -0.5 - (1 - overlap) * 2;
          if (overlapGhostP) overlapGhostP.setAttribute('cx', ghostX);
          if (overlapRegionP) overlapRegionP.setAttribute('cx', ghostX);
        }

        // Mini instructions
        const miniInst = shotPalette.querySelector('#shotMiniInstructions');
        if (miniInst && shotData) {
          if (shotData.isFoul) {
            miniInst.innerHTML = '<span style="color:#f66">âš  FOUL - Hit wrong ball</span>';
          } else if (shotData.aimInstruction) {
            miniInst.textContent = shotData.aimInstruction;
          } else {
            miniInst.textContent = 'Place balls and select a pocket';
          }
        }
      }

      // Hook into existing updateShotInstructions
      const originalUpdateShotInstructions = updateShotInstructions;
      updateShotInstructions = function (shotData) {
        originalUpdateShotInstructions(shotData);
        updatePaletteDisplays(shotData);
      };

      // Initialize palettes
      setTimeout(() => {
        createPaletteBalls();
        setupPaletteControls();
        setupPaletteDragging();
        setupPaletteSync();
        setupSharePalette();
        loadStateFromURL();
      }, 150);

      // ========== SHARE/EXPORT FUNCTIONALITY ==========

      // Toast notification
      function showToast(message, duration = 2000) {
        const toast = document.getElementById('toastNotification');
        toast.textContent = message;
        toast.classList.add('show');
        setTimeout(() => toast.classList.remove('show'), duration);
      }

      // Capture current state for URL encoding
      function captureState() {
        const state = {
          v: 1,
          balls: {},
          pocket: selectedPocket || '',
          ball: selectedBallId || '',
          mode: currentGameMode.id,
          power: shotForce,
          english: { x: contactOffset.x, y: contactOffset.y },
          solver: currentSolverMode
        };

        // Only include balls that are on the table
        for (const [id, pos] of Object.entries(ballPositions)) {
          if (pos && isOnPlayingSurface(pos.x, pos.y)) {
            state.balls[id] = { x: Math.round(pos.x * 10) / 10, y: Math.round(pos.y * 10) / 10 };
          }
        }

        return state;
      }

      // Encode state to compact URL string
      function encodeState(state) {
        const parts = [`v${state.v}`];

        // Encode balls: id:x,y
        for (const [id, pos] of Object.entries(state.balls)) {
          parts.push(`${id}:${pos.x.toFixed(1)},${pos.y.toFixed(1)}`);
        }

        // Encode settings
        if (state.pocket) parts.push(`p:${state.pocket.replace('corner-', 'c').replace('side-', 's')}`);
        if (state.ball) parts.push(`b:${state.ball}`);
        parts.push(`m:${state.mode}`);
        parts.push(`f:${state.power}`);
        parts.push(`e:${state.english.x.toFixed(1)},${state.english.y.toFixed(1)}`);
        parts.push(`s:${state.solver}`);

        return parts.join('|');
      }

      // Decode URL string to state
      function decodeState(encoded) {
        const state = { balls: {}, english: { x: 0, y: 0 } };
        const parts = encoded.split('|');

        for (const part of parts) {
          if (part.startsWith('v')) {
            state.v = parseInt(part.slice(1));
          } else if (part.startsWith('p:')) {
            const pocketCode = part.slice(2);
            state.pocket = pocketCode
              .replace(/^c/, 'corner-')
              .replace(/^s/, 'side-');
          } else if (part.startsWith('b:')) {
            state.ball = part.slice(2);
          } else if (part.startsWith('m:')) {
            state.mode = part.slice(2);
          } else if (part.startsWith('f:')) {
            state.power = parseFloat(part.slice(2));
          } else if (part.startsWith('e:')) {
            const [ex, ey] = part.slice(2).split(',').map(parseFloat);
            state.english = { x: ex, y: ey };
          } else if (part.startsWith('s:')) {
            state.solver = part.slice(2);
          } else if (part.includes(':')) {
            // Ball position
            const [id, coords] = part.split(':');
            const [x, y] = coords.split(',').map(parseFloat);
            state.balls[id] = { x, y };
          }
        }

        return state;
      }

      // Apply state to diagram
      function applyState(state) {
        // Set game mode
        if (state.mode) {
          const modeKey = Object.keys(GAME_MODES).find(k => GAME_MODES[k].id === state.mode);
          if (modeKey) {
            currentGameMode = GAME_MODES[modeKey];
            gameModeSelect.value = state.mode;
            const gamePalette = document.getElementById('gameModeSelect-palette');
            if (gamePalette) gamePalette.value = state.mode;
          }
        }

        // Set ball positions
        for (const [id, pos] of Object.entries(state.balls)) {
          ballPositions[id] = pos;
          const ball = document.getElementById(`ball-${id}`);
          if (ball) {
            positionBallOnTable(ball, pos.x, pos.y);
          }
        }

        // Set selections
        if (state.ball) selectBall(state.ball);
        if (state.pocket) selectPocket(state.pocket);

        // Set power
        if (state.power) {
          shotForce = state.power;
          forceSlider.value = state.power;
          forceValueDisplay.textContent = state.power;
          const forcePalette = document.getElementById('forceSlider-palette');
          const forceValuePalette = document.getElementById('forceValue-palette');
          if (forcePalette) forcePalette.value = state.power;
          if (forceValuePalette) forceValuePalette.textContent = state.power;
        }

        // Set english
        if (state.english) {
          contactOffset = { x: state.english.x, y: state.english.y };
          contactPoint.setAttribute('cx', contactOffset.x);
          contactPoint.setAttribute('cy', contactOffset.y);
          updateSpinDisplay(getSpinType(contactOffset));
        }

        // Set solver mode
        if (state.solver) {
          currentSolverMode = state.solver;
          const radio = document.querySelector(`input[name="solver-mode"][value="${state.solver}"]`);
          if (radio) radio.checked = true;
          const paletteRadio = document.querySelector(`input[name="solver-mode-palette"][value="${state.solver}"]`);
          if (paletteRadio) paletteRadio.checked = true;
        }

        updateCueGhostLine();
      }

      // Load state from URL on page load
      function loadStateFromURL() {
        const hash = window.location.hash.slice(1);
        if (hash && hash.startsWith('v')) {
          try {
            const state = decodeState(hash);
            applyState(state);
          } catch (e) {
            console.error('Failed to load state from URL:', e);
          }
        }
      }

      // Update URL with current state (debounced)
      let urlUpdateTimeout;
      function updateURL() {
        clearTimeout(urlUpdateTimeout);
        urlUpdateTimeout = setTimeout(() => {
          const state = captureState();
          const encoded = encodeState(state);
          history.replaceState(null, '', '#' + encoded);
        }, 500);
      }

      // Copy link to clipboard
      function copyShareLink() {
        const state = captureState();
        const encoded = encodeState(state);
        const url = window.location.origin + window.location.pathname + '#' + encoded;

        navigator.clipboard.writeText(url).then(() => {
          showToast('Link copied to clipboard!');
        }).catch(() => {
          // Fallback for older browsers
          const textarea = document.createElement('textarea');
          textarea.value = url;
          document.body.appendChild(textarea);
          textarea.select();
          document.execCommand('copy');
          document.body.removeChild(textarea);
          showToast('Link copied to clipboard!');
        });
      }

      // Ball colors for SVG export (simplified solid colors)
      const BALL_EXPORT_COLORS = {
        'cue': { fill: '#f0f0f0', stroke: '#999', textFill: '#666' },
        'ghost': { fill: 'none', stroke: '#fff', strokeDash: '0.3,0.2', textFill: 'rgba(255,255,255,0.8)' },
        '1': { fill: '#ffd700', stroke: '#c9a600', textFill: '#000' },
        '2': { fill: '#0066cc', stroke: '#004c99', textFill: '#fff' },
        '3': { fill: '#ff4444', stroke: '#cc0000', textFill: '#fff' },
        '4': { fill: '#6b2d8b', stroke: '#4a1f61', textFill: '#fff' },
        '5': { fill: '#ff6600', stroke: '#cc5200', textFill: '#fff' },
        '6': { fill: '#006633', stroke: '#004422', textFill: '#fff' },
        '7': { fill: '#8b0000', stroke: '#5c0000', textFill: '#fff' },
        '8': { fill: '#111', stroke: '#000', textFill: '#fff' },
        '9': { fill: '#ffd700', stroke: '#c9a600', textFill: '#000', stripe: true },
        '10': { fill: '#0066cc', stroke: '#004c99', textFill: '#fff', stripe: true },
        '11': { fill: '#ff4444', stroke: '#cc0000', textFill: '#fff', stripe: true },
        '12': { fill: '#6b2d8b', stroke: '#4a1f61', textFill: '#fff', stripe: true },
        '13': { fill: '#ff6600', stroke: '#cc5200', textFill: '#fff', stripe: true },
        '14': { fill: '#006633', stroke: '#004422', textFill: '#fff', stripe: true },
        '15': { fill: '#8b0000', stroke: '#5c0000', textFill: '#fff', stripe: true },
        'gray': { fill: '#777', stroke: '#555', textFill: '#fff' }
      };

      // Create a composite SVG for export with all visible elements
      function createExportSVG() {
        const tableSvg = document.getElementById('pool-table-svg');
        const overlay = document.getElementById('connection-overlay');

        // Extended viewBox to include info panels below table
        // Original: -8 -8 116 66, now add 22 units below for panels
        const exportSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        exportSvg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
        exportSvg.setAttribute('viewBox', '-8 -8 116 88');

        // Add background (extended for panels)
        const bg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        bg.setAttribute('x', '-8');
        bg.setAttribute('y', '-8');
        bg.setAttribute('width', '116');
        bg.setAttribute('height', '88');
        bg.setAttribute('fill', '#1a1a2e');
        exportSvg.appendChild(bg);

        // Clone and add table SVG content (excluding defs, we'll handle those)
        const tableClone = tableSvg.cloneNode(true);
        // Copy defs
        const tableDefs = tableClone.querySelector('defs');
        if (tableDefs) {
          exportSvg.appendChild(tableDefs.cloneNode(true));
        }
        // Copy all other children
        Array.from(tableClone.children).forEach(child => {
          if (child.tagName !== 'defs' && child.tagName !== 'title') {
            exportSvg.appendChild(child.cloneNode(true));
          }
        });

        // Clone overlay defs (gradients for cue stick)
        const overlayDefs = overlay.querySelector('defs');
        if (overlayDefs) {
          const existingDefs = exportSvg.querySelector('defs');
          if (existingDefs) {
            Array.from(overlayDefs.children).forEach(child => {
              existingDefs.appendChild(child.cloneNode(true));
            });
          }
        }

        // Add visible overlay elements (skip pocket-targets and hidden items)
        const overlayGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        overlayGroup.setAttribute('id', 'shot-overlay');

        Array.from(overlay.children).forEach(child => {
          // Skip defs and pocket targets
          if (child.tagName === 'defs') return;
          if (child.id === 'pocket-targets') return;
          if (child.classList && child.classList.contains('pocket-target')) return;

          // Only include visible elements
          const visibility = child.getAttribute('visibility');
          const display = child.style.display;
          if (visibility === 'hidden' || display === 'none') return;

          // Clone the element
          const clone = child.cloneNode(true);
          overlayGroup.appendChild(clone);
        });

        exportSvg.appendChild(overlayGroup);

        // Add balls as SVG circles
        const ballsGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        ballsGroup.setAttribute('id', 'balls');

        // Ball radius in SVG units
        const BALL_RADIUS = 1.125;

        Object.entries(ballPositions).forEach(([ballId, pos]) => {
          if (!pos) return;

          const colors = BALL_EXPORT_COLORS[ballId] || BALL_EXPORT_COLORS['gray'];
          const ballGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
          ballGroup.setAttribute('transform', `translate(${pos.x}, ${pos.y})`);

          // For striped balls, draw stripe pattern
          if (colors.stripe) {
            // Bottom half of ball color
            const bottomHalf = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            bottomHalf.setAttribute('r', BALL_RADIUS);
            bottomHalf.setAttribute('fill', colors.fill);
            bottomHalf.setAttribute('stroke', colors.stroke);
            bottomHalf.setAttribute('stroke-width', '0.1');
            ballGroup.appendChild(bottomHalf);

            // White stripe band in middle
            const stripe = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            stripe.setAttribute('x', -BALL_RADIUS);
            stripe.setAttribute('y', -BALL_RADIUS * 0.4);
            stripe.setAttribute('width', BALL_RADIUS * 2);
            stripe.setAttribute('height', BALL_RADIUS * 0.8);
            stripe.setAttribute('fill', '#fff');
            // Clip to circle
            const clipId = `clip-ball-${ballId}`;
            const clipPath = document.createElementNS('http://www.w3.org/2000/svg', 'clipPath');
            clipPath.setAttribute('id', clipId);
            const clipCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            clipCircle.setAttribute('r', BALL_RADIUS);
            clipPath.appendChild(clipCircle);
            ballGroup.appendChild(clipPath);
            stripe.setAttribute('clip-path', `url(#${clipId})`);
            ballGroup.appendChild(stripe);
          } else if (ballId === 'ghost') {
            // Ghost ball - dashed outline
            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('r', BALL_RADIUS);
            circle.setAttribute('fill', 'none');
            circle.setAttribute('stroke', colors.stroke);
            circle.setAttribute('stroke-width', '0.15');
            circle.setAttribute('stroke-dasharray', colors.strokeDash || '');
            circle.setAttribute('opacity', '0.7');
            ballGroup.appendChild(circle);
          } else {
            // Solid balls and cue ball
            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('r', BALL_RADIUS);
            circle.setAttribute('fill', colors.fill);
            circle.setAttribute('stroke', colors.stroke);
            circle.setAttribute('stroke-width', '0.1');
            ballGroup.appendChild(circle);

            // For numbered solid balls, add white center circle
            if (!isNaN(parseInt(ballId)) && parseInt(ballId) <= 8) {
              const centerCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
              centerCircle.setAttribute('r', BALL_RADIUS * 0.45);
              centerCircle.setAttribute('fill', '#fff');
              ballGroup.appendChild(centerCircle);
            }
          }

          // Add label text
          const label = balls.find(b => b.id === ballId)?.label || ballId;
          const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
          text.setAttribute('x', '0');
          text.setAttribute('y', '0.35');
          text.setAttribute('text-anchor', 'middle');
          text.setAttribute('font-size', ballId === 'cue' || ballId === 'ghost' || ballId === 'gray' ? '0.7' : '0.9');
          text.setAttribute('font-family', 'Arial, sans-serif');
          text.setAttribute('font-weight', 'bold');
          text.setAttribute('fill', colors.textFill);
          text.textContent = label;
          ballGroup.appendChild(text);

          ballsGroup.appendChild(ballGroup);
        });

        exportSvg.appendChild(ballsGroup);

        // ========== ADD INFO PANELS BELOW TABLE ==========
        const panelY = 60;  // Start panels below the table
        const panelHeight = 18;
        const panelPadding = 1.5;

        // Panel background
        const panelBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        panelBg.setAttribute('x', '-6');
        panelBg.setAttribute('y', panelY);
        panelBg.setAttribute('width', '112');
        panelBg.setAttribute('height', panelHeight);
        panelBg.setAttribute('fill', '#0d1520');
        panelBg.setAttribute('rx', '2');
        exportSvg.appendChild(panelBg);

        // Create three panel sections
        const sectionWidth = 35;

        // Helper to create text elements
        function addText(parent, x, y, text, options = {}) {
          const el = document.createElementNS('http://www.w3.org/2000/svg', 'text');
          el.setAttribute('x', x);
          el.setAttribute('y', y);
          el.setAttribute('font-family', 'Arial, sans-serif');
          el.setAttribute('font-size', options.size || '2');
          el.setAttribute('fill', options.fill || '#fff');
          if (options.weight) el.setAttribute('font-weight', options.weight);
          if (options.anchor) el.setAttribute('text-anchor', options.anchor);
          el.textContent = text;
          parent.appendChild(el);
          return el;
        }

        // Helper to draw a line sample for legend
        function addLineSample(parent, x, y, color, dasharray, label) {
          const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
          line.setAttribute('x1', x);
          line.setAttribute('y1', y);
          line.setAttribute('x2', x + 4);
          line.setAttribute('y2', y);
          line.setAttribute('stroke', color);
          line.setAttribute('stroke-width', '0.5');
          if (dasharray) line.setAttribute('stroke-dasharray', dasharray);
          parent.appendChild(line);
          addText(parent, x + 5.5, y + 0.5, label, { size: '1.6', fill: '#aaa' });
        }

        // ===== PANEL 1: CUE CONTROL =====
        const panel1X = -4;
        const panel1 = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        panel1.setAttribute('id', 'export-cue-control');

        addText(panel1, panel1X, panelY + 3, 'CUE CONTROL', { size: '2.2', fill: '#0fa', weight: 'bold' });

        // English position
        const engX = contactOffset.x;
        const engY = contactOffset.y;
        let engDesc = 'Center';
        if (Math.abs(engX) > 0.1 || Math.abs(engY) > 0.1) {
          const parts = [];
          if (engY < -0.15) parts.push('Follow');
          else if (engY > 0.15) parts.push('Draw');
          if (engX < -0.15) parts.push('Left');
          else if (engX > 0.15) parts.push('Right');
          engDesc = parts.length > 0 ? parts.join(' + ') : 'Center';
        }
        addText(panel1, panel1X, panelY + 6, 'English:', { size: '1.8', fill: '#888' });
        addText(panel1, panel1X + 10, panelY + 6, engDesc, { size: '1.8', fill: '#fff' });

        // Power
        addText(panel1, panel1X, panelY + 9, 'Power:', { size: '1.8', fill: '#888' });
        addText(panel1, panel1X + 10, panelY + 9, `${shotForce}/10`, { size: '1.8', fill: '#fff' });

        // Draw mini cue ball with contact point
        const miniCueX = panel1X + 25;
        const miniCueY = panelY + 9;
        const miniR = 4;
        const miniCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        miniCircle.setAttribute('cx', miniCueX);
        miniCircle.setAttribute('cy', miniCueY);
        miniCircle.setAttribute('r', miniR);
        miniCircle.setAttribute('fill', '#e8e8e8');
        miniCircle.setAttribute('stroke', '#666');
        miniCircle.setAttribute('stroke-width', '0.2');
        panel1.appendChild(miniCircle);

        // Contact point on mini cue ball (scaled from -0.56 to 0.56 range)
        const contactDotX = miniCueX + (engX / 0.56) * (miniR * 0.9);
        const contactDotY = miniCueY + (engY / 0.56) * (miniR * 0.9);
        const contactDot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        contactDot.setAttribute('cx', contactDotX);
        contactDot.setAttribute('cy', contactDotY);
        contactDot.setAttribute('r', '0.8');
        contactDot.setAttribute('fill', '#0066cc');
        panel1.appendChild(contactDot);

        exportSvg.appendChild(panel1);

        // ===== PANEL 2: SHOT INFO =====
        const panel2X = 33;
        const panel2 = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        panel2.setAttribute('id', 'export-shot-info');

        addText(panel2, panel2X, panelY + 3, 'SHOT INFO', { size: '2.2', fill: '#0fa', weight: 'bold' });

        // Get current shot info from display elements
        const cutAngleText = cutAngleDisplay?.textContent || '--';
        const overlapText = overlapDisplay?.textContent || '--';
        const overlapPercentText = document.getElementById('overlapPercent')?.textContent || '50%';
        const overlapEnglishText = document.getElementById('overlapEnglish')?.textContent || 'Half ball';
        const diffText = difficultyText?.textContent || '--';
        const verdictText = shotVerdict?.textContent || '--';

        // Text info on left side of panel 2
        addText(panel2, panel2X, panelY + 6, 'Cut Angle:', { size: '1.6', fill: '#888' });
        addText(panel2, panel2X + 11, panelY + 6, cutAngleText, { size: '1.6', fill: '#fff' });

        addText(panel2, panel2X, panelY + 8.5, 'Overlap:', { size: '1.6', fill: '#888' });
        addText(panel2, panel2X + 11, panelY + 8.5, `${overlapEnglishText} (${overlapPercentText})`, { size: '1.6', fill: '#fff' });

        addText(panel2, panel2X, panelY + 11, 'Difficulty:', { size: '1.6', fill: '#888' });
        addText(panel2, panel2X + 11, panelY + 11, diffText, { size: '1.6', fill: '#fff' });

        addText(panel2, panel2X, panelY + 13.5, 'Verdict:', { size: '1.6', fill: '#888' });
        addText(panel2, panel2X + 11, panelY + 13.5, verdictText, { size: '1.6', fill: '#0fa', weight: 'bold' });

        // Venn diagram (overlap visualization) on right side of panel 2
        const vennX = panel2X + 27;
        const vennY = panelY + 9;
        const vennScale = 3.5;  // Scale factor for the diagram

        // Parse overlap percentage to calculate ghost ball position
        const overlapPercent = parseInt(overlapPercentText) || 50;
        const overlapFraction = overlapPercent / 100;
        const objBallXVenn = 0.5;
        const vennOffset = (1 - overlapFraction) * 2;
        const ghostBallXVenn = objBallXVenn - vennOffset;

        // Venn diagram background
        const vennBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        vennBg.setAttribute('x', vennX - 3.5 * vennScale / 3);
        vennBg.setAttribute('y', vennY - vennScale);
        vennBg.setAttribute('width', 7 * vennScale / 3);
        vennBg.setAttribute('height', 2 * vennScale);
        vennBg.setAttribute('fill', '#0a0f15');
        vennBg.setAttribute('rx', '1');
        panel2.appendChild(vennBg);

        // ClipPath for overlap region
        const vennClipId = 'export-clip-obj-ball';
        const vennDefs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
        const vennClip = document.createElementNS('http://www.w3.org/2000/svg', 'clipPath');
        vennClip.setAttribute('id', vennClipId);
        const clipCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        clipCircle.setAttribute('cx', vennX + objBallXVenn * vennScale / 3);
        clipCircle.setAttribute('cy', vennY);
        clipCircle.setAttribute('r', vennScale / 3);
        vennClip.appendChild(clipCircle);
        vennDefs.appendChild(vennClip);
        panel2.appendChild(vennDefs);

        // Object Ball (OB) - orange outline
        const vennOB = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        vennOB.setAttribute('cx', vennX + objBallXVenn * vennScale / 3);
        vennOB.setAttribute('cy', vennY);
        vennOB.setAttribute('r', vennScale / 3);
        vennOB.setAttribute('fill', 'none');
        vennOB.setAttribute('stroke', '#ff6b35');
        vennOB.setAttribute('stroke-width', '0.15');
        panel2.appendChild(vennOB);

        // Ghost Ball (GB) - gold dashed
        const vennGB = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        vennGB.setAttribute('cx', vennX + ghostBallXVenn * vennScale / 3);
        vennGB.setAttribute('cy', vennY);
        vennGB.setAttribute('r', vennScale / 3);
        vennGB.setAttribute('fill', 'rgba(255,215,0,0.15)');
        vennGB.setAttribute('stroke', '#ffd700');
        vennGB.setAttribute('stroke-width', '0.15');
        vennGB.setAttribute('stroke-dasharray', '0.3,0.2');
        panel2.appendChild(vennGB);

        // Overlap region highlight (clipped to OB)
        const vennOverlap = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        vennOverlap.setAttribute('cx', vennX + ghostBallXVenn * vennScale / 3);
        vennOverlap.setAttribute('cy', vennY);
        vennOverlap.setAttribute('r', vennScale / 3);
        vennOverlap.setAttribute('fill', 'rgba(0,255,170,0.3)');
        vennOverlap.setAttribute('clip-path', `url(#${vennClipId})`);
        panel2.appendChild(vennOverlap);

        // Labels
        addText(panel2, vennX + objBallXVenn * vennScale / 3, vennY + 0.3, 'OB', { size: '1.1', fill: '#ff6b35', anchor: 'middle' });
        addText(panel2, vennX + ghostBallXVenn * vennScale / 3, vennY + 0.3, 'CB', { size: '1.1', fill: '#ffd700', anchor: 'middle' });

        exportSvg.appendChild(panel2);

        // ===== PANEL 3: LEGEND =====
        const panel3X = 68;
        const panel3 = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        panel3.setAttribute('id', 'export-legend');

        addText(panel3, panel3X, panelY + 3, 'LEGEND', { size: '2.2', fill: '#0fa', weight: 'bold' });

        // Line legend items
        addLineSample(panel3, panel3X, panelY + 5.5, '#fff', '1,1', 'Aim Line');
        addLineSample(panel3, panel3X, panelY + 8, '#ffd700', null, 'Target Line');
        addLineSample(panel3, panel3X, panelY + 10.5, '#ff6b35', null, 'OB Path');
        addLineSample(panel3, panel3X, panelY + 13, '#00bfff', null, 'CB Path');

        addLineSample(panel3, panel3X + 18, panelY + 5.5, '#ff0', null, 'Kick Point');
        addLineSample(panel3, panel3X + 18, panelY + 8, '#ff4444', '0.8,0.4', 'Blocked');
        addLineSample(panel3, panel3X + 18, panelY + 10.5, '#ff44ff', null, 'Combo');
        addLineSample(panel3, panel3X + 18, panelY + 13, '#00ffff', '0.8,0.4', 'Tangent');

        exportSvg.appendChild(panel3);

        return exportSvg;
      }

      // Export as PNG
      async function exportPNG() {
        const exportSvg = createExportSVG();

        // Set explicit dimensions (viewBox is 116x88, aspect ratio ~1.32)
        exportSvg.setAttribute('width', '1600');
        exportSvg.setAttribute('height', '1214');

        const svgData = new XMLSerializer().serializeToString(exportSvg);
        const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
        const url = URL.createObjectURL(svgBlob);

        const canvas = document.createElement('canvas');
        canvas.width = 1600;
        canvas.height = 1214;
        const ctx = canvas.getContext('2d');

        const img = new Image();
        img.onload = () => {
          // Draw SVG (fills canvas)
          ctx.drawImage(img, 0, 0, 1600, 1214);
          URL.revokeObjectURL(url);

          // Download
          canvas.toBlob(blob => {
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = 'shot-diagram.png';
            a.click();
            URL.revokeObjectURL(a.href);
            showToast('PNG downloaded!');
          }, 'image/png');
        };
        img.onerror = (e) => {
          console.error('Failed to load SVG for PNG export:', e);
          showToast('Export failed - try SVG instead');
          URL.revokeObjectURL(url);
        };
        img.src = url;
      }

      // Export as SVG
      function exportSVG() {
        const exportSvg = createExportSVG();

        // Set explicit dimensions (viewBox is 116x88, aspect ratio ~1.32)
        exportSvg.setAttribute('width', '800');
        exportSvg.setAttribute('height', '607');

        const svgData = new XMLSerializer().serializeToString(exportSvg);
        const blob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });

        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'shot-diagram.svg';
        a.click();
        URL.revokeObjectURL(a.href);
        showToast('SVG downloaded!');
      }

      // ========== LOCAL STORAGE SAVE/LOAD ==========

      const STORAGE_KEY = 'ace_shot_diagrams';

      function getSavedDiagrams() {
        try {
          const data = localStorage.getItem(STORAGE_KEY);
          return data ? JSON.parse(data) : [];
        } catch (e) {
          console.error('Failed to load saved diagrams:', e);
          return [];
        }
      }

      function saveDiagram(name) {
        if (!name || !name.trim()) {
          showToast('Please enter a diagram name');
          return false;
        }

        const state = captureState();
        const diagrams = getSavedDiagrams();

        // Check if name already exists
        const existingIndex = diagrams.findIndex(d => d.name.toLowerCase() === name.trim().toLowerCase());
        if (existingIndex >= 0) {
          // Update existing
          diagrams[existingIndex] = {
            name: name.trim(),
            state: state,
            savedAt: Date.now()
          };
        } else {
          // Add new
          diagrams.push({
            name: name.trim(),
            state: state,
            savedAt: Date.now()
          });
        }

        try {
          localStorage.setItem(STORAGE_KEY, JSON.stringify(diagrams));
          showToast(`Saved "${name.trim()}"`);
          renderSavedList();
          return true;
        } catch (e) {
          console.error('Failed to save diagram:', e);
          showToast('Failed to save - storage may be full');
          return false;
        }
      }

      function loadDiagram(index) {
        const diagrams = getSavedDiagrams();
        if (index >= 0 && index < diagrams.length) {
          const diagram = diagrams[index];
          applyState(diagram.state);
          showToast(`Loaded "${diagram.name}"`);
          updateURL();
        }
      }

      function deleteDiagram(index) {
        const diagrams = getSavedDiagrams();
        if (index >= 0 && index < diagrams.length) {
          const name = diagrams[index].name;
          diagrams.splice(index, 1);
          try {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(diagrams));
            showToast(`Deleted "${name}"`);
            renderSavedList();
          } catch (e) {
            console.error('Failed to delete diagram:', e);
          }
        }
      }

      function formatDate(timestamp) {
        const date = new Date(timestamp);
        const now = new Date();
        const diffDays = Math.floor((now - date) / (1000 * 60 * 60 * 24));

        if (diffDays === 0) {
          return 'Today ' + date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        } else if (diffDays === 1) {
          return 'Yesterday';
        } else if (diffDays < 7) {
          return diffDays + ' days ago';
        } else {
          return date.toLocaleDateString();
        }
      }

      function renderSavedList() {
        const listEl = document.getElementById('savedDiagramsList');
        const diagrams = getSavedDiagrams();

        if (diagrams.length === 0) {
          listEl.innerHTML = '<div class="no-saved">No saved diagrams yet</div>';
          return;
        }

        // Sort by most recent first
        diagrams.sort((a, b) => b.savedAt - a.savedAt);

        listEl.innerHTML = diagrams.map((d, i) => `
          <div class="saved-item" data-index="${i}">
            <div class="saved-item-info" onclick="loadDiagram(${i})" title="Click to load">
              <div class="saved-item-name">${escapeHtml(d.name)}</div>
              <div class="saved-item-date">${formatDate(d.savedAt)}</div>
            </div>
            <div class="saved-item-actions">
              <button class="saved-item-btn delete" onclick="deleteDiagram(${i})" title="Delete">Ã—</button>
            </div>
          </div>
        `).join('');
      }

      function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      }

      // Expose functions globally for onclick handlers
      window.loadDiagram = loadDiagram;
      window.deleteDiagram = deleteDiagram;

      // ========== TANGENT LINE VISUALIZATION ==========

      let showTangentLine = false;
      const tangentLineGroup = document.getElementById('tangent-line-group');
      const tangentLine = document.getElementById('tangent-line');
      const tangentLabel = document.getElementById('tangent-label');

      function updateTangentLine() {
        if (!showTangentLine || !selectedBallId || !selectedPocket) {
          tangentLineGroup.setAttribute('visibility', 'hidden');
          return;
        }

        const ghostPos = ballPositions['ghost'];
        const objBallPos = ballPositions[selectedBallId];
        const cuePos = ballPositions['cue'];

        if (!ghostPos || !objBallPos || !cuePos) {
          tangentLineGroup.setAttribute('visibility', 'hidden');
          return;
        }

        // Vector from ghost to object ball (contact direction)
        const contactDir = vectorNormalize(vectorSubtract(objBallPos, ghostPos));

        // Tangent is perpendicular (90Â° rotation)
        let tangentDir = { x: -contactDir.y, y: contactDir.x };

        // Determine which direction CB would go based on which side we're cutting
        const cueToGhost = vectorSubtract(ghostPos, cuePos);
        const crossProduct = cueToGhost.x * contactDir.y - cueToGhost.y * contactDir.x;
        if (crossProduct < 0) {
          tangentDir.x = -tangentDir.x;
          tangentDir.y = -tangentDir.y;
        }

        // Calculate end point (extend toward table edge)
        const lineLength = 50;
        let endX = ghostPos.x + tangentDir.x * lineLength;
        let endY = ghostPos.y + tangentDir.y * lineLength;

        // Clip to table boundaries (playing surface is 0-100 x 0-50)
        if (endX < 0) {
          const t = -ghostPos.x / (endX - ghostPos.x);
          endX = 0;
          endY = ghostPos.y + t * (endY - ghostPos.y);
        } else if (endX > 100) {
          const t = (100 - ghostPos.x) / (endX - ghostPos.x);
          endX = 100;
          endY = ghostPos.y + t * (endY - ghostPos.y);
        }
        if (endY < 0) {
          const t = -ghostPos.y / (endY - ghostPos.y);
          endY = 0;
          endX = ghostPos.x + t * (endX - ghostPos.x);
        } else if (endY > 50) {
          const t = (50 - ghostPos.y) / (endY - ghostPos.y);
          endY = 50;
          endX = ghostPos.x + t * (endX - ghostPos.x);
        }

        tangentLine.setAttribute('x1', ghostPos.x);
        tangentLine.setAttribute('y1', ghostPos.y);
        tangentLine.setAttribute('x2', endX);
        tangentLine.setAttribute('y2', endY);

        // Position label at end of line
        tangentLabel.setAttribute('x', endX);
        tangentLabel.setAttribute('y', endY - 1.5);

        tangentLineGroup.setAttribute('visibility', 'visible');
      }

      // ========== FOLLOW/DRAW LINE VISUALIZATION ==========

      let showFollowLine = false;
      let showDrawLine = false;
      const followLineGroup = document.getElementById('follow-line-group');
      const followLine = document.getElementById('follow-line');
      const followLabel = document.getElementById('follow-label');
      const drawLineGroup = document.getElementById('draw-line-group');
      const drawLine = document.getElementById('draw-line');
      const drawLabel = document.getElementById('draw-label');

      function updateFollowDrawLines() {
        // Hide both by default
        followLineGroup.setAttribute('visibility', 'hidden');
        drawLineGroup.setAttribute('visibility', 'hidden');

        if ((!showFollowLine && !showDrawLine) || !selectedBallId || !selectedPocket) {
          return;
        }

        const ghostPos = ballPositions['ghost'];
        const objBallPos = ballPositions[selectedBallId];
        const cuePos = ballPositions['cue'];

        if (!ghostPos || !objBallPos || !cuePos) return;

        // Vector from ghost to object ball (contact direction)
        const contactDir = vectorNormalize(vectorSubtract(objBallPos, ghostPos));

        // Tangent is perpendicular (90Â° rotation)
        let tangentDir = { x: -contactDir.y, y: contactDir.x };

        // Determine which direction CB would go based on which side we're cutting
        const cueToGhost = vectorSubtract(ghostPos, cuePos);
        const crossProduct = cueToGhost.x * contactDir.y - cueToGhost.y * contactDir.x;
        if (crossProduct < 0) {
          tangentDir.x = -tangentDir.x;
          tangentDir.y = -tangentDir.y;
        }

        // Follow line: CB continues forward ~30Â° from tangent (toward OB direction)
        // The angle depends on the cut angle - steeper cuts = less follow effect
        const cutAngle = angleBetweenVectors(cueToGhost, vectorSubtract(objBallPos, ghostPos));
        const followAngleDeg = 30 * Math.cos(cutAngle * Math.PI / 180); // Reduces at steep cuts

        if (showFollowLine) {
          // Follow rotates toward the OB direction (opposite of tangent perpendicular)
          const followDir = rotateVector(tangentDir, -followAngleDeg * Math.sign(crossProduct || 1));
          const lineLength = 40;
          let endX = ghostPos.x + followDir.x * lineLength;
          let endY = ghostPos.y + followDir.y * lineLength;

          // Clip to table
          if (endX < 0) { const t = -ghostPos.x / (endX - ghostPos.x); endX = 0; endY = ghostPos.y + t * (endY - ghostPos.y); }
          else if (endX > 100) { const t = (100 - ghostPos.x) / (endX - ghostPos.x); endX = 100; endY = ghostPos.y + t * (endY - ghostPos.y); }
          if (endY < 0) { const t = -ghostPos.y / (endY - ghostPos.y); endY = 0; endX = ghostPos.x + t * (endX - ghostPos.x); }
          else if (endY > 50) { const t = (50 - ghostPos.y) / (endY - ghostPos.y); endY = 50; endX = ghostPos.x + t * (endX - ghostPos.x); }

          followLine.setAttribute('x1', ghostPos.x);
          followLine.setAttribute('y1', ghostPos.y);
          followLine.setAttribute('x2', endX);
          followLine.setAttribute('y2', endY);
          followLabel.setAttribute('x', endX);
          followLabel.setAttribute('y', endY - 1.5);
          followLineGroup.setAttribute('visibility', 'visible');
        }

        if (showDrawLine) {
          // Draw rotates away from the OB direction (back toward shooter)
          const drawAngleDeg = 30 + cutAngle * 0.3; // Draw pulls back more at steep cuts
          const drawDir = rotateVector(tangentDir, drawAngleDeg * Math.sign(crossProduct || 1));
          const lineLength = 35;
          let endX = ghostPos.x + drawDir.x * lineLength;
          let endY = ghostPos.y + drawDir.y * lineLength;

          // Clip to table
          if (endX < 0) { const t = -ghostPos.x / (endX - ghostPos.x); endX = 0; endY = ghostPos.y + t * (endY - ghostPos.y); }
          else if (endX > 100) { const t = (100 - ghostPos.x) / (endX - ghostPos.x); endX = 100; endY = ghostPos.y + t * (endY - ghostPos.y); }
          if (endY < 0) { const t = -ghostPos.y / (endY - ghostPos.y); endY = 0; endX = ghostPos.x + t * (endX - ghostPos.x); }
          else if (endY > 50) { const t = (50 - ghostPos.y) / (endY - ghostPos.y); endY = 50; endX = ghostPos.x + t * (endX - ghostPos.x); }

          drawLine.setAttribute('x1', ghostPos.x);
          drawLine.setAttribute('y1', ghostPos.y);
          drawLine.setAttribute('x2', endX);
          drawLine.setAttribute('y2', endY);
          drawLabel.setAttribute('x', endX);
          drawLabel.setAttribute('y', endY - 1.5);
          drawLineGroup.setAttribute('visibility', 'visible');
        }
      }

      // ========== SHOT MAKE PROBABILITY ==========

      function calculateMakeProbability(shotData) {
        if (!shotData || !shotData.isReady) return null;

        // If OB path is blocked, shot is impossible
        if (shotData.obPathBlocked) return 0;

        // Base probability starts at 95% for straight-in shots
        let probability = 95;

        // Cut angle penalty (biggest factor)
        const cutAngle = shotData.cutAngle || 0;
        if (cutAngle > 70) probability -= 50;
        else if (cutAngle > 60) probability -= 35;
        else if (cutAngle > 50) probability -= 25;
        else if (cutAngle > 40) probability -= 15;
        else if (cutAngle > 30) probability -= 8;
        else if (cutAngle > 20) probability -= 4;

        // Distance penalty
        const distance = shotData.totalDistance || 50;
        if (distance > 80) probability -= 15;
        else if (distance > 60) probability -= 10;
        else if (distance > 40) probability -= 5;

        // Shot type penalties
        if (shotData.isKickShot) probability -= 25;
        if (shotData.isBankShot) probability -= 20;
        if (shotData.isComboShot) probability -= 30;

        // Ensure bounds
        probability = Math.max(5, Math.min(95, probability));

        return Math.round(probability);
      }

      function updateMakeProbability(shotData) {
        // Use querySelector to target the correct palette (ID is duplicated)
        const shotPalette = document.getElementById('palette-shot');
        const display = shotPalette ? shotPalette.querySelector('#makeProbabilityDisplay') : null;
        if (!display) return;

        const prob = calculateMakeProbability(shotData);
        if (prob === null) {
          display.textContent = '--';
          display.style.color = '#888';
          return;
        }

        display.textContent = prob + '%';

        // Color code by probability
        if (prob >= 80) display.style.color = '#0f8';
        else if (prob >= 60) display.style.color = '#8f0';
        else if (prob >= 40) display.style.color = '#ff0';
        else if (prob >= 20) display.style.color = '#f80';
        else display.style.color = '#f44';
      }

      // ========== RANDOM RACK WITH BREAK ANIMATION ==========

      // Physics constants for break simulation
      const BREAK_PHYSICS = {
        FRICTION: 0.985,           // Per-frame velocity decay (rolling friction)
        RAIL_COR: 0.85,            // Coefficient of restitution for rail bounce
        BALL_COR: 0.95,            // Coefficient of restitution for ball-ball collision
        MIN_VELOCITY: 0.02,        // Minimum velocity before ball stops
        BALL_DIAMETER: BALL_RADIUS * 2,
        FRAME_RATE: 60,            // Target FPS
        FORCE_MULTIPLIER: 0.8,     // 3/4 force = 7.5 * 0.8 = 6 initial speed
        COLLISION_ITERATIONS: 8    // Multiple passes for frozen rack momentum propagation
      };

      // Ball state during animation
      let breakBallStates = {};    // { ballId: { x, y, vx, vy } }
      let breakAnimationId = null;
      let isBreakAnimating = false;

      // Shot animation state (for regular shots)
      let shotBallStates = {};
      let shotAnimationId = null;
      let isShotAnimating = false;
      let shotAnimationFrames = 0;
      const MAX_SHOT_FRAMES = 120; // ~2 seconds at 60fps - ensures completion in tests
      let isBreakSetup = false;  // Flag to prevent ghost ball clearing during break setup
      let frozenRackPending = false;  // Flag to apply empirical break physics on first contact
      let rackBallPositions = {};  // Store rack positions with row/col for break physics

      // Cue stick element
      let cueStickElement = null;

      // Generate British-style rack positions
      function generateRackPositions(gameBalls) {
        const FOOT_SPOT = { x: 75, y: 25 };
        const BALL_D = BREAK_PHYSICS.BALL_DIAMETER;
        const ROW_SPACING = BALL_D * Math.sin(Math.PI / 3); // Equilateral triangle spacing
        const positions = {};

        if (gameBalls.length === 9) {
          // 9-Ball diamond rack: 1-2-3-2-1 formation
          // British style: 1 at apex, 9 in center, others random
          const diamondPattern = [
            [0],           // Row 0: 1 ball (apex)
            [-0.5, 0.5],   // Row 1: 2 balls
            [-1, 0, 1],    // Row 2: 3 balls (9 in center)
            [-0.5, 0.5],   // Row 3: 2 balls
            [0]            // Row 4: 1 ball
          ];

          const shuffledBalls = [...gameBalls].filter(b => b !== '1' && b !== '9');
          shuffleArray(shuffledBalls);

          let ballIndex = 0;
          for (let row = 0; row < diamondPattern.length; row++) {
            for (let col = 0; col < diamondPattern[row].length; col++) {
              const x = FOOT_SPOT.x + row * ROW_SPACING;
              const y = FOOT_SPOT.y + diamondPattern[row][col] * BALL_D;

              let ballId;
              if (row === 0) {
                ballId = '1';  // 1-ball at apex
              } else if (row === 2 && col === 1) {
                ballId = '9';  // 9-ball in center
              } else {
                ballId = shuffledBalls[ballIndex++];
              }

              if (ballId && gameBalls.includes(ballId)) {
                positions[ballId] = { x, y };
              }
            }
          }
        } else if (gameBalls.length === 10) {
          // 10-Ball triangle rack: 1-2-3-4 formation
          const trianglePattern = [
            [0],                    // Row 0: 1 ball (apex)
            [-0.5, 0.5],            // Row 1: 2 balls
            [-1, 0, 1],             // Row 2: 3 balls (10 in center)
            [-1.5, -0.5, 0.5, 1.5]  // Row 3: 4 balls
          ];

          const shuffledBalls = [...gameBalls].filter(b => b !== '1' && b !== '10');
          shuffleArray(shuffledBalls);

          let ballIndex = 0;
          for (let row = 0; row < trianglePattern.length; row++) {
            for (let col = 0; col < trianglePattern[row].length; col++) {
              const x = FOOT_SPOT.x + row * ROW_SPACING;
              const y = FOOT_SPOT.y + trianglePattern[row][col] * BALL_D;

              let ballId;
              if (row === 0) {
                ballId = '1';   // 1-ball at apex
              } else if (row === 2 && col === 1) {
                ballId = '10';  // 10-ball in center
              } else {
                ballId = shuffledBalls[ballIndex++];
              }

              if (ballId && gameBalls.includes(ballId)) {
                positions[ballId] = { x, y };
              }
            }
          }
        } else {
          // 8-Ball/15-Ball triangle rack: 1-2-3-4-5 formation
          // British style: 8 in center, solid+stripe on back corners, alternating
          const trianglePattern = [
            [0],                          // Row 0: 1 ball (apex)
            [-0.5, 0.5],                  // Row 1: 2 balls
            [-1, 0, 1],                   // Row 2: 3 balls (8 in center)
            [-1.5, -0.5, 0.5, 1.5],       // Row 3: 4 balls
            [-2, -1, 0, 1, 2]             // Row 4: 5 balls (corners: solid + stripe)
          ];

          // Separate solids and stripes
          // Traditional 8-ball: 1-ball is ALWAYS at the apex (head ball)
          const solids = gameBalls.filter(b => parseInt(b) >= 1 && parseInt(b) <= 7 && b !== '1');
          const stripes = gameBalls.filter(b => parseInt(b) >= 9 && parseInt(b) <= 15);

          shuffleArray(solids);
          shuffleArray(stripes);

          // Pick one random solid and stripe for back corners
          const cornerSolid = solids.pop();
          const cornerStripe = stripes.pop();

          // Combine remaining balls and shuffle for the rest
          const remainingBalls = [...solids, ...stripes];
          shuffleArray(remainingBalls);

          let ballIndex = 0;
          for (let row = 0; row < trianglePattern.length; row++) {
            for (let col = 0; col < trianglePattern[row].length; col++) {
              const x = FOOT_SPOT.x + row * ROW_SPACING;
              const y = FOOT_SPOT.y + trianglePattern[row][col] * BALL_D;

              let ballId;
              if (row === 0) {
                // Apex: ALWAYS the 1-ball (traditional 8-ball rack)
                ballId = '1';
              } else if (row === 2 && col === 1) {
                ballId = '8';  // 8-ball in center
              } else if (row === 4 && col === 0) {
                // Back left corner: solid
                ballId = cornerSolid;
              } else if (row === 4 && col === 4) {
                // Back right corner: stripe
                ballId = cornerStripe;
              } else {
                ballId = remainingBalls[ballIndex++];
              }

              if (ballId && gameBalls.includes(ballId)) {
                positions[ballId] = { x, y };
              }
            }
          }
        }

        return positions;
      }

      // Fisher-Yates shuffle
      function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
      }

      // Empirical break physics based on Dr. Dave's research
      // In a frozen rack, forces propagate instantly through touching balls
      // Center balls (like 8-ball) barely move because forces pass through them
      // Corner balls get maximum velocity because they only receive outward forces
      function applyFrozenRackBreakPhysics(cueVelocity) {
        const FOOT_SPOT = { x: 75, y: 25 };
        const cueSpeed = Math.sqrt(cueVelocity.vx * cueVelocity.vx + cueVelocity.vy * cueVelocity.vy);

        // Base velocity factor from cue speed
        const baseVel = cueSpeed * 0.7;

        for (const ballId in shotBallStates) {
          if (ballId === 'cue') continue;

          const ball = shotBallStates[ballId];
          if (!ball || ball.pocketed) continue;

          // Calculate position relative to foot spot
          const relX = ball.x - FOOT_SPOT.x;  // + means behind foot spot (toward back of rack)
          const relY = ball.y - FOOT_SPOT.y;  // + means below center, - means above

          // Determine row in rack (approximate based on x position)
          const rowSpacing = BALL_RADIUS * 2 * Math.sin(Math.PI / 3);
          const row = Math.round(relX / rowSpacing);

          // Determine lateral position (how far from center line)
          const lateralPos = Math.abs(relY) / (BALL_RADIUS * 2);

          // Calculate velocity based on position
          // Key insight: center balls (low lateral position) get less velocity
          // Edge balls (high lateral position) get more velocity

          // Row factor: back rows get slightly more energy
          const rowFactor = 0.5 + row * 0.12;

          // Lateral factor: edge balls get more, center balls get less
          // This is the key to making 8-ball (center) stay still
          const lateralFactor = 0.1 + lateralPos * 0.5;

          // Combined velocity magnitude
          const velMag = baseVel * rowFactor * lateralFactor;

          // Direction: mostly outward from center, slightly forward
          const outwardAngle = Math.atan2(relY, 1);  // Angle from center line
          const spreadAngle = outwardAngle * (0.8 + row * 0.1);  // More spread for back rows

          // Apply velocity
          ball.vx = Math.cos(spreadAngle) * velMag + baseVel * 0.3;  // Forward component
          ball.vy = Math.sin(spreadAngle) * velMag;

          // Special handling for 8-ball (or any center ball) - minimal movement
          if (ballId === '8' || ballId === '9' || ballId === '10') {
            // Check if truly centered (low lateral position)
            if (Math.abs(relY) < BALL_RADIUS) {
              ball.vx *= 0.15;  // Drastically reduce center ball movement
              ball.vy *= 0.15;
            }
          }
        }

        // Cue ball behavior based on english
        const cueBall = shotBallStates['cue'];
        if (cueBall && cueBall.english) {
          if (cueBall.english.y > 0) {
            // Draw - cue ball comes back
            cueBall.vx *= -0.4;
            cueBall.vy *= -0.4;
          } else if (cueBall.english.y < 0) {
            // Follow - cue ball continues forward
            cueBall.vx *= 0.5;
            cueBall.vy *= 0.5;
          } else {
            // Stop/stun
            cueBall.vx *= 0.1;
            cueBall.vy *= 0.1;
          }
          cueBall.english = null;
        }

        frozenRackPending = false;
      }

      // Create or get cue stick SVG element
      function getCueStick() {
        if (!cueStickElement) {
          const svg = document.getElementById('pool-table-svg');
          const cueGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
          cueGroup.id = 'cue-stick';
          cueGroup.style.visibility = 'hidden';

          // Cue stick body (tapered)
          const cueBody = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
          // Tip at origin, butt extends in negative x direction
          cueBody.setAttribute('points', '0,-0.3 -50,-0.6 -50,0.6 0,0.3');
          cueBody.setAttribute('fill', 'url(#cue-gradient)');
          cueBody.setAttribute('stroke', '#654321');
          cueBody.setAttribute('stroke-width', '0.1');

          // Add gradient definition
          const defs = svg.querySelector('defs') || document.createElementNS('http://www.w3.org/2000/svg', 'defs');
          if (!svg.querySelector('defs')) svg.insertBefore(defs, svg.firstChild);

          const gradient = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
          gradient.id = 'cue-gradient';
          gradient.setAttribute('x1', '0%');
          gradient.setAttribute('x2', '100%');

          const stop1 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
          stop1.setAttribute('offset', '0%');
          stop1.setAttribute('style', 'stop-color:#f5deb3');

          const stop2 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
          stop2.setAttribute('offset', '15%');
          stop2.setAttribute('style', 'stop-color:#deb887');

          const stop3 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
          stop3.setAttribute('offset', '100%');
          stop3.setAttribute('style', 'stop-color:#8b4513');

          gradient.appendChild(stop1);
          gradient.appendChild(stop2);
          gradient.appendChild(stop3);
          defs.appendChild(gradient);

          // Ferrule (white tip holder)
          const ferrule = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
          ferrule.setAttribute('x', '-2');
          ferrule.setAttribute('y', '-0.35');
          ferrule.setAttribute('width', '2');
          ferrule.setAttribute('height', '0.7');
          ferrule.setAttribute('fill', '#f5f5dc');
          ferrule.setAttribute('rx', '0.1');

          // Tip (blue chalk)
          const tip = document.createElementNS('http://www.w3.org/2000/svg', 'ellipse');
          tip.setAttribute('cx', '0');
          tip.setAttribute('cy', '0');
          tip.setAttribute('rx', '0.5');
          tip.setAttribute('ry', '0.3');
          tip.setAttribute('fill', '#4169e1');

          cueGroup.appendChild(cueBody);
          cueGroup.appendChild(ferrule);
          cueGroup.appendChild(tip);

          svg.appendChild(cueGroup);
          cueStickElement = cueGroup;
        }
        return cueStickElement;
      }

      // Position and angle the cue stick
      function positionCueStick(cuePos, targetPos, pullback = 0) {
        const cue = getCueStick();
        const dx = targetPos.x - cuePos.x;
        const dy = targetPos.y - cuePos.y;
        const angle = Math.atan2(dy, dx) * 180 / Math.PI;

        // Position tip at cue ball position, offset by pullback
        const offsetX = cuePos.x - pullback * Math.cos(angle * Math.PI / 180);
        const offsetY = cuePos.y - pullback * Math.sin(angle * Math.PI / 180);

        cue.setAttribute('transform', `translate(${offsetX}, ${offsetY}) rotate(${angle})`);
        cue.style.visibility = 'visible';
      }

      // Hide cue stick
      function hideCueStick() {
        const cue = getCueStick();
        cue.style.visibility = 'hidden';
      }

      // Ball-ball collision detection and response
      // Uses multiple iterations to simulate momentum propagation through frozen rack
      // Key insight: In a frozen rack, momentum cascades through touching balls almost instantly
      // Iteration 1: Cueâ†’1-ball, Iteration 2: 1-ballâ†’row2, Iteration 3: row2â†’row3, etc.
      function checkBallCollisions() {
        const ballIds = Object.keys(breakBallStates);

        // Multiple iterations allow momentum to CASCADE through chain of touching balls
        // Each iteration, newly-moving balls can hit the next layer
        for (let iter = 0; iter < BREAK_PHYSICS.COLLISION_ITERATIONS; iter++) {
          let hadCollision = false;

          for (let i = 0; i < ballIds.length; i++) {
            for (let j = i + 1; j < ballIds.length; j++) {
              const ball1 = breakBallStates[ballIds[i]];
              const ball2 = breakBallStates[ballIds[j]];

              if (!ball1 || !ball2 || ball1.pocketed || ball2.pocketed) continue;

              const dx = ball2.x - ball1.x;
              const dy = ball2.y - ball1.y;
              const dist = Math.sqrt(dx * dx + dy * dy);

              // Check if balls are touching/overlapping
              if (dist < BREAK_PHYSICS.BALL_DIAMETER && dist > 0) {
                const id1 = ballIds[i];
                const id2 = ballIds[j];

                // Normal vector (from ball1 to ball2)
                const nx = dx / dist;
                const ny = dy / dist;

                // Relative velocity
                const dvx = ball1.vx - ball2.vx;
                const dvy = ball1.vy - ball2.vy;

                // Relative velocity along collision normal
                const dvn = dvx * nx + dvy * ny;

                // Only resolve if balls are approaching
                if (dvn > 0) {
                  hadCollision = true;

                  // Full impulse - DO NOT divide by iterations!
                  // Each iteration processes NEW collisions from cascading momentum
                  const impulse = dvn * BREAK_PHYSICS.BALL_COR;

                  ball1.vx -= impulse * nx;
                  ball1.vy -= impulse * ny;
                  ball2.vx += impulse * nx;
                  ball2.vy += impulse * ny;

                  // Apply english effect when cue ball first hits rack
                  if (id1 === 'cue' && ball1.english !== undefined && ball1.english !== null) {
                    const english = ball1.english;
                    const followFactor = 1 + english * 0.5;
                    ball1.vx *= followFactor;
                    ball1.vy *= followFactor;
                    ball1.english = null;
                  } else if (id2 === 'cue' && ball2.english !== undefined && ball2.english !== null) {
                    const english = ball2.english;
                    const followFactor = 1 + english * 0.5;
                    ball2.vx *= followFactor;
                    ball2.vy *= followFactor;
                    ball2.english = null;
                  }

                  // Separate overlapping balls fully
                  const overlap = BREAK_PHYSICS.BALL_DIAMETER - dist;
                  if (overlap > 0) {
                    const separationX = (overlap / 2 + 0.01) * nx;
                    const separationY = (overlap / 2 + 0.01) * ny;
                    ball1.x -= separationX;
                    ball1.y -= separationY;
                    ball2.x += separationX;
                    ball2.y += separationY;
                  }
                }
              }
            }
          }

          // If no collisions occurred, no need for more iterations
          if (!hadCollision) break;
        }
      }

      // Rail collision detection and response
      function checkRailCollisions() {
        const RAIL_TOP = 2 + BALL_RADIUS;
        const RAIL_BOTTOM = 48 - BALL_RADIUS;
        const RAIL_LEFT = 2 + BALL_RADIUS;
        const RAIL_RIGHT = 98 - BALL_RADIUS;

        for (const ballId in breakBallStates) {
          const ball = breakBallStates[ballId];
          if (!ball) continue;

          // Check pockets first (before rail bounce)
          if (isBallInPocket(ball.x, ball.y)) {
            // Ball is pocketed - remove from simulation
            ball.pocketed = true;
            ball.vx = 0;
            ball.vy = 0;
            continue;
          }

          // Top rail
          if (ball.y < RAIL_TOP) {
            ball.y = RAIL_TOP;
            ball.vy = -ball.vy * BREAK_PHYSICS.RAIL_COR;
          }
          // Bottom rail
          if (ball.y > RAIL_BOTTOM) {
            ball.y = RAIL_BOTTOM;
            ball.vy = -ball.vy * BREAK_PHYSICS.RAIL_COR;
          }
          // Left rail
          if (ball.x < RAIL_LEFT) {
            ball.x = RAIL_LEFT;
            ball.vx = -ball.vx * BREAK_PHYSICS.RAIL_COR;
          }
          // Right rail
          if (ball.x > RAIL_RIGHT) {
            ball.x = RAIL_RIGHT;
            ball.vx = -ball.vx * BREAK_PHYSICS.RAIL_COR;
          }
        }
      }

      // Check if ball is in a pocket
      // Uses same coordinates as pocketCenters for consistency
      function isBallInPocket(x, y) {
        const pockets = [
          { x: 1.5, y: 1.5 },     // Top-left (corner-tl)
          { x: 98.5, y: 1.5 },    // Top-right (corner-tr)
          { x: 1.5, y: 48.5 },    // Bottom-left (corner-bl)
          { x: 98.5, y: 48.5 },   // Bottom-right (corner-br)
          { x: 50, y: 0 },        // Side-top (middle of top rail)
          { x: 50, y: 50 }        // Side-bottom (middle of bottom rail)
        ];

        const POCKET_RADIUS = 4.0; // Match visual pocket size for reliable detection

        for (const pocket of pockets) {
          const dx = x - pocket.x;
          const dy = y - pocket.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < POCKET_RADIUS) {
            return true;
          }
        }
        return false;
      }

      // Update ball positions each frame
      function updateBreakPhysics() {
        let anyMoving = false;

        // Apply friction and update positions
        for (const ballId in breakBallStates) {
          const ball = breakBallStates[ballId];
          if (!ball || ball.pocketed) continue;

          // Apply velocity
          ball.x += ball.vx;
          ball.y += ball.vy;

          // Apply friction
          ball.vx *= BREAK_PHYSICS.FRICTION;
          ball.vy *= BREAK_PHYSICS.FRICTION;

          // Check if still moving
          const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
          if (speed > BREAK_PHYSICS.MIN_VELOCITY) {
            anyMoving = true;
          } else {
            ball.vx = 0;
            ball.vy = 0;
          }
        }

        // Check collisions
        checkBallCollisions();
        checkRailCollisions();

        // Update visual positions
        for (const ballId in breakBallStates) {
          const ball = breakBallStates[ballId];
          if (!ball) continue;

          const ballEl = document.getElementById(`ball-${ballId}`);
          if (ballEl) {
            if (ball.pocketed) {
              ballEl.style.display = 'none';
            } else {
              positionBallOnTable(ballEl, ball.x, ball.y);
            }
          }
        }

        return anyMoving;
      }

      // Animation loop for break
      function animateBreak() {
        if (!isBreakAnimating) return;

        const stillMoving = updateBreakPhysics();

        if (stillMoving) {
          breakAnimationId = requestAnimationFrame(animateBreak);
        } else {
          // Animation complete - finalize positions
          finalizeBreakPositions();
        }
      }

      // Finalize ball positions after animation
      function finalizeBreakPositions() {
        isBreakAnimating = false;

        for (const ballId in breakBallStates) {
          const ball = breakBallStates[ballId];
          if (!ball) continue;

          if (ball.pocketed) {
            ballPositions[ballId] = null;
          } else {
            ballPositions[ballId] = { x: ball.x, y: ball.y };
          }
        }

        // Hide cue stick
        hideCueStick();

        // Clear selections
        selectBall(null);
        selectPocket(null);

        // Update display
        updateCueGhostLine();
        showToast('Break complete!');
      }

      // ========== REGULAR SHOT ANIMATION SYSTEM ==========
      // Adapts break physics for controlled single-ball shots

      // Execute a regular shot with current settings
      async function executeShot() {
        console.log('executeShot() called');
        // Only validate cue ball and ghost ball - no need for selection
        const cuePos = ballPositions['cue'];
        const ghostPos = ballPositions['ghost'];

        console.log('Cue position:', cuePos);
        console.log('Ghost position:', ghostPos);

        if (!cuePos) {
          console.log('Validation failed: No cue ball');
          showToast('âš ï¸ Place cue ball on table first');
          return;
        }

        if (!ghostPos) {
          console.log('Validation failed: No ghost ball');
          showToast('âš ï¸ No aim point - position cue ball to aim');
          return;
        }

        console.log('Validation passed - proceeding with shot');

        // Clear break setup mode
        isBreakSetup = false;

        // Cancel any existing animation
        if (shotAnimationId) {
          cancelAnimationFrame(shotAnimationId);
        }
        if (breakAnimationId) {
          cancelAnimationFrame(breakAnimationId);
        }
        isShotAnimating = false;
        isBreakAnimating = false;

        // Determine aim target (kick point or ghost ball)
        const aimTarget = currentKickPath ? currentKickPath.aimPoint : ghostPos;

        // Show toast immediately so user knows shot is executing
        showToast('ðŸŽ¯ Shot in progress...');

        // Show cue stroke animation
        await animateCueStroke(cuePos, aimTarget, contactOffset.y);

        // Initialize shot physics state - cue ball only initially
        shotBallStates = {
          'cue': {
            x: cuePos.x,
            y: cuePos.y,
            vx: 0,
            vy: 0,
            pocketed: false,
            english: { x: contactOffset.x, y: contactOffset.y }  // Store for collision
          }
        };

        // Add all other balls on table to physics simulation
        for (const ballId in ballPositions) {
          if (ballId === 'cue' || ballId === 'ghost' || !ballPositions[ballId]) continue;

          shotBallStates[ballId] = {
            x: ballPositions[ballId].x,
            y: ballPositions[ballId].y,
            vx: 0,
            vy: 0,
            pocketed: false
          };
        }

        // Calculate initial cue ball velocity toward aim target
        const dx = aimTarget.x - cuePos.x;
        const dy = aimTarget.y - cuePos.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const speed = shotForce * 0.75;  // Scale 1-10 to physics units

        shotBallStates['cue'].vx = (dx / dist) * speed;
        shotBallStates['cue'].vy = (dy / dist) * speed;

        // Start physics simulation
        shotAnimationFrames = 0;
        isShotAnimating = true;
        animateShot();
      }

      // Update physics for shot animation (similar to updateBreakPhysics)
      function updateShotPhysics() {
        let anyMoving = false;

        // Apply friction and update positions
        for (const ballId in shotBallStates) {
          const ball = shotBallStates[ballId];
          if (!ball || ball.pocketed) continue;

          // Apply velocity
          ball.x += ball.vx;
          ball.y += ball.vy;

          // Apply friction
          ball.vx *= BREAK_PHYSICS.FRICTION;
          ball.vy *= BREAK_PHYSICS.FRICTION;

          // Check if still moving
          const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
          if (speed > BREAK_PHYSICS.MIN_VELOCITY) {
            anyMoving = true;
          } else {
            ball.vx = 0;
            ball.vy = 0;
          }
        }

        // Check collisions (reuse break physics functions)
        checkShotCollisions();
        checkShotRailCollisions();

        // Update visual positions
        for (const ballId in shotBallStates) {
          const ball = shotBallStates[ballId];
          if (!ball) continue;

          const ballEl = document.getElementById(`ball-${ballId}`);
          if (ballEl) {
            if (ball.pocketed) {
              ballEl.style.display = 'none';
            } else {
              positionBallOnTable(ballEl, ball.x, ball.y);
            }
          }
        }

        return anyMoving;
      }

      // Check ball-to-ball collisions for shot
      function checkShotCollisions() {
        const ballIds = Object.keys(shotBallStates);
        const collisions = [];

        // Detect collisions
        for (let i = 0; i < ballIds.length; i++) {
          for (let j = i + 1; j < ballIds.length; j++) {
            const ball1 = shotBallStates[ballIds[i]];
            const ball2 = shotBallStates[ballIds[j]];

            if (!ball1 || !ball2 || ball1.pocketed || ball2.pocketed) continue;

            const dx = ball2.x - ball1.x;
            const dy = ball2.y - ball1.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist < BREAK_PHYSICS.BALL_DIAMETER && dist > 0) {
              // Check for frozen rack break - cue hitting any rack ball
              if (frozenRackPending && (ballIds[i] === 'cue' || ballIds[j] === 'cue')) {
                // Apply empirical break physics instead of sequential collisions
                const cueBall = shotBallStates['cue'];
                applyFrozenRackBreakPhysics({ vx: cueBall.vx, vy: cueBall.vy });
                return;  // Skip normal collision processing
              }
              collisions.push([ballIds[i], ballIds[j]]);
            }
          }
        }

        // Resolve collisions
        for (const [id1, id2] of collisions) {
          const ball1 = shotBallStates[id1];
          const ball2 = shotBallStates[id2];

          const dx = ball2.x - ball1.x;
          const dy = ball2.y - ball1.y;
          const dist = Math.sqrt(dx * dx + dy * dy);

          if (dist === 0) continue;

          const nx = dx / dist;
          const ny = dy / dist;

          // Relative velocity
          const dvx = ball1.vx - ball2.vx;
          const dvy = ball1.vy - ball2.vy;
          const dvn = dvx * nx + dvy * ny;

          // Only resolve if balls are approaching
          if (dvn > 0) {
            const impulse = dvn * BREAK_PHYSICS.BALL_COR;

            ball1.vx -= impulse * nx;
            ball1.vy -= impulse * ny;
            ball2.vx += impulse * nx;
            ball2.vy += impulse * ny;

            // Apply english/throw effect if cue ball collision
            if (id1 === 'cue' && ball1.english) {
              // Side english causes throw
              const throwAngle = ball1.english.x * 0.05;  // Radians
              const speed2 = Math.sqrt(ball2.vx * ball2.vx + ball2.vy * ball2.vy);
              const angle2 = Math.atan2(ball2.vy, ball2.vx);
              ball2.vx = Math.cos(angle2 + throwAngle) * speed2;
              ball2.vy = Math.sin(angle2 + throwAngle) * speed2;

              // Top/bottom english affects cue ball after collision
              if (ball1.english.y < 0) {
                // Follow (top spin) - maintain more forward motion
                ball1.vx *= 0.8;
                ball1.vy *= 0.8;
              } else if (ball1.english.y > 0) {
                // Draw (bottom spin) - reverse or stop
                ball1.vx *= -0.3;
                ball1.vy *= -0.3;
              } else {
                // Stun (center) - stop dead
                ball1.vx *= 0.1;
                ball1.vy *= 0.1;
              }

              ball1.english = null;  // English applied, clear it
            }

            // Separate overlapping balls
            const overlap = BREAK_PHYSICS.BALL_DIAMETER - dist;
            const separationX = nx * (overlap / 2 + 0.01);
            const separationY = ny * (overlap / 2 + 0.01);
            ball1.x -= separationX;
            ball1.y -= separationY;
            ball2.x += separationX;
            ball2.y += separationY;
          }
        }
      }

      // Check rail collisions for shot
      function checkShotRailCollisions() {
        for (const ballId in shotBallStates) {
          const ball = shotBallStates[ballId];
          if (!ball || ball.pocketed) continue;

          const ballR = BALL_RADIUS;

          // Check pockets first - use realistic pocket radius for detection
          const POCKET_DETECT_RADIUS = 4.0;  // Match visual pocket size
          for (const pocketName in pocketCenters) {
            const pocket = pocketCenters[pocketName];
            const dx = ball.x - pocket.x;
            const dy = ball.y - pocket.y;
            const distToPocket = Math.sqrt(dx * dx + dy * dy);

            if (distToPocket < POCKET_DETECT_RADIUS) {
              ball.pocketed = true;
              ball.vx = 0;
              ball.vy = 0;
              break;
            }
          }

          if (ball.pocketed) continue;

          // Rail bounces
          if (ball.y - ballR <= RAILS.top.y) {
            ball.y = RAILS.top.y + ballR;
            ball.vy = -ball.vy * BREAK_PHYSICS.RAIL_COR;
          }

          if (ball.y + ballR >= RAILS.bottom.y) {
            ball.y = RAILS.bottom.y - ballR;
            ball.vy = -ball.vy * BREAK_PHYSICS.RAIL_COR;
          }

          if (ball.x - ballR <= RAILS.left.x) {
            ball.x = RAILS.left.x + ballR;
            ball.vx = -ball.vx * BREAK_PHYSICS.RAIL_COR;
          }

          if (ball.x + ballR >= RAILS.right.x) {
            ball.x = RAILS.right.x - ballR;
            ball.vx = -ball.vx * BREAK_PHYSICS.RAIL_COR;
          }
        }
      }

      // Animation loop for regular shot
      function animateShot() {
        if (!isShotAnimating) return;

        shotAnimationFrames++;
        const stillMoving = updateShotPhysics();

        if (stillMoving && shotAnimationFrames < MAX_SHOT_FRAMES) {
          shotAnimationId = requestAnimationFrame(animateShot);
        } else {
          // Animation complete - finalize positions
          finalizeShotPositions();
        }
      }

      // Finalize ball positions after shot animation
      function finalizeShotPositions() {
        isShotAnimating = false;

        let anyBallMade = false;
        let cueBallScratched = false;
        const pocketedBalls = [];

        for (const ballId in shotBallStates) {
          const ball = shotBallStates[ballId];
          if (!ball) continue;

          if (ball.pocketed) {
            ballPositions[ballId] = null;
            if (ballId === 'cue') {
              cueBallScratched = true;
            } else {
              anyBallMade = true;
              pocketedBalls.push(ballId);
            }
          } else {
            ballPositions[ballId] = { x: ball.x, y: ball.y };
          }
        }

        // Hide cue stick
        hideCueStick();

        // Clear selections
        selectBall(null);
        selectPocket(null);

        // Update display
        updateCueGhostLine();

        // Show result
        if (cueBallScratched) {
          showToast('âŒ Scratch! Cue ball pocketed');
        } else if (anyBallMade) {
          const ballList = pocketedBalls.join(', ');
          showToast(`âœ… Pocketed: ${ballList}`);
        } else {
          showToast('â­• No balls pocketed');
        }
      }

      // Animate cue stroke
      async function animateCueStroke(cuePos, targetPos, english) {
        return new Promise(resolve => {
          const pullbackDist = 8;
          const strikeDist = 2;
          const steps = 20;
          let step = 0;

          function animate() {
            if (step <= steps / 2) {
              // Pullback phase
              const progress = step / (steps / 2);
              const pullback = pullbackDist * progress + strikeDist;
              positionCueStick(cuePos, targetPos, pullback);
            } else if (step <= steps) {
              // Strike phase
              const progress = (step - steps / 2) / (steps / 2);
              const pullback = pullbackDist * (1 - progress * 2) + strikeDist;
              if (pullback < 0) {
                // Contact! Start ball movement
                resolve();
                return;
              }
              positionCueStick(cuePos, targetPos, Math.max(0, pullback));
            }

            step++;
            if (step <= steps) {
              requestAnimationFrame(animate);
            } else {
              resolve();
            }
          }

          animate();
        });
      }

      // Main break and rack function
      function randomRack() {
        // Rack button: Just arrange balls, no animation
        // User will click Shoot button to animate the break

        // Get current game mode's balls
        const gameBalls = currentGameMode.ballIds || ['1', '2', '3', '4', '5', '6', '7', '8', '9'];

        // Clear all ball positions first
        for (const ballId of gameBalls) {
          ballPositions[ballId] = null;
          const ball = document.getElementById(`ball-${ballId}`);
          if (ball) {
            ball.style.display = 'none';
          }
        }

        // Generate rack positions (British style)
        const rackPositions = generateRackPositions(gameBalls);

        // Place balls in rack
        for (const ballId in rackPositions) {
          const pos = rackPositions[ballId];
          ballPositions[ballId] = { x: pos.x, y: pos.y };
          const ball = document.getElementById(`ball-${ballId}`);
          if (ball) {
            positionBallOnTable(ball, pos.x, pos.y);
            ball.style.display = '';
          }
        }

        // Place cue ball in kitchen break area
        const cueX = 20;  // Behind head string
        const cueY = 25;  // Center
        ballPositions['cue'] = { x: cueX, y: cueY };
        const cueBall = document.getElementById('ball-cue');
        if (cueBall) {
          positionBallOnTable(cueBall, cueX, cueY);
          cueBall.style.display = '';
        }

        // Position ghost ball to aim at head ball (apex of rack)
        const apexBallId = gameBalls.includes('1') ? '1' : gameBalls[0];
        const headBallPos = rackPositions[apexBallId];

        if (headBallPos) {
          // Ghost ball positioned for proper contact point on head ball
          const dx = headBallPos.x - cueX;
          const dy = headBallPos.y - cueY;
          const dist = Math.sqrt(dx * dx + dy * dy);

          // Place ghost ball one ball-diameter behind head ball (on the line from cue to head ball)
          const ghostX = headBallPos.x - (dx / dist) * BALL_RADIUS * 2;
          const ghostY = headBallPos.y - (dy / dist) * BALL_RADIUS * 2;

          ballPositions['ghost'] = { x: ghostX, y: ghostY };

          // Show ghost ball visually
          const ghostBall = document.getElementById('ball-ghost');
          if (ghostBall) {
            positionBallOnTable(ghostBall, ghostX, ghostY);
            ghostBall.style.display = '';
          }
        }

        // Set break-appropriate english and power
        // Max draw (bottom spin) for power break with cue ball control
        contactOffset = { x: 0, y: 0.55 };  // Max draw (backspin) for break
        contactPoint.setAttribute('cx', 0);
        contactPoint.setAttribute('cy', 0.55);
        updateSpinDisplay(getSpinType(contactOffset));

        shotForce = 10;  // Maximum break power (10/10)
        forceSlider.value = shotForce;
        forceValueDisplay.textContent = shotForce;

        // Initialize break ball states
        breakBallStates = {};
        for (const ballId of gameBalls) {
          if (rackPositions[ballId]) {
            breakBallStates[ballId] = {
              x: rackPositions[ballId].x,
              y: rackPositions[ballId].y,
              vx: 0,
              vy: 0,
              pocketed: false
            };
          }
        }

        // Add cue ball to break states
        if (ballPositions['cue']) {
          breakBallStates['cue'] = {
            x: ballPositions['cue'].x,
            y: ballPositions['cue'].y,
            vx: 0,
            vy: 0,
            pocketed: false
          };
        }

        // Clear selections
        selectedBallId = null;
        selectedPocket = null;

        // Set break mode to preserve ghost ball position
        isBreakSetup = true;
        frozenRackPending = true;  // Enable empirical break physics on first contact

        // Update visualizations
        updateCueGhostLine();
        // DON'T call updateShotGeometry() here - it would hide the ghost ball we just set!
        // updateShotGeometry();

        showToast('âœ… Rack set - Click Shoot to break!');
      }

      // ========== SHAPE ZONE VISUALIZATION ==========

      let showShapeZone = false;
      const shapeZoneGroup = document.getElementById('shape-zone-group');
      const shapeZonePath = document.getElementById('shape-zone-path');
      const shapeZoneLabel = document.getElementById('shape-zone-label');

      const SHAPE_ZONE_CONFIG = {
        maxCutAngle: 65,    // degrees
        maxDistance: 45,    // SVG units
        minDistance: 3      // minimum approach distance
      };

      function rotateVector(v, angleDeg) {
        const rad = angleDeg * Math.PI / 180;
        const cos = Math.cos(rad);
        const sin = Math.sin(rad);
        return {
          x: v.x * cos - v.y * sin,
          y: v.x * sin + v.y * cos
        };
      }

      function clipPointToTable(point) {
        return {
          x: Math.max(0, Math.min(100, point.x)),
          y: Math.max(0, Math.min(50, point.y))
        };
      }

      function updateShapeZone() {
        if (!showShapeZone || !selectedBallId || !selectedPocket) {
          shapeZoneGroup.setAttribute('visibility', 'hidden');
          return;
        }

        const objBallPos = ballPositions[selectedBallId];
        const pocketPos = pocketCenters[selectedPocket];

        if (!objBallPos || !pocketPos) {
          shapeZoneGroup.setAttribute('visibility', 'hidden');
          return;
        }

        // Calculate ghost ball position
        const objToPocket = vectorNormalize(vectorSubtract(pocketPos, objBallPos));
        const ghostPos = {
          x: objBallPos.x - objToPocket.x * GHOST_BALL_OFFSET,
          y: objBallPos.y - objToPocket.y * GHOST_BALL_OFFSET
        };

        // Direction from ghost AWAY from object ball (where CB approaches from)
        const approachDir = { x: -objToPocket.x, y: -objToPocket.y };

        // Generate zone polygon points
        const points = [];

        // Start at ghost position (apex of triangle)
        points.push({ ...ghostPos });

        // Arc from left edge to right edge
        const numArcPoints = 16;
        for (let i = 0; i <= numArcPoints; i++) {
          const t = i / numArcPoints;
          const angle = SHAPE_ZONE_CONFIG.maxCutAngle * (1 - 2 * t); // +max to -max
          const dir = rotateVector(approachDir, angle);

          // Distance varies: closer near center, farther at edges
          const angleRatio = Math.abs(angle) / SHAPE_ZONE_CONFIG.maxCutAngle;
          const dist = SHAPE_ZONE_CONFIG.maxDistance * (0.7 + 0.3 * (1 - angleRatio));

          let point = {
            x: ghostPos.x + dir.x * dist,
            y: ghostPos.y + dir.y * dist
          };

          // Clip to table bounds
          point = clipPointToTable(point);
          points.push(point);
        }

        // Convert to SVG path
        const pathD = `M ${points.map(p => `${p.x.toFixed(1)},${p.y.toFixed(1)}`).join(' L ')} Z`;
        shapeZonePath.setAttribute('d', pathD);

        // Position label in center of zone
        const centerDist = SHAPE_ZONE_CONFIG.maxDistance * 0.4;
        const labelPos = clipPointToTable({
          x: ghostPos.x + approachDir.x * centerDist,
          y: ghostPos.y + approachDir.y * centerDist
        });
        shapeZoneLabel.setAttribute('x', labelPos.x);
        shapeZoneLabel.setAttribute('y', labelPos.y);

        shapeZoneGroup.setAttribute('visibility', 'visible');
      }

      // ========== SETUP SHARE PALETTE ==========

      function setupSharePalette() {
        // Copy Link button
        const btnCopyLink = document.getElementById('btnCopyLink');
        if (btnCopyLink) {
          btnCopyLink.addEventListener('click', copyShareLink);
        }

        // Export PNG button
        const btnExportPNG = document.getElementById('btnExportPNG');
        if (btnExportPNG) {
          btnExportPNG.addEventListener('click', exportPNG);
        }

        // Export SVG button
        const btnExportSVG = document.getElementById('btnExportSVG');
        if (btnExportSVG) {
          btnExportSVG.addEventListener('click', exportSVG);
        }

        // Tangent line toggle
        const toggleTangent = document.getElementById('toggleTangentLine');
        if (toggleTangent) {
          toggleTangent.addEventListener('change', (e) => {
            showTangentLine = e.target.checked;
            updateTangentLine();
          });
        }

        // Shape zone toggle
        const toggleShape = document.getElementById('toggleShapeZone');
        if (toggleShape) {
          toggleShape.addEventListener('change', (e) => {
            showShapeZone = e.target.checked;
            updateShapeZone();
          });
        }

        // Follow line toggle
        const toggleFollow = document.getElementById('toggleFollowLine');
        if (toggleFollow) {
          toggleFollow.addEventListener('change', (e) => {
            showFollowLine = e.target.checked;
            updateFollowDrawLines();
          });
        }

        // Draw line toggle
        const toggleDraw = document.getElementById('toggleDrawLine');
        if (toggleDraw) {
          toggleDraw.addEventListener('change', (e) => {
            showDrawLine = e.target.checked;
            updateFollowDrawLines();
          });
        }

        // Random rack button
        const btnRandomRack = document.getElementById('btnRandomRack');
        if (btnRandomRack) {
          btnRandomRack.addEventListener('click', randomRack);
        }

        // Shoot button
        const btnShoot = document.getElementById('btnShoot');
        if (btnShoot) {
          btnShoot.addEventListener('click', executeShot);
        }

        // Save diagram button
        const btnSaveDiagram = document.getElementById('btnSaveDiagram');
        const saveDiagramName = document.getElementById('saveDiagramName');
        if (btnSaveDiagram && saveDiagramName) {
          btnSaveDiagram.addEventListener('click', () => {
            if (saveDiagram(saveDiagramName.value)) {
              saveDiagramName.value = '';
            }
          });

          // Also save on Enter key
          saveDiagramName.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
              if (saveDiagram(saveDiagramName.value)) {
                saveDiagramName.value = '';
              }
            }
          });
        }

        // Initialize saved diagrams list
        renderSavedList();

        // Setup restore button for share palette
        const restoreShare = document.getElementById('restore-share');
        const paletteShare = document.getElementById('palette-share');
        if (restoreShare && paletteShare) {
          restoreShare.addEventListener('click', () => {
            paletteShare.style.display = 'block';
            restoreShare.style.display = 'none';
          });

          // Setup close button
          const closeBtn = paletteShare.querySelector('.palette-btn.close');
          if (closeBtn) {
            closeBtn.addEventListener('click', () => {
              paletteShare.style.display = 'none';
              restoreShare.style.display = 'block';
            });
          }

          // Setup minimize button
          const minBtn = paletteShare.querySelector('.palette-btn.minimize');
          const body = paletteShare.querySelector('.palette-body');
          if (minBtn && body) {
            minBtn.addEventListener('click', () => {
              const isMinimized = body.style.display === 'none';
              body.style.display = isMinimized ? 'block' : 'none';
              minBtn.textContent = isMinimized ? 'âˆ’' : '+';
            });
          }

          // Make palette draggable
          const header = paletteShare.querySelector('.palette-header');
          if (header) {
            let isDragging = false;
            let startX, startY, startLeft, startTop;

            header.addEventListener('mousedown', (e) => {
              if (e.target.classList.contains('palette-btn')) return;
              isDragging = true;
              startX = e.clientX;
              startY = e.clientY;
              const rect = paletteShare.getBoundingClientRect();
              startLeft = rect.left;
              startTop = rect.top;
              header.style.cursor = 'grabbing';
            });

            document.addEventListener('mousemove', (e) => {
              if (!isDragging) return;
              const dx = e.clientX - startX;
              const dy = e.clientY - startY;
              paletteShare.style.left = (startLeft + dx) + 'px';
              paletteShare.style.top = (startTop + dy) + 'px';
              paletteShare.style.right = 'auto';
            });

            document.addEventListener('mouseup', () => {
              isDragging = false;
              header.style.cursor = 'grab';
            });
          }
        }
      }

      // Hook into updateShotGeometry to also update position aids
      const origUpdateShotGeometry = updateShotGeometry;
      updateShotGeometry = function () {
        origUpdateShotGeometry();
        updateTangentLine();
        updateFollowDrawLines();
        updateShapeZone();
        updateURL();
      };

      // Hook into updatePaletteDisplays to also update make probability
      const origUpdatePaletteDisplays = updatePaletteDisplays;
      updatePaletteDisplays = function (shotData) {
        origUpdatePaletteDisplays(shotData);
        updateMakeProbability(shotData);
      };

      // ========== FIRST-TIME USER TOUR SYSTEM ==========

      const TOUR_STEPS = [
        {
          id: 'welcome',
          title: 'Welcome to ACE Shot Diagrams',
          content: `<div class="tour-welcome-icon">ðŸŽ±</div>
            <h2>Master Your Pool Game</h2>
            <p>This interactive tool helps you visualize shots, understand aiming systems, and improve your position play.</p>
            <p style="color:#8af;margin-top:12px;">Let's take a quick tour of the features!</p>`,
          target: null,
          position: 'center',
          task: null
        },
        {
          id: 'ball-rack',
          title: 'The Ball Rack',
          content: `Drag balls from this rack onto the table to set up your shot scenario.<br><br>
            The rack contains the <span class="highlight">cue ball</span> (white), <span class="highlight">numbered balls 1-15</span>, and a generic gray ball for blockers.`,
          target: '#palette-balls',
          position: 'right',
          task: 'Drag the CUE ball onto the table'
        },
        {
          id: 'place-object-ball',
          title: 'Place Object Balls',
          content: `Now place an object ball on the table. In 9-ball, you must hit the <span class="highlight">lowest numbered ball</span> first.<br><br>
            Try placing the 1-ball somewhere on the table.`,
          target: '#palette-balls',
          position: 'right',
          task: 'Drag the 1-ball onto the table'
        },
        {
          id: 'select-ball',
          title: 'Select a Ball',
          content: `<strong>Double-click</strong> (or long-press on mobile) on a ball to select it as your target.<br><br>
            Selected balls show a <span class="highlight">green ring</span>. This tells the system which ball you want to pocket.`,
          target: '#tableWrapper',
          position: 'bottom',
          task: 'Double-click the 1-ball to select it'
        },
        {
          id: 'select-pocket',
          title: 'Choose Your Pocket',
          content: `Click on any <span class="highlight">pocket</span> to set your target. The pockets glow when you hover over them.<br><br>
            Once you select a pocket, the system calculates the <span class="highlight">ghost ball</span> position - where you need to aim.`,
          target: '#tableWrapper',
          position: 'bottom',
          task: 'Click on a pocket to target it'
        },
        {
          id: 'ghost-ball',
          title: 'The Ghost Ball (AIM)',
          content: `The yellow <span class="highlight">AIM</span> indicator shows the "ghost ball" - the exact spot where the cue ball needs to be at the moment of contact.<br><br>
            Aim your cue stick at this point to pocket the object ball!`,
          target: '#ghost-ball-indicator',
          position: 'left',
          task: null
        },
        {
          id: 'shot-info',
          title: 'Shot Information',
          content: `This panel shows critical shot data:<br><br>
            â€¢ <strong>Cut Angle</strong> - How much you're cutting the ball<br>
            â€¢ <strong>Make %</strong> - Probability of pocketing<br>
            â€¢ <strong>Difficulty</strong> - Visual difficulty meter<br>
            â€¢ <strong>Overlap</strong> - Ball-to-ball contact fraction`,
          target: '#palette-shot',
          position: 'left',
          task: null
        },
        {
          id: 'cue-controls',
          title: 'Cue Ball Control',
          content: `Adjust your shot parameters here:<br><br>
            â€¢ <strong>Contact Point</strong> - Click the cue ball diagram to apply english (spin)<br>
            â€¢ <strong>Power Slider</strong> - Set shot force (1-10)<br><br>
            English affects cue ball path after contact!`,
          target: '#palette-cue',
          position: 'right',
          task: 'Try clicking the cue ball diagram to add spin'
        },
        {
          id: 'game-modes',
          title: 'Game Modes',
          content: `Switch between different pool games:<br><br>
            â€¢ <strong>9-Ball</strong> - Must hit lowest ball first<br>
            â€¢ <strong>8-Ball</strong> - Hit your suit (solids/stripes)<br>
            â€¢ <strong>10-Ball</strong> - Like 9-ball but call pocket<br>
            â€¢ <strong>Straight Pool</strong> - Any ball, call pocket<br>
            â€¢ <strong>One Pocket</strong> - Score in your pocket only`,
          target: '#palette-game',
          position: 'right',
          task: null
        },
        {
          id: 'shot-types',
          title: 'Automatic Shot Detection',
          content: `The system automatically finds the best shot:<br><br>
            â€¢ <strong>Direct</strong> - Clear path to object ball<br>
            â€¢ <strong>Kick</strong> - Bounce off rail(s) first<br>
            â€¢ <strong>Bank</strong> - Object ball banks off rail<br>
            â€¢ <strong>Combo</strong> - Hit one ball into another<br><br>
            Place a blocker ball to see kick shots in action!`,
          target: '#palette-game',
          position: 'right',
          task: null
        },
        {
          id: 'position-aids',
          title: 'Position Aids',
          content: `Enable visual helpers for position play:<br><br>
            â€¢ <strong>Tangent Line</strong> - Where CB goes with stop shot<br>
            â€¢ <strong>Follow/Draw Lines</strong> - CB path with spin<br>
            â€¢ <strong>Shape Zone</strong> - Area where CB can be to make next shot<br><br>
            These are essential for planning run-outs!`,
          target: '#palette-aids',
          position: 'left',
          task: 'Enable the Tangent Line checkbox'
        },
        {
          id: 'share-export',
          title: 'Save & Actions',
          content: `Share your diagrams and try features:<br><br>
            â€¢ <strong>Save</strong> (bottom) - Link, PNG, SVG export & saved diagrams<br>
            â€¢ <strong>Actions</strong> (top) - Break rack animation & tour<br><br>
            Try the Break button for a physics-simulated break shot!`,
          target: '#palette-save',
          position: 'top',
          task: null
        },
        {
          id: 'complete',
          title: 'You\'re Ready!',
          content: `<div class="tour-welcome-icon">ðŸ†</div>
            <h2>Tour Complete!</h2>
            <p>You now know the basics of ACE Shot Diagrams. Here are some tips:</p>
            <ul style="text-align:left;margin:12px 0;padding-left:20px;color:#aaa;">
              <li>Drag palettes by their headers to reposition</li>
              <li>Use the mirror system overlay for kick shots</li>
              <li>Try different game modes to learn the rules</li>
              <li>Export diagrams to share with friends</li>
            </ul>
            <p style="color:#0fa;margin-top:12px;">Happy shooting! ðŸŽ¯</p>`,
          target: null,
          position: 'center',
          task: null
        }
      ];

      // Tour state
      let tourActive = false;
      let tourCurrentStep = 0;
      let tourCompletedSteps = new Set();

      // Tour DOM elements
      const tourOverlay = document.getElementById('tourOverlay');
      const tourSpotlight = document.getElementById('tourSpotlight');
      const tourTooltip = document.getElementById('tourTooltip');
      const tourTitle = document.getElementById('tourTitle');
      const tourStep = document.getElementById('tourStep');
      const tourContent = document.getElementById('tourContent');
      const tourTask = document.getElementById('tourTask');
      const tourArrow = document.getElementById('tourArrow');
      const tourBack = document.getElementById('tourBack');
      const tourNext = document.getElementById('tourNext');
      const tourSkip = document.getElementById('tourSkip');

      function startTour() {
        tourActive = true;
        tourCurrentStep = 0;
        tourCompletedSteps.clear();
        tourOverlay.style.display = 'block';
        tourOverlay.classList.add('active');
        showTourStep(0);
      }

      function endTour(completed = false) {
        tourActive = false;
        tourOverlay.classList.remove('active');
        tourOverlay.style.display = 'none';
        tourTooltip.classList.remove('active');
        tourSpotlight.style.display = 'none';

        // Clear any highlights
        document.querySelectorAll('.tour-highlight').forEach(el => {
          el.classList.remove('tour-highlight');
        });

        // Save completion status
        if (completed) {
          localStorage.setItem('ace-tour-completed', 'true');
          showToast('Tour complete! You\'re ready to use ACE Shot Diagrams.');
        }
      }

      function showTourStep(stepIndex) {
        if (stepIndex < 0 || stepIndex >= TOUR_STEPS.length) return;

        tourCurrentStep = stepIndex;
        const step = TOUR_STEPS[stepIndex];

        // Update content
        tourTitle.textContent = step.title;
        tourStep.textContent = `Step ${stepIndex + 1} of ${TOUR_STEPS.length}`;
        tourContent.innerHTML = step.content;

        // Update task
        if (step.task) {
          tourTask.textContent = step.task;
          tourTask.style.display = 'block';
        } else {
          tourTask.style.display = 'none';
        }

        // Update navigation buttons
        tourBack.style.display = stepIndex > 0 ? 'inline-block' : 'none';
        tourNext.textContent = stepIndex === TOUR_STEPS.length - 1 ? 'Finish' : 'Next';

        // Clear previous highlights
        document.querySelectorAll('.tour-highlight').forEach(el => {
          el.classList.remove('tour-highlight');
        });

        // Position tooltip and spotlight
        if (step.target) {
          const targetEl = document.querySelector(step.target);
          if (targetEl) {
            targetEl.classList.add('tour-highlight');
            positionSpotlight(targetEl);
            positionTooltip(targetEl, step.position);
            tourSpotlight.style.display = 'block';
          }
        } else {
          // Center position (welcome/complete screens)
          tourSpotlight.style.display = 'none';
          tourTooltip.classList.add('tour-welcome');
          tourTooltip.style.left = '50%';
          tourTooltip.style.top = '50%';
          tourTooltip.style.transform = 'translate(-50%, -50%)';
          tourArrow.style.display = 'none';
        }

        // Show tooltip with animation
        setTimeout(() => tourTooltip.classList.add('active'), 50);
      }

      function positionSpotlight(targetEl) {
        const rect = targetEl.getBoundingClientRect();
        const padding = 8;

        tourSpotlight.style.left = (rect.left - padding) + 'px';
        tourSpotlight.style.top = (rect.top - padding) + 'px';
        tourSpotlight.style.width = (rect.width + padding * 2) + 'px';
        tourSpotlight.style.height = (rect.height + padding * 2) + 'px';
        tourSpotlight.classList.add('pulse');
      }

      function positionTooltip(targetEl, position) {
        const rect = targetEl.getBoundingClientRect();
        const tooltipWidth = 360;
        const tooltipHeight = tourTooltip.offsetHeight || 300;
        const margin = 20;

        tourTooltip.classList.remove('tour-welcome');
        tourTooltip.style.transform = 'none';
        tourArrow.style.display = 'block';

        // Remove all arrow position classes
        tourArrow.className = 'tour-tooltip-arrow';

        let left, top;

        switch (position) {
          case 'right':
            left = rect.right + margin;
            top = rect.top + rect.height / 2 - tooltipHeight / 2;
            tourArrow.classList.add('left');
            tourArrow.style.left = '-7px';
            tourArrow.style.top = '50%';
            tourArrow.style.transform = 'translateY(-50%) rotate(45deg)';
            break;
          case 'left':
            left = rect.left - tooltipWidth - margin;
            top = rect.top + rect.height / 2 - tooltipHeight / 2;
            tourArrow.classList.add('right');
            tourArrow.style.right = '-7px';
            tourArrow.style.left = 'auto';
            tourArrow.style.top = '50%';
            tourArrow.style.transform = 'translateY(-50%) rotate(45deg)';
            break;
          case 'bottom':
            left = rect.left + rect.width / 2 - tooltipWidth / 2;
            top = rect.bottom + margin;
            tourArrow.classList.add('top');
            tourArrow.style.top = '-7px';
            tourArrow.style.left = '50%';
            tourArrow.style.transform = 'translateX(-50%) rotate(45deg)';
            break;
          case 'top':
            left = rect.left + rect.width / 2 - tooltipWidth / 2;
            top = rect.top - tooltipHeight - margin;
            tourArrow.classList.add('bottom');
            tourArrow.style.bottom = '-7px';
            tourArrow.style.top = 'auto';
            tourArrow.style.left = '50%';
            tourArrow.style.transform = 'translateX(-50%) rotate(45deg)';
            break;
        }

        // Keep tooltip in viewport
        left = Math.max(10, Math.min(window.innerWidth - tooltipWidth - 10, left));
        top = Math.max(10, Math.min(window.innerHeight - tooltipHeight - 10, top));

        tourTooltip.style.left = left + 'px';
        tourTooltip.style.top = top + 'px';
      }

      function nextTourStep() {
        tourCompletedSteps.add(tourCurrentStep);
        tourTooltip.classList.remove('active');

        if (tourCurrentStep >= TOUR_STEPS.length - 1) {
          endTour(true);
        } else {
          setTimeout(() => showTourStep(tourCurrentStep + 1), 200);
        }
      }

      function prevTourStep() {
        tourTooltip.classList.remove('active');
        setTimeout(() => showTourStep(tourCurrentStep - 1), 200);
      }

      // Tour event listeners
      function setupTour() {
        const btnStartTour = document.getElementById('btnStartTour');
        if (btnStartTour) {
          btnStartTour.addEventListener('click', startTour);
        }

        tourNext.addEventListener('click', nextTourStep);
        tourBack.addEventListener('click', prevTourStep);
        tourSkip.addEventListener('click', () => endTour(false));

        // Allow clicking overlay to close tour
        tourOverlay.addEventListener('click', (e) => {
          if (e.target === tourOverlay) {
            endTour(false);
          }
        });

        // Allow Escape key to close tour
        document.addEventListener('keydown', (e) => {
          if (e.key === 'Escape' && tourActive) {
            endTour(false);
          }
        });

        // Check if first visit
        const tourCompleted = localStorage.getItem('ace-tour-completed');
        if (!tourCompleted && !window.location.hash) {
          // Show tour prompt after a short delay
          setTimeout(() => {
            if (confirm('Welcome to ACE Shot Diagrams! Would you like a quick tour of the features?')) {
              startTour();
            } else {
              localStorage.setItem('ace-tour-completed', 'true');
            }
          }, 1000);
        }
      }

      // ========== TEST SUITE ==========

      const TestSuite = {
        results: [],
        passed: 0,
        failed: 0,

        // Test runner
        async runAll() {
          this.results = [];
          this.passed = 0;
          this.failed = 0;

          console.log('%cðŸ§ª ACE Shot Diagrams - Test Suite', 'font-size:16px;font-weight:bold;color:#0fa;');
          console.log('â”€'.repeat(50));

          // Core function tests
          await this.test('vectorSubtract calculates correctly', () => {
            const result = vectorSubtract({ x: 10, y: 20 }, { x: 3, y: 5 });
            return result.x === 7 && result.y === 15;
          });

          await this.test('vectorNormalize produces unit vector', () => {
            const result = vectorNormalize({ x: 3, y: 4 });
            const length = Math.sqrt(result.x * result.x + result.y * result.y);
            return Math.abs(length - 1) < 0.0001;
          });

          await this.test('dotProduct calculates correctly', () => {
            const result = dotProduct({ x: 1, y: 0 }, { x: 0, y: 1 });
            return result === 0; // Perpendicular vectors
          });

          await this.test('rotateVector rotates 90 degrees', () => {
            const result = rotateVector({ x: 1, y: 0 }, 90);
            return Math.abs(result.x) < 0.0001 && Math.abs(result.y - 1) < 0.0001;
          });

          // State encoding/decoding tests
          await this.test('encodeState produces valid string', () => {
            const state = {
              v: 1,
              balls: { cue: { x: 25, y: 25 }, '1': { x: 50, y: 25 } },
              pocket: 'corner-br',
              ball: '1',
              mode: '9ball',
              power: 5,
              english: { x: 0, y: 0 },
              solver: 'auto'
            };
            const encoded = encodeState(state);
            return encoded.includes('v1') && encoded.includes('cue:') && encoded.includes('p:cbr');
          });

          await this.test('decodeState reverses encodeState', () => {
            const original = {
              v: 1,
              balls: { cue: { x: 25.0, y: 25.0 } },
              pocket: 'corner-br',
              ball: '1',
              mode: '9ball',
              power: 5,
              english: { x: 0.0, y: 0.0 },
              solver: 'auto'
            };
            const encoded = encodeState(original);
            const decoded = decodeState(encoded);
            return decoded.pocket === 'corner-br' && decoded.mode === '9ball';
          });

          // Make probability tests
          await this.test('calculateMakeProbability returns null for invalid data', () => {
            return calculateMakeProbability(null) === null;
          });

          await this.test('calculateMakeProbability returns high % for easy shots', () => {
            const shotData = { isReady: true, cutAngle: 10, totalDistance: 30 };
            const prob = calculateMakeProbability(shotData);
            return prob >= 80;
          });

          await this.test('calculateMakeProbability penalizes steep cuts', () => {
            const easy = calculateMakeProbability({ isReady: true, cutAngle: 10, totalDistance: 30 });
            const hard = calculateMakeProbability({ isReady: true, cutAngle: 60, totalDistance: 30 });
            return hard < easy;
          });

          await this.test('calculateMakeProbability penalizes kick shots', () => {
            const direct = calculateMakeProbability({ isReady: true, cutAngle: 30, totalDistance: 40 });
            const kick = calculateMakeProbability({ isReady: true, cutAngle: 30, totalDistance: 40, isKickShot: true });
            return kick < direct;
          });

          // DOM element tests
          await this.test('Pool table SVG exists', () => {
            return document.getElementById('pool-table-svg') !== null;
          });

          await this.test('Cue ball element exists', () => {
            return document.getElementById('ball-cue') !== null;
          });

          await this.test('All numbered balls exist (1-15)', () => {
            for (let i = 1; i <= 15; i++) {
              if (!document.getElementById(`ball-${i}`)) return false;
            }
            return true;
          });

          await this.test('Ghost ball indicator exists', () => {
            return document.getElementById('ghost-ball-indicator') !== null;
          });

          await this.test('All palettes exist', () => {
            const palettes = ['palette-balls', 'palette-cue', 'palette-game', 'palette-shot', 'palette-share'];
            return palettes.every(id => document.getElementById(id) !== null);
          });

          await this.test('Position aid elements exist', () => {
            const elements = ['tangent-line-group', 'follow-line-group', 'draw-line-group', 'shape-zone-group'];
            return elements.every(id => document.getElementById(id) !== null);
          });

          await this.test('Tour elements exist', () => {
            const elements = ['tourOverlay', 'tourSpotlight', 'tourTooltip'];
            return elements.every(id => document.getElementById(id) !== null);
          });

          // Game mode tests
          await this.test('GAME_MODES object exists with all modes', () => {
            const modes = ['NINE_BALL', 'EIGHT_BALL', 'TEN_BALL', 'STRAIGHT_POOL', 'ONE_POCKET'];
            return modes.every(m => GAME_MODES[m] !== undefined);
          });

          await this.test('9-ball mode has correct rotation rule', () => {
            return GAME_MODES.NINE_BALL.targetRule === 'rotation';
          });

          await this.test('8-ball mode has correct suit rule', () => {
            return GAME_MODES.EIGHT_BALL.targetRule === 'suit';
          });

          // Pocket centers test
          await this.test('pocketCenters has all 6 pockets', () => {
            const pockets = ['corner-tl', 'corner-tr', 'corner-bl', 'corner-br', 'side-top', 'side-bottom'];
            return pockets.every(p => pocketCenters[p] !== undefined);
          });

          // Export function tests
          await this.test('exportPNG function exists', () => {
            return typeof exportPNG === 'function';
          });

          await this.test('exportSVG function exists', () => {
            return typeof exportSVG === 'function';
          });

          await this.test('copyShareLink function exists', () => {
            return typeof copyShareLink === 'function';
          });

          // Position aid function tests
          await this.test('updateTangentLine function exists', () => {
            return typeof updateTangentLine === 'function';
          });

          await this.test('updateFollowDrawLines function exists', () => {
            return typeof updateFollowDrawLines === 'function';
          });

          await this.test('updateShapeZone function exists', () => {
            return typeof updateShapeZone === 'function';
          });

          // Tour function tests
          await this.test('TOUR_STEPS has expected steps', () => {
            return TOUR_STEPS.length >= 10 && TOUR_STEPS[0].id === 'welcome';
          });

          await this.test('startTour function exists', () => {
            return typeof startTour === 'function';
          });

          await this.test('endTour function exists', () => {
            return typeof endTour === 'function';
          });

          // Local storage save/load tests
          await this.test('getSavedDiagrams function exists', () => {
            return typeof getSavedDiagrams === 'function';
          });

          await this.test('saveDiagram function exists', () => {
            return typeof saveDiagram === 'function';
          });

          await this.test('loadDiagram function exists', () => {
            return typeof loadDiagram === 'function';
          });

          await this.test('deleteDiagram function exists', () => {
            return typeof deleteDiagram === 'function';
          });

          await this.test('renderSavedList function exists', () => {
            return typeof renderSavedList === 'function';
          });

          await this.test('Saved diagrams list element exists', () => {
            return document.getElementById('savedDiagramsList') !== null;
          });

          await this.test('Save input element exists', () => {
            return document.getElementById('saveDiagramName') !== null;
          });

          await this.test('Save button element exists', () => {
            return document.getElementById('btnSaveDiagram') !== null;
          });

          // OB path blocking tests
          await this.test('isPathBlockedByBall detects intersection', () => {
            // Path from (25,35) to (98.5,1.5) should be blocked by ball at (70,15)
            const start = { x: 25, y: 35 };
            const end = { x: 98.5, y: 1.5 };
            const ballCenter = { x: 70, y: 15 };
            const ballRadius = BALL_RADIUS * 2.1;
            return isPathBlockedByBall(start, end, ballCenter, ballRadius) === true;
          });

          await this.test('isPathBlockedByAnyBall finds blocking balls', () => {
            // Temporarily set up test positions
            const origPositions = { ...ballPositions };
            ballPositions['testball'] = { x: 70, y: 15 };

            const result = isPathBlockedByAnyBall(
              { x: 25, y: 35 },  // start
              { x: 98.5, y: 1.5 },  // end
              ['cue', 'ghost', 'gray']  // exclude
            );

            // Restore original
            delete ballPositions['testball'];
            Object.assign(ballPositions, origPositions);

            return result.blocked && result.blockingBalls.includes('testball');
          });

          // Print summary
          console.log('â”€'.repeat(50));
          console.log(`%câœ“ Passed: ${this.passed}`, 'color:#0f0;font-weight:bold;');
          console.log(`%câœ— Failed: ${this.failed}`, this.failed > 0 ? 'color:#f00;font-weight:bold;' : 'color:#888;');
          console.log(`Total: ${this.passed + this.failed} tests`);

          if (this.failed === 0) {
            console.log('%cðŸŽ‰ All tests passed!', 'font-size:14px;color:#0fa;');
          }

          return { passed: this.passed, failed: this.failed, results: this.results };
        },

        async test(name, fn) {
          try {
            const result = await fn();
            if (result) {
              this.passed++;
              this.results.push({ name, status: 'passed' });
              console.log(`%c  âœ“ ${name}`, 'color:#0f0;');
            } else {
              this.failed++;
              this.results.push({ name, status: 'failed', error: 'Assertion failed' });
              console.log(`%c  âœ— ${name}`, 'color:#f00;');
            }
          } catch (e) {
            this.failed++;
            this.results.push({ name, status: 'failed', error: e.message });
            console.log(`%c  âœ— ${name}: ${e.message}`, 'color:#f00;');
          }
        }
      };

      // Expose test suite globally for console access
      window.ACETests = TestSuite;

      // Initialize tour
      setTimeout(setupTour, 200);

      // ========== DEBUG TOOLS ==========
      // Expose internal state for browser console debugging
      window.DEBUG = {
        // State inspection
        state: () => ({
          ballPositions: { ...ballPositions },
          selectedBallId,
          selectedPocket,
          isBreakSetup,
          isShotAnimating,
          isBreakAnimating
        }),
        ghost: () => ballPositions['ghost'],
        cue: () => ballPositions['cue'],
        balls: () => ({ ...ballPositions }),

        // Test API: Place a ball on the table
        placeBall: (ballId, x, y) => {
          const ball = document.getElementById(`ball-${ballId}`);
          if (!ball) throw new Error(`Ball not found: ${ballId}`);
          ballPositions[ballId] = { x, y };
          positionBallOnTable(ball, x, y);
          ball.classList.add('on-table');
          updateShotGeometry();
          return { success: true, position: { x, y } };
        },

        // Test API: Select an object ball
        selectBall: (ballId) => {
          const ball = document.getElementById(`ball-${ballId}`);
          if (!ball) throw new Error(`Ball not found: ${ballId}`);
          selectBall(ballId);
          return { success: true, selectedBallId: ballId };
        },

        // Test API: Select a pocket
        selectPocket: (pocketId) => {
          const pocket = document.querySelector(`.pocket-target[data-pocket="${pocketId}"]`);
          if (!pocket) throw new Error(`Pocket not found: ${pocketId}`);
          // Use the internal selectPocket function which also auto-positions ghost ball
          selectPocket(pocketId);
          return { success: true, selectedPocket: pocketId };
        },

        // Shot validation
        testShot: () => {
          const cue = ballPositions['cue'];
          const ghost = ballPositions['ghost'];
          console.log('Cue:', cue);
          console.log('Ghost:', ghost);
          console.log('isBreakSetup:', isBreakSetup);
          console.log('Valid shot:', !!(cue && ghost));
          return { cue, ghost, isBreakSetup, valid: !!(cue && ghost) };
        },

        // Watch ghost ball changes
        watchGhost: () => {
          const originalValue = ballPositions['ghost'];
          Object.defineProperty(ballPositions, 'ghost', {
            get() { return this._ghost; },
            set(val) {
              console.log('%c[Ghost Changed]', 'color: #ff6b6b; font-weight: bold',
                val ? `{x: ${val.x?.toFixed(1)}, y: ${val.y?.toFixed(1)}}` : 'null/undefined');
              console.trace('Ghost ball set from:');
              this._ghost = val;
            },
            configurable: true
          });
          ballPositions._ghost = originalValue;
          console.log('%cðŸ” Now watching ghost ball changes', 'color: #4CAF50; font-weight: bold');
        },

        // Help
        help: () => {
          console.log(`
%cDEBUG Commands:%c
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
DEBUG.state()     - Full state snapshot
DEBUG.ghost()     - Ghost ball position
DEBUG.cue()       - Cue ball position
DEBUG.balls()     - All ball positions
DEBUG.testShot()  - Validate shot setup
DEBUG.watchGhost() - Watch ghost ball changes (logs on set)
DEBUG.help()      - This help message
          `, 'color: #4CAF50; font-weight: bold; font-size: 14px;', '');
        }
      };

      console.log('%cðŸŽ± DEBUG tools loaded - Type DEBUG.help() for commands',
                  'color: #4CAF50; font-weight: bold; font-size: 14px;');

    })();
  </script>
</body>

</html>